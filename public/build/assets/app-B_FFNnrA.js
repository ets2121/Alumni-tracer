function Qc(n, e) { return function () { return n.apply(e, arguments) } } const { toString: Ph } = Object.prototype, { getPrototypeOf: Jo } = Object, { iterator: Ki, toStringTag: Zc } = Symbol, qi = (n => e => { const t = Ph.call(e); return n[t] || (n[t] = t.slice(8, -1).toLowerCase()) })(Object.create(null)), ve = n => (n = n.toLowerCase(), e => qi(e) === n), Ji = n => e => typeof e === n, { isArray: Tn } = Array, xn = Ji("undefined"); function br(n) { return n !== null && !xn(n) && n.constructor !== null && !xn(n.constructor) && he(n.constructor.isBuffer) && n.constructor.isBuffer(n) } const eu = ve("ArrayBuffer"); function Lh(n) { let e; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && eu(n.buffer), e } const Bh = Ji("string"), he = Ji("function"), tu = Ji("number"), xr = n => n !== null && typeof n == "object", Fh = n => n === !0 || n === !1, Kr = n => { if (qi(n) !== "object") return !1; const e = Jo(n); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Zc in n) && !(Ki in n) }, zh = n => { if (!xr(n) || br(n)) return !1; try { return Object.keys(n).length === 0 && Object.getPrototypeOf(n) === Object.prototype } catch { return !1 } }, $h = ve("Date"), Hh = ve("File"), jh = ve("Blob"), Vh = ve("FileList"), Uh = n => xr(n) && he(n.pipe), Wh = n => { let e; return n && (typeof FormData == "function" && n instanceof FormData || he(n.append) && ((e = qi(n)) === "formdata" || e === "object" && he(n.toString) && n.toString() === "[object FormData]")) }, Kh = ve("URLSearchParams"), [qh, Jh, Gh, Yh] = ["ReadableStream", "Request", "Response", "Headers"].map(ve), Xh = n => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Sr(n, e, { allOwnKeys: t = !1 } = {}) { if (n === null || typeof n > "u") return; let r, i; if (typeof n != "object" && (n = [n]), Tn(n)) for (r = 0, i = n.length; r < i; r++)e.call(null, n[r], r, n); else { if (br(n)) return; const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n), o = s.length; let l; for (r = 0; r < o; r++)l = s[r], e.call(null, n[l], l, n) } } function nu(n, e) { if (br(n)) return null; e = e.toLowerCase(); const t = Object.keys(n); let r = t.length, i; for (; r-- > 0;)if (i = t[r], e === i.toLowerCase()) return i; return null } const vt = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, ru = n => !xn(n) && n !== vt; function eo() { const { caseless: n, skipUndefined: e } = ru(this) && this || {}, t = {}, r = (i, s) => { const o = n && nu(t, s) || s; Kr(t[o]) && Kr(i) ? t[o] = eo(t[o], i) : Kr(i) ? t[o] = eo({}, i) : Tn(i) ? t[o] = i.slice() : (!e || !xn(i)) && (t[o] = i) }; for (let i = 0, s = arguments.length; i < s; i++)arguments[i] && Sr(arguments[i], r); return t } const Qh = (n, e, t, { allOwnKeys: r } = {}) => (Sr(e, (i, s) => { t && he(i) ? Object.defineProperty(n, s, { value: Qc(i, t), writable: !0, enumerable: !0, configurable: !0 }) : Object.defineProperty(n, s, { value: i, writable: !0, enumerable: !0, configurable: !0 }) }, { allOwnKeys: r }), n), Zh = n => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), ep = (n, e, t, r) => { n.prototype = Object.create(e.prototype, r), Object.defineProperty(n.prototype, "constructor", { value: n, writable: !0, enumerable: !1, configurable: !0 }), Object.defineProperty(n, "super", { value: e.prototype }), t && Object.assign(n.prototype, t) }, tp = (n, e, t, r) => { let i, s, o; const l = {}; if (e = e || {}, n == null) return e; do { for (i = Object.getOwnPropertyNames(n), s = i.length; s-- > 0;)o = i[s], (!r || r(o, n, e)) && !l[o] && (e[o] = n[o], l[o] = !0); n = t !== !1 && Jo(n) } while (n && (!t || t(n, e)) && n !== Object.prototype); return e }, np = (n, e, t) => { n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length; const r = n.indexOf(e, t); return r !== -1 && r === t }, rp = n => { if (!n) return null; if (Tn(n)) return n; let e = n.length; if (!tu(e)) return null; const t = new Array(e); for (; e-- > 0;)t[e] = n[e]; return t }, ip = (n => e => n && e instanceof n)(typeof Uint8Array < "u" && Jo(Uint8Array)), sp = (n, e) => { const r = (n && n[Ki]).call(n); let i; for (; (i = r.next()) && !i.done;) { const s = i.value; e.call(n, s[0], s[1]) } }, op = (n, e) => { let t; const r = []; for (; (t = n.exec(e)) !== null;)r.push(t); return r }, lp = ve("HTMLFormElement"), ap = n => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, r, i) { return r.toUpperCase() + i }), ta = (({ hasOwnProperty: n }) => (e, t) => n.call(e, t))(Object.prototype), cp = ve("RegExp"), iu = (n, e) => { const t = Object.getOwnPropertyDescriptors(n), r = {}; Sr(t, (i, s) => { let o; (o = e(i, s, n)) !== !1 && (r[s] = o || i) }), Object.defineProperties(n, r) }, up = n => { iu(n, (e, t) => { if (he(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1) return !1; const r = n[t]; if (he(r)) { if (e.enumerable = !1, "writable" in e) { e.writable = !1; return } e.set || (e.set = () => { throw Error("Can not rewrite read-only method '" + t + "'") }) } }) }, fp = (n, e) => { const t = {}, r = i => { i.forEach(s => { t[s] = !0 }) }; return Tn(n) ? r(n) : r(String(n).split(e)), t }, dp = () => { }, hp = (n, e) => n != null && Number.isFinite(n = +n) ? n : e; function pp(n) { return !!(n && he(n.append) && n[Zc] === "FormData" && n[Ki]) } const mp = n => { const e = new Array(10), t = (r, i) => { if (xr(r)) { if (e.indexOf(r) >= 0) return; if (br(r)) return r; if (!("toJSON" in r)) { e[i] = r; const s = Tn(r) ? [] : {}; return Sr(r, (o, l) => { const a = t(o, i + 1); !xn(a) && (s[l] = a) }), e[i] = void 0, s } } return r }; return t(n, 0) }, gp = ve("AsyncFunction"), yp = n => n && (xr(n) || he(n)) && he(n.then) && he(n.catch), su = ((n, e) => n ? setImmediate : e ? ((t, r) => (vt.addEventListener("message", ({ source: i, data: s }) => { i === vt && s === t && r.length && r.shift()() }, !1), i => { r.push(i), vt.postMessage(t, "*") }))(`axios@${Math.random()}`, []) : t => setTimeout(t))(typeof setImmediate == "function", he(vt.postMessage)), bp = typeof queueMicrotask < "u" ? queueMicrotask.bind(vt) : typeof process < "u" && process.nextTick || su, xp = n => n != null && he(n[Ki]), b = { isArray: Tn, isArrayBuffer: eu, isBuffer: br, isFormData: Wh, isArrayBufferView: Lh, isString: Bh, isNumber: tu, isBoolean: Fh, isObject: xr, isPlainObject: Kr, isEmptyObject: zh, isReadableStream: qh, isRequest: Jh, isResponse: Gh, isHeaders: Yh, isUndefined: xn, isDate: $h, isFile: Hh, isBlob: jh, isRegExp: cp, isFunction: he, isStream: Uh, isURLSearchParams: Kh, isTypedArray: ip, isFileList: Vh, forEach: Sr, merge: eo, extend: Qh, trim: Xh, stripBOM: Zh, inherits: ep, toFlatObject: tp, kindOf: qi, kindOfTest: ve, endsWith: np, toArray: rp, forEachEntry: sp, matchAll: op, isHTMLForm: lp, hasOwnProperty: ta, hasOwnProp: ta, reduceDescriptors: iu, freezeMethods: up, toObjectSet: fp, toCamelCase: ap, noop: dp, toFiniteNumber: hp, findKey: nu, global: vt, isContextDefined: ru, isSpecCompliantForm: pp, toJSONObject: mp, isAsyncFn: gp, isThenable: yp, setImmediate: su, asap: bp, isIterable: xp }; let N = class ou extends Error { static from(e, t, r, i, s, o) { const l = new ou(e.message, t || e.code, r, i, s); return l.cause = e, l.name = e.name, o && Object.assign(l, o), l } constructor(e, t, r, i, s) { super(e), this.name = "AxiosError", this.isAxiosError = !0, t && (this.code = t), r && (this.config = r), i && (this.request = i), s && (this.response = s, this.status = s.status) } toJSON() { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: b.toJSONObject(this.config), code: this.code, status: this.status } } }; N.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE"; N.ERR_BAD_OPTION = "ERR_BAD_OPTION"; N.ECONNABORTED = "ECONNABORTED"; N.ETIMEDOUT = "ETIMEDOUT"; N.ERR_NETWORK = "ERR_NETWORK"; N.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS"; N.ERR_DEPRECATED = "ERR_DEPRECATED"; N.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE"; N.ERR_BAD_REQUEST = "ERR_BAD_REQUEST"; N.ERR_CANCELED = "ERR_CANCELED"; N.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT"; N.ERR_INVALID_URL = "ERR_INVALID_URL"; const Sp = null; function to(n) { return b.isPlainObject(n) || b.isArray(n) } function lu(n) { return b.endsWith(n, "[]") ? n.slice(0, -2) : n } function na(n, e, t) { return n ? n.concat(e).map(function (i, s) { return i = lu(i), !t && s ? "[" + i + "]" : i }).join(t ? "." : "") : e } function wp(n) { return b.isArray(n) && !n.some(to) } const kp = b.toFlatObject(b, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function Gi(n, e, t) { if (!b.isObject(n)) throw new TypeError("target must be an object"); e = e || new FormData, t = b.toFlatObject(t, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (g, m) { return !b.isUndefined(m[g]) }); const r = t.metaTokens, i = t.visitor || u, s = t.dots, o = t.indexes, a = (t.Blob || typeof Blob < "u" && Blob) && b.isSpecCompliantForm(e); if (!b.isFunction(i)) throw new TypeError("visitor must be a function"); function c(h) { if (h === null) return ""; if (b.isDate(h)) return h.toISOString(); if (b.isBoolean(h)) return h.toString(); if (!a && b.isBlob(h)) throw new N("Blob is not supported. Use a Buffer instead."); return b.isArrayBuffer(h) || b.isTypedArray(h) ? a && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h } function u(h, g, m) { let y = h; if (h && !m && typeof h == "object") { if (b.endsWith(g, "{}")) g = r ? g : g.slice(0, -2), h = JSON.stringify(h); else if (b.isArray(h) && wp(h) || (b.isFileList(h) || b.endsWith(g, "[]")) && (y = b.toArray(h))) return g = lu(g), y.forEach(function (k, M) { !(b.isUndefined(k) || k === null) && e.append(o === !0 ? na([g], M, s) : o === null ? g : g + "[]", c(k)) }), !1 } return to(h) ? !0 : (e.append(na(m, g, s), c(h)), !1) } const f = [], d = Object.assign(kp, { defaultVisitor: u, convertValue: c, isVisitable: to }); function p(h, g) { if (!b.isUndefined(h)) { if (f.indexOf(h) !== -1) throw Error("Circular reference detected in " + g.join(".")); f.push(h), b.forEach(h, function (y, S) { (!(b.isUndefined(y) || y === null) && i.call(e, y, b.isString(S) ? S.trim() : S, g, d)) === !0 && p(y, g ? g.concat(S) : [S]) }), f.pop() } } if (!b.isObject(n)) throw new TypeError("data must be an object"); return p(n), e } function ra(n) { const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (r) { return e[r] }) } function Go(n, e) { this._pairs = [], n && Gi(n, this, e) } const au = Go.prototype; au.append = function (e, t) { this._pairs.push([e, t]) }; au.toString = function (e) { const t = e ? function (r) { return e.call(this, r, ra) } : ra; return this._pairs.map(function (i) { return t(i[0]) + "=" + t(i[1]) }, "").join("&") }; function Ep(n) { return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function cu(n, e, t) { if (!e) return n; const r = t && t.encode || Ep, i = b.isFunction(t) ? { serialize: t } : t, s = i && i.serialize; let o; if (s ? o = s(e, i) : o = b.isURLSearchParams(e) ? e.toString() : new Go(e, i).toString(r), o) { const l = n.indexOf("#"); l !== -1 && (n = n.slice(0, l)), n += (n.indexOf("?") === -1 ? "?" : "&") + o } return n } class ia { constructor() { this.handlers = [] } use(e, t, r) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { b.forEach(this.handlers, function (r) { r !== null && e(r) }) } } const uu = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Cp = typeof URLSearchParams < "u" ? URLSearchParams : Go, Op = typeof FormData < "u" ? FormData : null, Tp = typeof Blob < "u" ? Blob : null, Mp = { isBrowser: !0, classes: { URLSearchParams: Cp, FormData: Op, Blob: Tp }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Yo = typeof window < "u" && typeof document < "u", no = typeof navigator == "object" && navigator || void 0, Ap = Yo && (!no || ["ReactNative", "NativeScript", "NS"].indexOf(no.product) < 0), Np = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Rp = Yo && window.location.href || "http://localhost", vp = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Yo, hasStandardBrowserEnv: Ap, hasStandardBrowserWebWorkerEnv: Np, navigator: no, origin: Rp }, Symbol.toStringTag, { value: "Module" })), oe = { ...vp, ...Mp }; function _p(n, e) { return Gi(n, new oe.classes.URLSearchParams, { visitor: function (t, r, i, s) { return oe.isNode && b.isBuffer(t) ? (this.append(r, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments) }, ...e }) } function Dp(n) { return b.matchAll(/\w+|\[(\w*)]/g, n).map(e => e[0] === "[]" ? "" : e[1] || e[0]) } function Ip(n) { const e = {}, t = Object.keys(n); let r; const i = t.length; let s; for (r = 0; r < i; r++)s = t[r], e[s] = n[s]; return e } function fu(n) { function e(t, r, i, s) { let o = t[s++]; if (o === "__proto__") return !0; const l = Number.isFinite(+o), a = s >= t.length; return o = !o && b.isArray(i) ? i.length : o, a ? (b.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !l) : ((!i[o] || !b.isObject(i[o])) && (i[o] = []), e(t, r, i[o], s) && b.isArray(i[o]) && (i[o] = Ip(i[o])), !l) } if (b.isFormData(n) && b.isFunction(n.entries)) { const t = {}; return b.forEachEntry(n, (r, i) => { e(Dp(r), i, t, 0) }), t } return null } function Pp(n, e, t) { if (b.isString(n)) try { return (e || JSON.parse)(n), b.trim(n) } catch (r) { if (r.name !== "SyntaxError") throw r } return (t || JSON.stringify)(n) } const wr = { transitional: uu, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const r = t.getContentType() || "", i = r.indexOf("application/json") > -1, s = b.isObject(e); if (s && b.isHTMLForm(e) && (e = new FormData(e)), b.isFormData(e)) return i ? JSON.stringify(fu(e)) : e; if (b.isArrayBuffer(e) || b.isBuffer(e) || b.isStream(e) || b.isFile(e) || b.isBlob(e) || b.isReadableStream(e)) return e; if (b.isArrayBufferView(e)) return e.buffer; if (b.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let l; if (s) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return _p(e, this.formSerializer).toString(); if ((l = b.isFileList(e)) || r.indexOf("multipart/form-data") > -1) { const a = this.env && this.env.FormData; return Gi(l ? { "files[]": e } : e, a && new a, this.formSerializer) } } return s || i ? (t.setContentType("application/json", !1), Pp(e)) : e }], transformResponse: [function (e) { const t = this.transitional || wr.transitional, r = t && t.forcedJSONParsing, i = this.responseType === "json"; if (b.isResponse(e) || b.isReadableStream(e)) return e; if (e && b.isString(e) && (r && !this.responseType || i)) { const o = !(t && t.silentJSONParsing) && i; try { return JSON.parse(e, this.parseReviver) } catch (l) { if (o) throw l.name === "SyntaxError" ? N.from(l, N.ERR_BAD_RESPONSE, this, null, this.response) : l } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: oe.classes.FormData, Blob: oe.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; b.forEach(["delete", "get", "head", "post", "put", "patch"], n => { wr.headers[n] = {} }); const Lp = b.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Bp = n => {
  const e = {}; let t, r, i; return n && n.split(`
`).forEach(function (o) { i = o.indexOf(":"), t = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!t || e[t] && Lp[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r) }), e
}, sa = Symbol("internals"); function In(n) { return n && String(n).trim().toLowerCase() } function qr(n) { return n === !1 || n == null ? n : b.isArray(n) ? n.map(qr) : String(n) } function Fp(n) { const e = Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = t.exec(n);)e[r[1]] = r[2]; return e } const zp = n => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim()); function ws(n, e, t, r, i) { if (b.isFunction(r)) return r.call(this, e, t); if (i && (e = t), !!b.isString(e)) { if (b.isString(r)) return e.indexOf(r) !== -1; if (b.isRegExp(r)) return r.test(e) } } function $p(n) { return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r) } function Hp(n, e) { const t = b.toCamelCase(" " + e);["get", "set", "has"].forEach(r => { Object.defineProperty(n, r + t, { value: function (i, s, o) { return this[r].call(this, e, i, s, o) }, configurable: !0 }) }) } let pe = class {
  constructor(e) { e && this.set(e) } set(e, t, r) { const i = this; function s(l, a, c) { const u = In(a); if (!u) throw new Error("header name must be a non-empty string"); const f = b.findKey(i, u); (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || a] = qr(l)) } const o = (l, a) => b.forEach(l, (c, u) => s(c, u, a)); if (b.isPlainObject(e) || e instanceof this.constructor) o(e, t); else if (b.isString(e) && (e = e.trim()) && !zp(e)) o(Bp(e), t); else if (b.isObject(e) && b.isIterable(e)) { let l = {}, a, c; for (const u of e) { if (!b.isArray(u)) throw TypeError("Object iterator must return a key-value pair"); l[c = u[0]] = (a = l[c]) ? b.isArray(a) ? [...a, u[1]] : [a, u[1]] : u[1] } o(l, t) } else e != null && s(t, e, r); return this } get(e, t) { if (e = In(e), e) { const r = b.findKey(this, e); if (r) { const i = this[r]; if (!t) return i; if (t === !0) return Fp(i); if (b.isFunction(t)) return t.call(this, i, r); if (b.isRegExp(t)) return t.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = In(e), e) { const r = b.findKey(this, e); return !!(r && this[r] !== void 0 && (!t || ws(this, this[r], r, t))) } return !1 } delete(e, t) { const r = this; let i = !1; function s(o) { if (o = In(o), o) { const l = b.findKey(r, o); l && (!t || ws(r, r[l], l, t)) && (delete r[l], i = !0) } } return b.isArray(e) ? e.forEach(s) : s(e), i } clear(e) { const t = Object.keys(this); let r = t.length, i = !1; for (; r--;) { const s = t[r]; (!e || ws(this, this[s], s, e, !0)) && (delete this[s], i = !0) } return i } normalize(e) { const t = this, r = {}; return b.forEach(this, (i, s) => { const o = b.findKey(r, s); if (o) { t[o] = qr(i), delete t[s]; return } const l = e ? $p(s) : String(s).trim(); l !== s && delete t[s], t[l] = qr(i), r[l] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return b.forEach(this, (r, i) => { r != null && r !== !1 && (t[i] = e && b.isArray(r) ? r.join(", ") : r) }), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`)
  } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const r = new this(e); return t.forEach(i => r.set(i)), r } static accessor(e) { const r = (this[sa] = this[sa] = { accessors: {} }).accessors, i = this.prototype; function s(o) { const l = In(o); r[l] || (Hp(i, o), r[l] = !0) } return b.isArray(e) ? e.forEach(s) : s(e), this }
}; pe.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); b.reduceDescriptors(pe.prototype, ({ value: n }, e) => { let t = e[0].toUpperCase() + e.slice(1); return { get: () => n, set(r) { this[t] = r } } }); b.freezeMethods(pe); function ks(n, e) { const t = this || wr, r = e || t, i = pe.from(r.headers); let s = r.data; return b.forEach(n, function (l) { s = l.call(t, s, i.normalize(), e ? e.status : void 0) }), i.normalize(), s } function du(n) { return !!(n && n.__CANCEL__) } let kr = class extends N { constructor(e, t, r) { super(e ?? "canceled", N.ERR_CANCELED, t, r), this.name = "CanceledError", this.__CANCEL__ = !0 } }; function hu(n, e, t) { const r = t.config.validateStatus; !t.status || !r || r(t.status) ? n(t) : e(new N("Request failed with status code " + t.status, [N.ERR_BAD_REQUEST, N.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t)) } function jp(n) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n); return e && e[1] || "" } function Vp(n, e) { n = n || 10; const t = new Array(n), r = new Array(n); let i = 0, s = 0, o; return e = e !== void 0 ? e : 1e3, function (a) { const c = Date.now(), u = r[s]; o || (o = c), t[i] = a, r[i] = c; let f = s, d = 0; for (; f !== i;)d += t[f++], f = f % n; if (i = (i + 1) % n, i === s && (s = (s + 1) % n), c - o < e) return; const p = u && c - u; return p ? Math.round(d * 1e3 / p) : void 0 } } function Up(n, e) { let t = 0, r = 1e3 / e, i, s; const o = (c, u = Date.now()) => { t = u, i = null, s && (clearTimeout(s), s = null), n(...c) }; return [(...c) => { const u = Date.now(), f = u - t; f >= r ? o(c, u) : (i = c, s || (s = setTimeout(() => { s = null, o(i) }, r - f))) }, () => i && o(i)] } const ti = (n, e, t = 3) => { let r = 0; const i = Vp(50, 250); return Up(s => { const o = s.loaded, l = s.lengthComputable ? s.total : void 0, a = o - r, c = i(a), u = o <= l; r = o; const f = { loaded: o, total: l, progress: l ? o / l : void 0, bytes: a, rate: c || void 0, estimated: c && l && u ? (l - o) / c : void 0, event: s, lengthComputable: l != null, [e ? "download" : "upload"]: !0 }; n(f) }, t) }, oa = (n, e) => { const t = n != null; return [r => e[0]({ lengthComputable: t, total: n, loaded: r }), e[1]] }, la = n => (...e) => b.asap(() => n(...e)), Wp = oe.hasStandardBrowserEnv ? ((n, e) => t => (t = new URL(t, oe.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(new URL(oe.origin), oe.navigator && /(msie|trident)/i.test(oe.navigator.userAgent)) : () => !0, Kp = oe.hasStandardBrowserEnv ? { write(n, e, t, r, i, s, o) { if (typeof document > "u") return; const l = [`${n}=${encodeURIComponent(e)}`]; b.isNumber(t) && l.push(`expires=${new Date(t).toUTCString()}`), b.isString(r) && l.push(`path=${r}`), b.isString(i) && l.push(`domain=${i}`), s === !0 && l.push("secure"), b.isString(o) && l.push(`SameSite=${o}`), document.cookie = l.join("; ") }, read(n) { if (typeof document > "u") return null; const e = document.cookie.match(new RegExp("(?:^|; )" + n + "=([^;]*)")); return e ? decodeURIComponent(e[1]) : null }, remove(n) { this.write(n, "", Date.now() - 864e5, "/") } } : { write() { }, read() { return null }, remove() { } }; function qp(n) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n) } function Jp(n, e) { return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n } function pu(n, e, t) { let r = !qp(e); return n && (r || t == !1) ? Jp(n, e) : e } const aa = n => n instanceof pe ? { ...n } : n; function qt(n, e) { e = e || {}; const t = {}; function r(c, u, f, d) { return b.isPlainObject(c) && b.isPlainObject(u) ? b.merge.call({ caseless: d }, c, u) : b.isPlainObject(u) ? b.merge({}, u) : b.isArray(u) ? u.slice() : u } function i(c, u, f, d) { if (b.isUndefined(u)) { if (!b.isUndefined(c)) return r(void 0, c, f, d) } else return r(c, u, f, d) } function s(c, u) { if (!b.isUndefined(u)) return r(void 0, u) } function o(c, u) { if (b.isUndefined(u)) { if (!b.isUndefined(c)) return r(void 0, c) } else return r(void 0, u) } function l(c, u, f) { if (f in e) return r(c, u); if (f in n) return r(void 0, c) } const a = { url: s, method: s, data: s, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: l, headers: (c, u, f) => i(aa(c), aa(u), f, !0) }; return b.forEach(Object.keys({ ...n, ...e }), function (u) { const f = a[u] || i, d = f(n[u], e[u], u); b.isUndefined(d) && f !== l || (t[u] = d) }), t } const mu = n => { const e = qt({}, n); let { data: t, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: l } = e; if (e.headers = o = pe.from(o), e.url = cu(pu(e.baseURL, e.url, e.allowAbsoluteUrls), n.params, n.paramsSerializer), l && o.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))), b.isFormData(t)) { if (oe.hasStandardBrowserEnv || oe.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0); else if (b.isFunction(t.getHeaders)) { const a = t.getHeaders(), c = ["content-type", "content-length"]; Object.entries(a).forEach(([u, f]) => { c.includes(u.toLowerCase()) && o.set(u, f) }) } } if (oe.hasStandardBrowserEnv && (r && b.isFunction(r) && (r = r(e)), r || r !== !1 && Wp(e.url))) { const a = i && s && Kp.read(s); a && o.set(i, a) } return e }, Gp = typeof XMLHttpRequest < "u", Yp = Gp && function (n) { return new Promise(function (t, r) { const i = mu(n); let s = i.data; const o = pe.from(i.headers).normalize(); let { responseType: l, onUploadProgress: a, onDownloadProgress: c } = i, u, f, d, p, h; function g() { p && p(), h && h(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u) } let m = new XMLHttpRequest; m.open(i.method.toUpperCase(), i.url, !0), m.timeout = i.timeout; function y() { if (!m) return; const k = pe.from("getAllResponseHeaders" in m && m.getAllResponseHeaders()), T = { data: !l || l === "text" || l === "json" ? m.responseText : m.response, status: m.status, statusText: m.statusText, headers: k, config: n, request: m }; hu(function (C) { t(C), g() }, function (C) { r(C), g() }, T), m = null } "onloadend" in m ? m.onloadend = y : m.onreadystatechange = function () { !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(y) }, m.onabort = function () { m && (r(new N("Request aborted", N.ECONNABORTED, n, m)), m = null) }, m.onerror = function (M) { const T = M && M.message ? M.message : "Network Error", D = new N(T, N.ERR_NETWORK, n, m); D.event = M || null, r(D), m = null }, m.ontimeout = function () { let M = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded"; const T = i.transitional || uu; i.timeoutErrorMessage && (M = i.timeoutErrorMessage), r(new N(M, T.clarifyTimeoutError ? N.ETIMEDOUT : N.ECONNABORTED, n, m)), m = null }, s === void 0 && o.setContentType(null), "setRequestHeader" in m && b.forEach(o.toJSON(), function (M, T) { m.setRequestHeader(T, M) }), b.isUndefined(i.withCredentials) || (m.withCredentials = !!i.withCredentials), l && l !== "json" && (m.responseType = i.responseType), c && ([d, h] = ti(c, !0), m.addEventListener("progress", d)), a && m.upload && ([f, p] = ti(a), m.upload.addEventListener("progress", f), m.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (u = k => { m && (r(!k || k.type ? new kr(null, n, m) : k), m.abort(), m = null) }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u))); const S = jp(i.url); if (S && oe.protocols.indexOf(S) === -1) { r(new N("Unsupported protocol " + S + ":", N.ERR_BAD_REQUEST, n)); return } m.send(s || null) }) }, Xp = (n, e) => { const { length: t } = n = n ? n.filter(Boolean) : []; if (e || t) { let r = new AbortController, i; const s = function (c) { if (!i) { i = !0, l(); const u = c instanceof Error ? c : this.reason; r.abort(u instanceof N ? u : new kr(u instanceof Error ? u.message : u)) } }; let o = e && setTimeout(() => { o = null, s(new N(`timeout of ${e}ms exceeded`, N.ETIMEDOUT)) }, e); const l = () => { n && (o && clearTimeout(o), o = null, n.forEach(c => { c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s) }), n = null) }; n.forEach(c => c.addEventListener("abort", s)); const { signal: a } = r; return a.unsubscribe = () => b.asap(l), a } }, Qp = function* (n, e) { let t = n.byteLength; if (t < e) { yield n; return } let r = 0, i; for (; r < t;)i = r + e, yield n.slice(r, i), r = i }, Zp = async function* (n, e) { for await (const t of em(n)) yield* Qp(t, e) }, em = async function* (n) { if (n[Symbol.asyncIterator]) { yield* n; return } const e = n.getReader(); try { for (; ;) { const { done: t, value: r } = await e.read(); if (t) break; yield r } } finally { await e.cancel() } }, ca = (n, e, t, r) => { const i = Zp(n, e); let s = 0, o, l = a => { o || (o = !0, r && r(a)) }; return new ReadableStream({ async pull(a) { try { const { done: c, value: u } = await i.next(); if (c) { l(), a.close(); return } let f = u.byteLength; if (t) { let d = s += f; t(d) } a.enqueue(new Uint8Array(u)) } catch (c) { throw l(c), c } }, cancel(a) { return l(a), i.return() } }, { highWaterMark: 2 }) }, ua = 64 * 1024, { isFunction: Ar } = b, tm = (({ Request: n, Response: e }) => ({ Request: n, Response: e }))(b.global), { ReadableStream: fa, TextEncoder: da } = b.global, ha = (n, ...e) => { try { return !!n(...e) } catch { return !1 } }, nm = n => { n = b.merge.call({ skipUndefined: !0 }, tm, n); const { fetch: e, Request: t, Response: r } = n, i = e ? Ar(e) : typeof fetch == "function", s = Ar(t), o = Ar(r); if (!i) return !1; const l = i && Ar(fa), a = i && (typeof da == "function" ? (h => g => h.encode(g))(new da) : async h => new Uint8Array(await new t(h).arrayBuffer())), c = s && l && ha(() => { let h = !1; const g = new t(oe.origin, { body: new fa, method: "POST", get duplex() { return h = !0, "half" } }).headers.has("Content-Type"); return h && !g }), u = o && l && ha(() => b.isReadableStream(new r("").body)), f = { stream: u && (h => h.body) }; i && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(h => { !f[h] && (f[h] = (g, m) => { let y = g && g[h]; if (y) return y.call(g); throw new N(`Response type '${h}' is not supported`, N.ERR_NOT_SUPPORT, m) }) }); const d = async h => { if (h == null) return 0; if (b.isBlob(h)) return h.size; if (b.isSpecCompliantForm(h)) return (await new t(oe.origin, { method: "POST", body: h }).arrayBuffer()).byteLength; if (b.isArrayBufferView(h) || b.isArrayBuffer(h)) return h.byteLength; if (b.isURLSearchParams(h) && (h = h + ""), b.isString(h)) return (await a(h)).byteLength }, p = async (h, g) => { const m = b.toFiniteNumber(h.getContentLength()); return m ?? d(g) }; return async h => { let { url: g, method: m, data: y, signal: S, cancelToken: k, timeout: M, onDownloadProgress: T, onUploadProgress: D, responseType: C, headers: P, withCredentials: B = "same-origin", fetchOptions: De } = mu(h), Dn = e || fetch; C = C ? (C + "").toLowerCase() : "text"; let Qe = Xp([S, k && k.toAbortSignal()], M), Ze = null; const Ae = Qe && Qe.unsubscribe && (() => { Qe.unsubscribe() }); let Tt; try { if (D && c && m !== "get" && m !== "head" && (Tt = await p(P, y)) !== 0) { let nt = new t(g, { method: "POST", body: y, duplex: "half" }), ln; if (b.isFormData(y) && (ln = nt.headers.get("content-type")) && P.setContentType(ln), nt.body) { const [Ss, Mr] = oa(Tt, ti(la(D))); y = ca(nt.body, ua, Ss, Mr) } } b.isString(B) || (B = B ? "include" : "omit"); const Z = s && "credentials" in t.prototype, et = { ...De, signal: Qe, method: m.toUpperCase(), headers: P.normalize().toJSON(), body: y, duplex: "half", credentials: Z ? B : void 0 }; Ze = s && new t(g, et); let tt = await (s ? Dn(Ze, De) : Dn(g, et)); const Zl = u && (C === "stream" || C === "response"); if (u && (T || Zl && Ae)) { const nt = {};["status", "statusText", "headers"].forEach(ea => { nt[ea] = tt[ea] }); const ln = b.toFiniteNumber(tt.headers.get("content-length")), [Ss, Mr] = T && oa(ln, ti(la(T), !0)) || []; tt = new r(ca(tt.body, ua, Ss, () => { Mr && Mr(), Ae && Ae() }), nt) } C = C || "text"; let Ih = await f[b.findKey(f, C) || "text"](tt, h); return !Zl && Ae && Ae(), await new Promise((nt, ln) => { hu(nt, ln, { data: Ih, headers: pe.from(tt.headers), status: tt.status, statusText: tt.statusText, config: h, request: Ze }) }) } catch (Z) { throw Ae && Ae(), Z && Z.name === "TypeError" && /Load failed|fetch/i.test(Z.message) ? Object.assign(new N("Network Error", N.ERR_NETWORK, h, Ze), { cause: Z.cause || Z }) : N.from(Z, Z && Z.code, h, Ze) } } }, rm = new Map, gu = n => { let e = n && n.env || {}; const { fetch: t, Request: r, Response: i } = e, s = [r, i, t]; let o = s.length, l = o, a, c, u = rm; for (; l--;)a = s[l], c = u.get(a), c === void 0 && u.set(a, c = l ? new Map : nm(e)), u = c; return c }; gu(); const Xo = { http: Sp, xhr: Yp, fetch: { get: gu } }; b.forEach(Xo, (n, e) => { if (n) { try { Object.defineProperty(n, "name", { value: e }) } catch { } Object.defineProperty(n, "adapterName", { value: e }) } }); const pa = n => `- ${n}`, im = n => b.isFunction(n) || n === null || n === !1; function sm(n, e) {
  n = b.isArray(n) ? n : [n]; const { length: t } = n; let r, i; const s = {}; for (let o = 0; o < t; o++) { r = n[o]; let l; if (i = r, !im(r) && (i = Xo[(l = String(r)).toLowerCase()], i === void 0)) throw new N(`Unknown adapter '${l}'`); if (i && (b.isFunction(i) || (i = i.get(e)))) break; s[l || "#" + o] = i } if (!i) {
    const o = Object.entries(s).map(([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")); let l = t ? o.length > 1 ? `since :
`+ o.map(pa).join(`
`) : " " + pa(o[0]) : "as no adapter specified"; throw new N("There is no suitable adapter to dispatch the request " + l, "ERR_NOT_SUPPORT")
  } return i
} const yu = { getAdapter: sm, adapters: Xo }; function Es(n) { if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted) throw new kr(null, n) } function ma(n) { return Es(n), n.headers = pe.from(n.headers), n.data = ks.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), yu.getAdapter(n.adapter || wr.adapter, n)(n).then(function (r) { return Es(n), r.data = ks.call(n, n.transformResponse, r), r.headers = pe.from(r.headers), r }, function (r) { return du(r) || (Es(n), r && r.response && (r.response.data = ks.call(n, n.transformResponse, r.response), r.response.headers = pe.from(r.response.headers))), Promise.reject(r) }) } const bu = "1.13.4", Yi = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => { Yi[n] = function (r) { return typeof r === n || "a" + (e < 1 ? "n " : " ") + n } }); const ga = {}; Yi.transitional = function (e, t, r) { function i(s, o) { return "[Axios v" + bu + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "") } return (s, o, l) => { if (e === !1) throw new N(i(o, " has been removed" + (t ? " in " + t : "")), N.ERR_DEPRECATED); return t && !ga[o] && (ga[o] = !0, console.warn(i(o, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(s, o, l) : !0 } }; Yi.spelling = function (e) { return (t, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0) }; function om(n, e, t) { if (typeof n != "object") throw new N("options must be an object", N.ERR_BAD_OPTION_VALUE); const r = Object.keys(n); let i = r.length; for (; i-- > 0;) { const s = r[i], o = e[s]; if (o) { const l = n[s], a = l === void 0 || o(l, s, n); if (a !== !0) throw new N("option " + s + " must be " + a, N.ERR_BAD_OPTION_VALUE); continue } if (t !== !0) throw new N("Unknown option " + s, N.ERR_BAD_OPTION) } } const Jr = { assertOptions: om, validators: Yi }, Ie = Jr.validators; let Bt = class {
  constructor(e) { this.defaults = e || {}, this.interceptors = { request: new ia, response: new ia } } async request(e, t) {
    try { return await this._request(e, t) } catch (r) {
      if (r instanceof Error) {
        let i = {}; Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error; const s = i.stack ? i.stack.replace(/^.+\n/, "") : ""; try {
          r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ s) : r.stack = s
        } catch { }
      } throw r
    }
  } _request(e, t) { typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = qt(this.defaults, t); const { transitional: r, paramsSerializer: i, headers: s } = t; r !== void 0 && Jr.assertOptions(r, { silentJSONParsing: Ie.transitional(Ie.boolean), forcedJSONParsing: Ie.transitional(Ie.boolean), clarifyTimeoutError: Ie.transitional(Ie.boolean) }, !1), i != null && (b.isFunction(i) ? t.paramsSerializer = { serialize: i } : Jr.assertOptions(i, { encode: Ie.function, serialize: Ie.function }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Jr.assertOptions(t, { baseUrl: Ie.spelling("baseURL"), withXsrfToken: Ie.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let o = s && b.merge(s.common, s[t.method]); s && b.forEach(["delete", "get", "head", "post", "put", "patch", "common"], h => { delete s[h] }), t.headers = pe.concat(o, s); const l = []; let a = !0; this.interceptors.request.forEach(function (g) { typeof g.runWhen == "function" && g.runWhen(t) === !1 || (a = a && g.synchronous, l.unshift(g.fulfilled, g.rejected)) }); const c = []; this.interceptors.response.forEach(function (g) { c.push(g.fulfilled, g.rejected) }); let u, f = 0, d; if (!a) { const h = [ma.bind(this), void 0]; for (h.unshift(...l), h.push(...c), d = h.length, u = Promise.resolve(t); f < d;)u = u.then(h[f++], h[f++]); return u } d = l.length; let p = t; for (; f < d;) { const h = l[f++], g = l[f++]; try { p = h(p) } catch (m) { g.call(this, m); break } } try { u = ma.call(this, p) } catch (h) { return Promise.reject(h) } for (f = 0, d = c.length; f < d;)u = u.then(c[f++], c[f++]); return u } getUri(e) { e = qt(this.defaults, e); const t = pu(e.baseURL, e.url, e.allowAbsoluteUrls); return cu(t, e.params, e.paramsSerializer) }
}; b.forEach(["delete", "get", "head", "options"], function (e) { Bt.prototype[e] = function (t, r) { return this.request(qt(r || {}, { method: e, url: t, data: (r || {}).data })) } }); b.forEach(["post", "put", "patch"], function (e) { function t(r) { return function (s, o, l) { return this.request(qt(l || {}, { method: e, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: s, data: o })) } } Bt.prototype[e] = t(), Bt.prototype[e + "Form"] = t(!0) }); let lm = class xu { constructor(e) { if (typeof e != "function") throw new TypeError("executor must be a function."); let t; this.promise = new Promise(function (s) { t = s }); const r = this; this.promise.then(i => { if (!r._listeners) return; let s = r._listeners.length; for (; s-- > 0;)r._listeners[s](i); r._listeners = null }), this.promise.then = i => { let s; const o = new Promise(l => { r.subscribe(l), s = l }).then(i); return o.cancel = function () { r.unsubscribe(s) }, o }, e(function (s, o, l) { r.reason || (r.reason = new kr(s, o, l), t(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { if (this.reason) { e(this.reason); return } this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); t !== -1 && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = r => { e.abort(r) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let e; return { token: new xu(function (i) { e = i }), cancel: e } } }; function am(n) { return function (t) { return n.apply(null, t) } } function cm(n) { return b.isObject(n) && n.isAxiosError === !0 } const ro = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(ro).forEach(([n, e]) => { ro[e] = n }); function Su(n) { const e = new Bt(n), t = Qc(Bt.prototype.request, e); return b.extend(t, Bt.prototype, e, { allOwnKeys: !0 }), b.extend(t, e, null, { allOwnKeys: !0 }), t.create = function (i) { return Su(qt(n, i)) }, t } const V = Su(wr); V.Axios = Bt; V.CanceledError = kr; V.CancelToken = lm; V.isCancel = du; V.VERSION = bu; V.toFormData = Gi; V.AxiosError = N; V.Cancel = V.CanceledError; V.all = function (e) { return Promise.all(e) }; V.spread = am; V.isAxiosError = cm; V.mergeConfig = qt; V.AxiosHeaders = pe; V.formToJSON = n => fu(b.isHTMLForm(n) ? new FormData(n) : n); V.getAdapter = yu.getAdapter; V.HttpStatusCode = ro; V.default = V; const { Axios: ck, AxiosError: uk, CanceledError: fk, isCancel: dk, CancelToken: hk, VERSION: pk, all: mk, Cancel: gk, isAxiosError: yk, spread: bk, toFormData: xk, AxiosHeaders: Sk, HttpStatusCode: wk, formToJSON: kk, getAdapter: Ek, mergeConfig: Ck } = V; window.axios = V; window.axios.defaults.headers.common["X-Requested-With"] = "XMLHttpRequest"; var io = !1, so = !1, Ft = [], oo = -1; function um(n) { fm(n) } function fm(n) { Ft.includes(n) || Ft.push(n), hm() } function dm(n) { let e = Ft.indexOf(n); e !== -1 && e > oo && Ft.splice(e, 1) } function hm() { !so && !io && (io = !0, queueMicrotask(pm)) } function pm() { io = !1, so = !0; for (let n = 0; n < Ft.length; n++)Ft[n](), oo = n; Ft.length = 0, oo = -1, so = !1 } var Mn, rn, An, wu, lo = !0; function mm(n) { lo = !1, n(), lo = !0 } function gm(n) { Mn = n.reactive, An = n.release, rn = e => n.effect(e, { scheduler: t => { lo ? um(t) : t() } }), wu = n.raw } function ya(n) { rn = n } function ym(n) { let e = () => { }; return [r => { let i = rn(r); return n._x_effects || (n._x_effects = new Set, n._x_runEffects = () => { n._x_effects.forEach(s => s()) }), n._x_effects.add(i), e = () => { i !== void 0 && (n._x_effects.delete(i), An(i)) }, i }, () => { e() }] } function ku(n, e) { let t = !0, r, i = rn(() => { let s = n(); JSON.stringify(s), t ? r = s : queueMicrotask(() => { e(s, r), r = s }), t = !1 }); return () => An(i) } var Eu = [], Cu = [], Ou = []; function bm(n) { Ou.push(n) } function Qo(n, e) { typeof e == "function" ? (n._x_cleanups || (n._x_cleanups = []), n._x_cleanups.push(e)) : (e = n, Cu.push(e)) } function Tu(n) { Eu.push(n) } function Mu(n, e, t) { n._x_attributeCleanups || (n._x_attributeCleanups = {}), n._x_attributeCleanups[e] || (n._x_attributeCleanups[e] = []), n._x_attributeCleanups[e].push(t) } function Au(n, e) { n._x_attributeCleanups && Object.entries(n._x_attributeCleanups).forEach(([t, r]) => { (e === void 0 || e.includes(t)) && (r.forEach(i => i()), delete n._x_attributeCleanups[t]) }) } function xm(n) { for (n._x_effects?.forEach(dm); n._x_cleanups?.length;)n._x_cleanups.pop()() } var Zo = new MutationObserver(rl), el = !1; function tl() { Zo.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), el = !0 } function Nu() { Sm(), Zo.disconnect(), el = !1 } var Pn = []; function Sm() { let n = Zo.takeRecords(); Pn.push(() => n.length > 0 && rl(n)); let e = Pn.length; queueMicrotask(() => { if (Pn.length === e) for (; Pn.length > 0;)Pn.shift()() }) } function $(n) { if (!el) return n(); Nu(); let e = n(); return tl(), e } var nl = !1, ni = []; function wm() { nl = !0 } function km() { nl = !1, rl(ni), ni = [] } function rl(n) { if (nl) { ni = ni.concat(n); return } let e = [], t = new Set, r = new Map, i = new Map; for (let s = 0; s < n.length; s++)if (!n[s].target._x_ignoreMutationObserver && (n[s].type === "childList" && (n[s].removedNodes.forEach(o => { o.nodeType === 1 && o._x_marker && t.add(o) }), n[s].addedNodes.forEach(o => { if (o.nodeType === 1) { if (t.has(o)) { t.delete(o); return } o._x_marker || e.push(o) } })), n[s].type === "attributes")) { let o = n[s].target, l = n[s].attributeName, a = n[s].oldValue, c = () => { r.has(o) || r.set(o, []), r.get(o).push({ name: l, value: o.getAttribute(l) }) }, u = () => { i.has(o) || i.set(o, []), i.get(o).push(l) }; o.hasAttribute(l) && a === null ? c() : o.hasAttribute(l) ? (u(), c()) : u() } i.forEach((s, o) => { Au(o, s) }), r.forEach((s, o) => { Eu.forEach(l => l(o, s)) }); for (let s of t) e.some(o => o.contains(s)) || Cu.forEach(o => o(s)); for (let s of e) s.isConnected && Ou.forEach(o => o(s)); e = null, t = null, r = null, i = null } function Ru(n) { return Gt(Jt(n)) } function Er(n, e, t) { return n._x_dataStack = [e, ...Jt(t || n)], () => { n._x_dataStack = n._x_dataStack.filter(r => r !== e) } } function Jt(n) { return n._x_dataStack ? n._x_dataStack : typeof ShadowRoot == "function" && n instanceof ShadowRoot ? Jt(n.host) : n.parentNode ? Jt(n.parentNode) : [] } function Gt(n) { return new Proxy({ objects: n }, Em) } var Em = { ownKeys({ objects: n }) { return Array.from(new Set(n.flatMap(e => Object.keys(e)))) }, has({ objects: n }, e) { return e == Symbol.unscopables ? !1 : n.some(t => Object.prototype.hasOwnProperty.call(t, e) || Reflect.has(t, e)) }, get({ objects: n }, e, t) { return e == "toJSON" ? Cm : Reflect.get(n.find(r => Reflect.has(r, e)) || {}, e, t) }, set({ objects: n }, e, t, r) { const i = n.find(o => Object.prototype.hasOwnProperty.call(o, e)) || n[n.length - 1], s = Object.getOwnPropertyDescriptor(i, e); return s?.set && s?.get ? s.set.call(r, t) || !0 : Reflect.set(i, e, t) } }; function Cm() { return Reflect.ownKeys(this).reduce((e, t) => (e[t] = Reflect.get(this, t), e), {}) } function il(n) { let e = r => typeof r == "object" && !Array.isArray(r) && r !== null, t = (r, i = "") => { Object.entries(Object.getOwnPropertyDescriptors(r)).forEach(([s, { value: o, enumerable: l }]) => { if (l === !1 || o === void 0 || typeof o == "object" && o !== null && o.__v_skip) return; let a = i === "" ? s : `${i}.${s}`; typeof o == "object" && o !== null && o._x_interceptor ? r[s] = o.initialize(n, a, s) : e(o) && o !== r && !(o instanceof Element) && t(o, a) }) }; return t(n) } function vu(n, e = () => { }) { let t = { initialValue: void 0, _x_interceptor: !0, initialize(r, i, s) { return n(this.initialValue, () => Om(r, i), o => ao(r, i, o), i, s) } }; return e(t), r => { if (typeof r == "object" && r !== null && r._x_interceptor) { let i = t.initialize.bind(t); t.initialize = (s, o, l) => { let a = r.initialize(s, o, l); return t.initialValue = a, i(s, o, l) } } else t.initialValue = r; return t } } function Om(n, e) { return e.split(".").reduce((t, r) => t[r], n) } function ao(n, e, t) { if (typeof e == "string" && (e = e.split(".")), e.length === 1) n[e[0]] = t; else { if (e.length === 0) throw error; return n[e[0]] || (n[e[0]] = {}), ao(n[e[0]], e.slice(1), t) } } var _u = {}; function _e(n, e) { _u[n] = e } function rr(n, e) { let t = Tm(e); return Object.entries(_u).forEach(([r, i]) => { Object.defineProperty(n, `$${r}`, { get() { return i(e, t) }, enumerable: !1 }) }), n } function Tm(n) { let [e, t] = $u(n), r = { interceptor: vu, ...e }; return Qo(n, t), r } function Mm(n, e, t, ...r) { try { return t(...r) } catch (i) { ir(i, n, e) } } function ir(...n) { return Du(...n) } var Du = Nm; function Am(n) { Du = n } function Nm(n, e, t = void 0) {
  n = Object.assign(n ?? { message: "No error message given." }, { el: e, expression: t }), console.warn(`Alpine Expression Error: ${n.message}

${t ? 'Expression: "' + t + `"

`: ""}`, e), setTimeout(() => { throw n }, 0)
} var gn = !0; function Iu(n) { let e = gn; gn = !1; let t = n(); return gn = e, t } function zt(n, e, t = {}) { let r; return ce(n, e)(i => r = i, t), r } function ce(...n) { return Pu(...n) } var Pu = Bu; function Rm(n) { Pu = n } var Lu; function vm(n) { Lu = n } function Bu(n, e) { let t = {}; rr(t, n); let r = [t, ...Jt(n)], i = typeof e == "function" ? _m(r, e) : Im(r, e, n); return Mm.bind(null, n, e, i) } function _m(n, e) { return (t = () => { }, { scope: r = {}, params: i = [], context: s } = {}) => { if (!gn) { sr(t, e, Gt([r, ...n]), i); return } let o = e.apply(Gt([r, ...n]), i); sr(t, o) } } var Cs = {}; function Dm(n, e) { if (Cs[n]) return Cs[n]; let t = Object.getPrototypeOf(async function () { }).constructor, r = /^[\n\s]*if.*\(.*\)/.test(n.trim()) || /^(let|const)\s/.test(n.trim()) ? `(async()=>{ ${n} })()` : n, s = (() => { try { let o = new t(["__self", "scope"], `with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`); return Object.defineProperty(o, "name", { value: `[Alpine] ${n}` }), o } catch (o) { return ir(o, e, n), Promise.resolve() } })(); return Cs[n] = s, s } function Im(n, e, t) { let r = Dm(e, t); return (i = () => { }, { scope: s = {}, params: o = [], context: l } = {}) => { r.result = void 0, r.finished = !1; let a = Gt([s, ...n]); if (typeof r == "function") { let c = r.call(l, r, a).catch(u => ir(u, t, e)); r.finished ? (sr(i, r.result, a, o, t), r.result = void 0) : c.then(u => { sr(i, u, a, o, t) }).catch(u => ir(u, t, e)).finally(() => r.result = void 0) } } } function sr(n, e, t, r, i) { if (gn && typeof e == "function") { let s = e.apply(t, r); s instanceof Promise ? s.then(o => sr(n, o, t, r)).catch(o => ir(o, i, e)) : n(s) } else typeof e == "object" && e instanceof Promise ? e.then(s => n(s)) : n(e) } function Pm(...n) { return Lu(...n) } function Lm(n, e, t = {}) { let r = {}; rr(r, n); let i = [r, ...Jt(n)], s = Gt([t.scope ?? {}, ...i]), o = t.params ?? []; if (e.includes("await")) { let l = Object.getPrototypeOf(async function () { }).constructor, a = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(async()=>{ ${e} })()` : e; return new l(["scope"], `with (scope) { let __result = ${a}; return __result }`).call(t.context, s) } else { let l = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(()=>{ ${e} })()` : e, c = new Function(["scope"], `with (scope) { let __result = ${l}; return __result }`).call(t.context, s); return typeof c == "function" && gn ? c.apply(s, o) : c } } var sl = "x-"; function Nn(n = "") { return sl + n } function Bm(n) { sl = n } var ri = {}; function K(n, e) { return ri[n] = e, { before(t) { if (!ri[t]) { console.warn(String.raw`Cannot find directive \`${t}\`. \`${n}\` will use the default order of execution`); return } const r = _t.indexOf(t); _t.splice(r >= 0 ? r : _t.indexOf("DEFAULT"), 0, n) } } } function Fm(n) { return Object.keys(ri).includes(n) } function ol(n, e, t) { if (e = Array.from(e), n._x_virtualDirectives) { let s = Object.entries(n._x_virtualDirectives).map(([l, a]) => ({ name: l, value: a })), o = Fu(s); s = s.map(l => o.find(a => a.name === l.name) ? { name: `x-bind:${l.name}`, value: `"${l.value}"` } : l), e = e.concat(s) } let r = {}; return e.map(Vu((s, o) => r[s] = o)).filter(Wu).map(Hm(r, t)).sort(jm).map(s => $m(n, s)) } function Fu(n) { return Array.from(n).map(Vu()).filter(e => !Wu(e)) } var co = !1, $n = new Map, zu = Symbol(); function zm(n) { co = !0; let e = Symbol(); zu = e, $n.set(e, []); let t = () => { for (; $n.get(e).length;)$n.get(e).shift()(); $n.delete(e) }, r = () => { co = !1, t() }; n(t), r() } function $u(n) { let e = [], t = l => e.push(l), [r, i] = ym(n); return e.push(i), [{ Alpine: vn, effect: r, cleanup: t, evaluateLater: ce.bind(ce, n), evaluate: zt.bind(zt, n) }, () => e.forEach(l => l())] } function $m(n, e) { let t = () => { }, r = ri[e.type] || t, [i, s] = $u(n); Mu(n, e.original, s); let o = () => { n._x_ignore || n._x_ignoreSelf || (r.inline && r.inline(n, e, i), r = r.bind(r, n, e, i), co ? $n.get(zu).push(r) : r()) }; return o.runCleanups = s, o } var Hu = (n, e) => ({ name: t, value: r }) => (t.startsWith(n) && (t = t.replace(n, e)), { name: t, value: r }), ju = n => n; function Vu(n = () => { }) { return ({ name: e, value: t }) => { let { name: r, value: i } = Uu.reduce((s, o) => o(s), { name: e, value: t }); return r !== e && n(r, e), { name: r, value: i } } } var Uu = []; function ll(n) { Uu.push(n) } function Wu({ name: n }) { return Ku().test(n) } var Ku = () => new RegExp(`^${sl}([^:^.]+)\\b`); function Hm(n, e) { return ({ name: t, value: r }) => { t === r && (r = ""); let i = t.match(Ku()), s = t.match(/:([a-zA-Z0-9\-_:]+)/), o = t.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], l = e || n[t] || t; return { type: i ? i[1] : null, value: s ? s[1] : null, modifiers: o.map(a => a.replace(".", "")), expression: r, original: l } } } var uo = "DEFAULT", _t = ["ignore", "ref", "data", "id", "anchor", "bind", "init", "for", "model", "modelable", "transition", "show", "if", uo, "teleport"]; function jm(n, e) { let t = _t.indexOf(n.type) === -1 ? uo : n.type, r = _t.indexOf(e.type) === -1 ? uo : e.type; return _t.indexOf(t) - _t.indexOf(r) } function Wn(n, e, t = {}) { n.dispatchEvent(new CustomEvent(e, { detail: t, bubbles: !0, composed: !0, cancelable: !0 })) } function Yt(n, e) { if (typeof ShadowRoot == "function" && n instanceof ShadowRoot) { Array.from(n.children).forEach(i => Yt(i, e)); return } let t = !1; if (e(n, () => t = !0), t) return; let r = n.firstElementChild; for (; r;)Yt(r, e), r = r.nextElementSibling } function Oe(n, ...e) { console.warn(`Alpine Warning: ${n}`, ...e) } var ba = !1; function Vm() { ba && Oe("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), ba = !0, document.body || Oe("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), Wn(document, "alpine:init"), Wn(document, "alpine:initializing"), tl(), bm(e => Ye(e, Yt)), Qo(e => Rn(e)), Tu((e, t) => { ol(e, t).forEach(r => r()) }); let n = e => !Xi(e.parentElement, !0); Array.from(document.querySelectorAll(Gu().join(","))).filter(n).forEach(e => { Ye(e) }), Wn(document, "alpine:initialized"), setTimeout(() => { qm() }) } var al = [], qu = []; function Ju() { return al.map(n => n()) } function Gu() { return al.concat(qu).map(n => n()) } function Yu(n) { al.push(n) } function Xu(n) { qu.push(n) } function Xi(n, e = !1) { return Xt(n, t => { if ((e ? Gu() : Ju()).some(i => t.matches(i))) return !0 }) } function Xt(n, e) { if (n) { if (e(n)) return n; if (n._x_teleportBack && (n = n._x_teleportBack), n.parentNode instanceof ShadowRoot) return Xt(n.parentNode.host, e); if (n.parentElement) return Xt(n.parentElement, e) } } function Um(n) { return Ju().some(e => n.matches(e)) } var Qu = []; function Wm(n) { Qu.push(n) } var Km = 1; function Ye(n, e = Yt, t = () => { }) { Xt(n, r => r._x_ignore) || zm(() => { e(n, (r, i) => { r._x_marker || (t(r, i), Qu.forEach(s => s(r, i)), ol(r, r.attributes).forEach(s => s()), r._x_ignore || (r._x_marker = Km++), r._x_ignore && i()) }) }) } function Rn(n, e = Yt) { e(n, t => { xm(t), Au(t), delete t._x_marker }) } function qm() { [["ui", "dialog", ["[x-dialog], [x-popover]"]], ["anchor", "anchor", ["[x-anchor]"]], ["sort", "sort", ["[x-sort]"]]].forEach(([e, t, r]) => { Fm(t) || r.some(i => { if (document.querySelector(i)) return Oe(`found "${i}", but missing ${e} plugin`), !0 }) }) } var fo = [], cl = !1; function ul(n = () => { }) { return queueMicrotask(() => { cl || setTimeout(() => { ho() }) }), new Promise(e => { fo.push(() => { n(), e() }) }) } function ho() { for (cl = !1; fo.length;)fo.shift()() } function Jm() { cl = !0 } function fl(n, e) { return Array.isArray(e) ? xa(n, e.join(" ")) : typeof e == "object" && e !== null ? Gm(n, e) : typeof e == "function" ? fl(n, e()) : xa(n, e) } function xa(n, e) { let t = i => i.split(" ").filter(s => !n.classList.contains(s)).filter(Boolean), r = i => (n.classList.add(...i), () => { n.classList.remove(...i) }); return e = e === !0 ? e = "" : e || "", r(t(e)) } function Gm(n, e) { let t = l => l.split(" ").filter(Boolean), r = Object.entries(e).flatMap(([l, a]) => a ? t(l) : !1).filter(Boolean), i = Object.entries(e).flatMap(([l, a]) => a ? !1 : t(l)).filter(Boolean), s = [], o = []; return i.forEach(l => { n.classList.contains(l) && (n.classList.remove(l), o.push(l)) }), r.forEach(l => { n.classList.contains(l) || (n.classList.add(l), s.push(l)) }), () => { o.forEach(l => n.classList.add(l)), s.forEach(l => n.classList.remove(l)) } } function Qi(n, e) { return typeof e == "object" && e !== null ? Ym(n, e) : Xm(n, e) } function Ym(n, e) { let t = {}; return Object.entries(e).forEach(([r, i]) => { t[r] = n.style[r], r.startsWith("--") || (r = Qm(r)), n.style.setProperty(r, i) }), setTimeout(() => { n.style.length === 0 && n.removeAttribute("style") }), () => { Qi(n, t) } } function Xm(n, e) { let t = n.getAttribute("style", e); return n.setAttribute("style", e), () => { n.setAttribute("style", t || "") } } function Qm(n) { return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function po(n, e = () => { }) { let t = !1; return function () { t ? e.apply(this, arguments) : (t = !0, n.apply(this, arguments)) } } K("transition", (n, { value: e, modifiers: t, expression: r }, { evaluate: i }) => { typeof r == "function" && (r = i(r)), r !== !1 && (!r || typeof r == "boolean" ? eg(n, t, e) : Zm(n, r, e)) }); function Zm(n, e, t) { Zu(n, fl, ""), { enter: i => { n._x_transition.enter.during = i }, "enter-start": i => { n._x_transition.enter.start = i }, "enter-end": i => { n._x_transition.enter.end = i }, leave: i => { n._x_transition.leave.during = i }, "leave-start": i => { n._x_transition.leave.start = i }, "leave-end": i => { n._x_transition.leave.end = i } }[t](e) } function eg(n, e, t) { Zu(n, Qi); let r = !e.includes("in") && !e.includes("out") && !t, i = r || e.includes("in") || ["enter"].includes(t), s = r || e.includes("out") || ["leave"].includes(t); e.includes("in") && !r && (e = e.filter((y, S) => S < e.indexOf("out"))), e.includes("out") && !r && (e = e.filter((y, S) => S > e.indexOf("out"))); let o = !e.includes("opacity") && !e.includes("scale"), l = o || e.includes("opacity"), a = o || e.includes("scale"), c = l ? 0 : 1, u = a ? Ln(e, "scale", 95) / 100 : 1, f = Ln(e, "delay", 0) / 1e3, d = Ln(e, "origin", "center"), p = "opacity, transform", h = Ln(e, "duration", 150) / 1e3, g = Ln(e, "duration", 75) / 1e3, m = "cubic-bezier(0.4, 0.0, 0.2, 1)"; i && (n._x_transition.enter.during = { transformOrigin: d, transitionDelay: `${f}s`, transitionProperty: p, transitionDuration: `${h}s`, transitionTimingFunction: m }, n._x_transition.enter.start = { opacity: c, transform: `scale(${u})` }, n._x_transition.enter.end = { opacity: 1, transform: "scale(1)" }), s && (n._x_transition.leave.during = { transformOrigin: d, transitionDelay: `${f}s`, transitionProperty: p, transitionDuration: `${g}s`, transitionTimingFunction: m }, n._x_transition.leave.start = { opacity: 1, transform: "scale(1)" }, n._x_transition.leave.end = { opacity: c, transform: `scale(${u})` }) } function Zu(n, e, t = {}) { n._x_transition || (n._x_transition = { enter: { during: t, start: t, end: t }, leave: { during: t, start: t, end: t }, in(r = () => { }, i = () => { }) { mo(n, e, { during: this.enter.during, start: this.enter.start, end: this.enter.end }, r, i) }, out(r = () => { }, i = () => { }) { mo(n, e, { during: this.leave.during, start: this.leave.start, end: this.leave.end }, r, i) } }) } window.Element.prototype._x_toggleAndCascadeWithTransitions = function (n, e, t, r) { const i = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout; let s = () => i(t); if (e) { n._x_transition && (n._x_transition.enter || n._x_transition.leave) ? n._x_transition.enter && (Object.entries(n._x_transition.enter.during).length || Object.entries(n._x_transition.enter.start).length || Object.entries(n._x_transition.enter.end).length) ? n._x_transition.in(t) : s() : n._x_transition ? n._x_transition.in(t) : s(); return } n._x_hidePromise = n._x_transition ? new Promise((o, l) => { n._x_transition.out(() => { }, () => o(r)), n._x_transitioning && n._x_transitioning.beforeCancel(() => l({ isFromCancelledTransition: !0 })) }) : Promise.resolve(r), queueMicrotask(() => { let o = ef(n); o ? (o._x_hideChildren || (o._x_hideChildren = []), o._x_hideChildren.push(n)) : i(() => { let l = a => { let c = Promise.all([a._x_hidePromise, ...(a._x_hideChildren || []).map(l)]).then(([u]) => u?.()); return delete a._x_hidePromise, delete a._x_hideChildren, c }; l(n).catch(a => { if (!a.isFromCancelledTransition) throw a }) }) }) }; function ef(n) { let e = n.parentNode; if (e) return e._x_hidePromise ? e : ef(e) } function mo(n, e, { during: t, start: r, end: i } = {}, s = () => { }, o = () => { }) { if (n._x_transitioning && n._x_transitioning.cancel(), Object.keys(t).length === 0 && Object.keys(r).length === 0 && Object.keys(i).length === 0) { s(), o(); return } let l, a, c; tg(n, { start() { l = e(n, r) }, during() { a = e(n, t) }, before: s, end() { l(), c = e(n, i) }, after: o, cleanup() { a(), c() } }) } function tg(n, e) { let t, r, i, s = po(() => { $(() => { t = !0, r || e.before(), i || (e.end(), ho()), e.after(), n.isConnected && e.cleanup(), delete n._x_transitioning }) }); n._x_transitioning = { beforeCancels: [], beforeCancel(o) { this.beforeCancels.push(o) }, cancel: po(function () { for (; this.beforeCancels.length;)this.beforeCancels.shift()(); s() }), finish: s }, $(() => { e.start(), e.during() }), Jm(), requestAnimationFrame(() => { if (t) return; let o = Number(getComputedStyle(n).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3, l = Number(getComputedStyle(n).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3; o === 0 && (o = Number(getComputedStyle(n).animationDuration.replace("s", "")) * 1e3), $(() => { e.before() }), r = !0, requestAnimationFrame(() => { t || ($(() => { e.end() }), ho(), setTimeout(n._x_transitioning.finish, o + l), i = !0) }) }) } function Ln(n, e, t) { if (n.indexOf(e) === -1) return t; const r = n[n.indexOf(e) + 1]; if (!r || e === "scale" && isNaN(r)) return t; if (e === "duration" || e === "delay") { let i = r.match(/([0-9]+)ms/); if (i) return i[1] } return e === "origin" && ["top", "right", "left", "center", "bottom"].includes(n[n.indexOf(e) + 2]) ? [r, n[n.indexOf(e) + 2]].join(" ") : r } var xt = !1; function kt(n, e = () => { }) { return (...t) => xt ? e(...t) : n(...t) } function ng(n) { return (...e) => xt && n(...e) } var tf = []; function Zi(n) { tf.push(n) } function rg(n, e) { tf.forEach(t => t(n, e)), xt = !0, nf(() => { Ye(e, (t, r) => { r(t, () => { }) }) }), xt = !1 } var go = !1; function ig(n, e) { e._x_dataStack || (e._x_dataStack = n._x_dataStack), xt = !0, go = !0, nf(() => { sg(e) }), xt = !1, go = !1 } function sg(n) { let e = !1; Ye(n, (r, i) => { Yt(r, (s, o) => { if (e && Um(s)) return o(); e = !0, i(s, o) }) }) } function nf(n) { let e = rn; ya((t, r) => { let i = e(t); return An(i), () => { } }), n(), ya(e) } function rf(n, e, t, r = []) { switch (n._x_bindings || (n._x_bindings = Mn({})), n._x_bindings[e] = t, e = r.includes("camel") ? hg(e) : e, e) { case "value": og(n, t); break; case "style": ag(n, t); break; case "class": lg(n, t); break; case "selected": case "checked": cg(n, e, t); break; default: sf(n, e, t); break } } function og(n, e) { if (af(n)) n.attributes.value === void 0 && (n.value = e), window.fromModel && (typeof e == "boolean" ? n.checked = Gr(n.value) === e : n.checked = Sa(n.value, e)); else if (dl(n)) Number.isInteger(e) ? n.value = e : !Array.isArray(e) && typeof e != "boolean" && ![null, void 0].includes(e) ? n.value = String(e) : Array.isArray(e) ? n.checked = e.some(t => Sa(t, n.value)) : n.checked = !!e; else if (n.tagName === "SELECT") dg(n, e); else { if (n.value === e) return; n.value = e === void 0 ? "" : e } } function lg(n, e) { n._x_undoAddedClasses && n._x_undoAddedClasses(), n._x_undoAddedClasses = fl(n, e) } function ag(n, e) { n._x_undoAddedStyles && n._x_undoAddedStyles(), n._x_undoAddedStyles = Qi(n, e) } function cg(n, e, t) { sf(n, e, t), fg(n, e, t) } function sf(n, e, t) { [null, void 0, !1].includes(t) && mg(e) ? n.removeAttribute(e) : (of(e) && (t = e), ug(n, e, t)) } function ug(n, e, t) { n.getAttribute(e) != t && n.setAttribute(e, t) } function fg(n, e, t) { n[e] !== t && (n[e] = t) } function dg(n, e) { const t = [].concat(e).map(r => r + ""); Array.from(n.options).forEach(r => { r.selected = t.includes(r.value) }) } function hg(n) { return n.toLowerCase().replace(/-(\w)/g, (e, t) => t.toUpperCase()) } function Sa(n, e) { return n == e } function Gr(n) { return [1, "1", "true", "on", "yes", !0].includes(n) ? !0 : [0, "0", "false", "off", "no", !1].includes(n) ? !1 : n ? !!n : null } var pg = new Set(["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "formnovalidate", "inert", "ismap", "itemscope", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected", "shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootserializable"]); function of(n) { return pg.has(n) } function mg(n) { return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(n) } function gg(n, e, t) { return n._x_bindings && n._x_bindings[e] !== void 0 ? n._x_bindings[e] : lf(n, e, t) } function yg(n, e, t, r = !0) { if (n._x_bindings && n._x_bindings[e] !== void 0) return n._x_bindings[e]; if (n._x_inlineBindings && n._x_inlineBindings[e] !== void 0) { let i = n._x_inlineBindings[e]; return i.extract = r, Iu(() => zt(n, i.expression)) } return lf(n, e, t) } function lf(n, e, t) { let r = n.getAttribute(e); return r === null ? typeof t == "function" ? t() : t : r === "" ? !0 : of(e) ? !![e, "true"].includes(r) : r } function dl(n) { return n.type === "checkbox" || n.localName === "ui-checkbox" || n.localName === "ui-switch" } function af(n) { return n.type === "radio" || n.localName === "ui-radio" } function cf(n, e) { let t; return function () { const r = this, i = arguments, s = function () { t = null, n.apply(r, i) }; clearTimeout(t), t = setTimeout(s, e) } } function uf(n, e) { let t; return function () { let r = this, i = arguments; t || (n.apply(r, i), t = !0, setTimeout(() => t = !1, e)) } } function ff({ get: n, set: e }, { get: t, set: r }) { let i = !0, s, o = rn(() => { let l = n(), a = t(); if (i) r(Os(l)), i = !1; else { let c = JSON.stringify(l), u = JSON.stringify(a); c !== s ? r(Os(l)) : c !== u && e(Os(a)) } s = JSON.stringify(n()), JSON.stringify(t()) }); return () => { An(o) } } function Os(n) { return typeof n == "object" ? JSON.parse(JSON.stringify(n)) : n } function bg(n) { (Array.isArray(n) ? n : [n]).forEach(t => t(vn)) } var At = {}, wa = !1; function xg(n, e) { if (wa || (At = Mn(At), wa = !0), e === void 0) return At[n]; At[n] = e, il(At[n]), typeof e == "object" && e !== null && e.hasOwnProperty("init") && typeof e.init == "function" && At[n].init() } function Sg() { return At } var df = {}; function wg(n, e) { let t = typeof e != "function" ? () => e : e; return n instanceof Element ? hf(n, t()) : (df[n] = t, () => { }) } function kg(n) { return Object.entries(df).forEach(([e, t]) => { Object.defineProperty(n, e, { get() { return (...r) => t(...r) } }) }), n } function hf(n, e, t) { let r = []; for (; r.length;)r.pop()(); let i = Object.entries(e).map(([o, l]) => ({ name: o, value: l })), s = Fu(i); return i = i.map(o => s.find(l => l.name === o.name) ? { name: `x-bind:${o.name}`, value: `"${o.value}"` } : o), ol(n, i, t).map(o => { r.push(o.runCleanups), o() }), () => { for (; r.length;)r.pop()() } } var pf = {}; function Eg(n, e) { pf[n] = e } function Cg(n, e) { return Object.entries(pf).forEach(([t, r]) => { Object.defineProperty(n, t, { get() { return (...i) => r.bind(e)(...i) }, enumerable: !1 }) }), n } var Og = { get reactive() { return Mn }, get release() { return An }, get effect() { return rn }, get raw() { return wu }, version: "3.15.5", flushAndStopDeferringMutations: km, dontAutoEvaluateFunctions: Iu, disableEffectScheduling: mm, startObservingMutations: tl, stopObservingMutations: Nu, setReactivityEngine: gm, onAttributeRemoved: Mu, onAttributesAdded: Tu, closestDataStack: Jt, skipDuringClone: kt, onlyDuringClone: ng, addRootSelector: Yu, addInitSelector: Xu, setErrorHandler: Am, interceptClone: Zi, addScopeToNode: Er, deferMutations: wm, mapAttributes: ll, evaluateLater: ce, interceptInit: Wm, initInterceptors: il, injectMagics: rr, setEvaluator: Rm, setRawEvaluator: vm, mergeProxies: Gt, extractProp: yg, findClosest: Xt, onElRemoved: Qo, closestRoot: Xi, destroyTree: Rn, interceptor: vu, transition: mo, setStyles: Qi, mutateDom: $, directive: K, entangle: ff, throttle: uf, debounce: cf, evaluate: zt, evaluateRaw: Pm, initTree: Ye, nextTick: ul, prefixed: Nn, prefix: Bm, plugin: bg, magic: _e, store: xg, start: Vm, clone: ig, cloneNode: rg, bound: gg, $data: Ru, watch: ku, walk: Yt, data: Eg, bind: wg }, vn = Og; function Tg(n, e) { const t = Object.create(null), r = n.split(","); for (let i = 0; i < r.length; i++)t[r[i]] = !0; return i => !!t[i] } var Mg = Object.freeze({}), Ag = Object.prototype.hasOwnProperty, es = (n, e) => Ag.call(n, e), $t = Array.isArray, Kn = n => mf(n) === "[object Map]", Ng = n => typeof n == "string", hl = n => typeof n == "symbol", ts = n => n !== null && typeof n == "object", Rg = Object.prototype.toString, mf = n => Rg.call(n), gf = n => mf(n).slice(8, -1), pl = n => Ng(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, vg = n => { const e = Object.create(null); return t => e[t] || (e[t] = n(t)) }, _g = vg(n => n.charAt(0).toUpperCase() + n.slice(1)), yf = (n, e) => n !== e && (n === n || e === e), yo = new WeakMap, Bn = [], Fe, Ht = Symbol("iterate"), bo = Symbol("Map key iterate"); function Dg(n) { return n && n._isEffect === !0 } function Ig(n, e = Mg) { Dg(n) && (n = n.raw); const t = Bg(n, e); return e.lazy || t(), t } function Pg(n) { n.active && (bf(n), n.options.onStop && n.options.onStop(), n.active = !1) } var Lg = 0; function Bg(n, e) { const t = function () { if (!t.active) return n(); if (!Bn.includes(t)) { bf(t); try { return zg(), Bn.push(t), Fe = t, n() } finally { Bn.pop(), xf(), Fe = Bn[Bn.length - 1] } } }; return t.id = Lg++, t.allowRecurse = !!e.allowRecurse, t._isEffect = !0, t.active = !0, t.raw = n, t.deps = [], t.options = e, t } function bf(n) { const { deps: e } = n; if (e.length) { for (let t = 0; t < e.length; t++)e[t].delete(n); e.length = 0 } } var Sn = !0, ml = []; function Fg() { ml.push(Sn), Sn = !1 } function zg() { ml.push(Sn), Sn = !0 } function xf() { const n = ml.pop(); Sn = n === void 0 ? !0 : n } function Re(n, e, t) { if (!Sn || Fe === void 0) return; let r = yo.get(n); r || yo.set(n, r = new Map); let i = r.get(t); i || r.set(t, i = new Set), i.has(Fe) || (i.add(Fe), Fe.deps.push(i), Fe.options.onTrack && Fe.options.onTrack({ effect: Fe, target: n, type: e, key: t })) } function St(n, e, t, r, i, s) { const o = yo.get(n); if (!o) return; const l = new Set, a = u => { u && u.forEach(f => { (f !== Fe || f.allowRecurse) && l.add(f) }) }; if (e === "clear") o.forEach(a); else if (t === "length" && $t(n)) o.forEach((u, f) => { (f === "length" || f >= r) && a(u) }); else switch (t !== void 0 && a(o.get(t)), e) { case "add": $t(n) ? pl(t) && a(o.get("length")) : (a(o.get(Ht)), Kn(n) && a(o.get(bo))); break; case "delete": $t(n) || (a(o.get(Ht)), Kn(n) && a(o.get(bo))); break; case "set": Kn(n) && a(o.get(Ht)); break }const c = u => { u.options.onTrigger && u.options.onTrigger({ effect: u, target: n, key: t, type: e, newValue: r, oldValue: i, oldTarget: s }), u.options.scheduler ? u.options.scheduler(u) : u() }; l.forEach(c) } var $g = Tg("__proto__,__v_isRef,__isVue"), Sf = new Set(Object.getOwnPropertyNames(Symbol).map(n => Symbol[n]).filter(hl)), Hg = wf(), jg = wf(!0), ka = Vg(); function Vg() { const n = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(e => { n[e] = function (...t) { const r = z(this); for (let s = 0, o = this.length; s < o; s++)Re(r, "get", s + ""); const i = r[e](...t); return i === -1 || i === !1 ? r[e](...t.map(z)) : i } }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => { n[e] = function (...t) { Fg(); const r = z(this)[e].apply(this, t); return xf(), r } }), n } function wf(n = !1, e = !1) { return function (r, i, s) { if (i === "__v_isReactive") return !n; if (i === "__v_isReadonly") return n; if (i === "__v_raw" && s === (n ? e ? ry : Of : e ? ny : Cf).get(r)) return r; const o = $t(r); if (!n && o && es(ka, i)) return Reflect.get(ka, i, s); const l = Reflect.get(r, i, s); return (hl(i) ? Sf.has(i) : $g(i)) || (n || Re(r, "get", i), e) ? l : xo(l) ? !o || !pl(i) ? l.value : l : ts(l) ? n ? Tf(l) : xl(l) : l } } var Ug = Wg(); function Wg(n = !1) { return function (t, r, i, s) { let o = t[r]; if (!n && (i = z(i), o = z(o), !$t(t) && xo(o) && !xo(i))) return o.value = i, !0; const l = $t(t) && pl(r) ? Number(r) < t.length : es(t, r), a = Reflect.set(t, r, i, s); return t === z(s) && (l ? yf(i, o) && St(t, "set", r, i, o) : St(t, "add", r, i)), a } } function Kg(n, e) { const t = es(n, e), r = n[e], i = Reflect.deleteProperty(n, e); return i && t && St(n, "delete", e, void 0, r), i } function qg(n, e) { const t = Reflect.has(n, e); return (!hl(e) || !Sf.has(e)) && Re(n, "has", e), t } function Jg(n) { return Re(n, "iterate", $t(n) ? "length" : Ht), Reflect.ownKeys(n) } var Gg = { get: Hg, set: Ug, deleteProperty: Kg, has: qg, ownKeys: Jg }, Yg = { get: jg, set(n, e) { return console.warn(`Set operation on key "${String(e)}" failed: target is readonly.`, n), !0 }, deleteProperty(n, e) { return console.warn(`Delete operation on key "${String(e)}" failed: target is readonly.`, n), !0 } }, gl = n => ts(n) ? xl(n) : n, yl = n => ts(n) ? Tf(n) : n, bl = n => n, ns = n => Reflect.getPrototypeOf(n); function Nr(n, e, t = !1, r = !1) { n = n.__v_raw; const i = z(n), s = z(e); e !== s && !t && Re(i, "get", e), !t && Re(i, "get", s); const { has: o } = ns(i), l = r ? bl : t ? yl : gl; if (o.call(i, e)) return l(n.get(e)); if (o.call(i, s)) return l(n.get(s)); n !== i && n.get(e) } function Rr(n, e = !1) { const t = this.__v_raw, r = z(t), i = z(n); return n !== i && !e && Re(r, "has", n), !e && Re(r, "has", i), n === i ? t.has(n) : t.has(n) || t.has(i) } function vr(n, e = !1) { return n = n.__v_raw, !e && Re(z(n), "iterate", Ht), Reflect.get(n, "size", n) } function Ea(n) { n = z(n); const e = z(this); return ns(e).has.call(e, n) || (e.add(n), St(e, "add", n, n)), this } function Ca(n, e) { e = z(e); const t = z(this), { has: r, get: i } = ns(t); let s = r.call(t, n); s ? Ef(t, r, n) : (n = z(n), s = r.call(t, n)); const o = i.call(t, n); return t.set(n, e), s ? yf(e, o) && St(t, "set", n, e, o) : St(t, "add", n, e), this } function Oa(n) { const e = z(this), { has: t, get: r } = ns(e); let i = t.call(e, n); i ? Ef(e, t, n) : (n = z(n), i = t.call(e, n)); const s = r ? r.call(e, n) : void 0, o = e.delete(n); return i && St(e, "delete", n, void 0, s), o } function Ta() { const n = z(this), e = n.size !== 0, t = Kn(n) ? new Map(n) : new Set(n), r = n.clear(); return e && St(n, "clear", void 0, void 0, t), r } function _r(n, e) { return function (r, i) { const s = this, o = s.__v_raw, l = z(o), a = e ? bl : n ? yl : gl; return !n && Re(l, "iterate", Ht), o.forEach((c, u) => r.call(i, a(c), a(u), s)) } } function Dr(n, e, t) { return function (...r) { const i = this.__v_raw, s = z(i), o = Kn(s), l = n === "entries" || n === Symbol.iterator && o, a = n === "keys" && o, c = i[n](...r), u = t ? bl : e ? yl : gl; return !e && Re(s, "iterate", a ? bo : Ht), { next() { const { value: f, done: d } = c.next(); return d ? { value: f, done: d } : { value: l ? [u(f[0]), u(f[1])] : u(f), done: d } }, [Symbol.iterator]() { return this } } } } function rt(n) { return function (...e) { { const t = e[0] ? `on key "${e[0]}" ` : ""; console.warn(`${_g(n)} operation ${t}failed: target is readonly.`, z(this)) } return n === "delete" ? !1 : this } } function Xg() { const n = { get(s) { return Nr(this, s) }, get size() { return vr(this) }, has: Rr, add: Ea, set: Ca, delete: Oa, clear: Ta, forEach: _r(!1, !1) }, e = { get(s) { return Nr(this, s, !1, !0) }, get size() { return vr(this) }, has: Rr, add: Ea, set: Ca, delete: Oa, clear: Ta, forEach: _r(!1, !0) }, t = { get(s) { return Nr(this, s, !0) }, get size() { return vr(this, !0) }, has(s) { return Rr.call(this, s, !0) }, add: rt("add"), set: rt("set"), delete: rt("delete"), clear: rt("clear"), forEach: _r(!0, !1) }, r = { get(s) { return Nr(this, s, !0, !0) }, get size() { return vr(this, !0) }, has(s) { return Rr.call(this, s, !0) }, add: rt("add"), set: rt("set"), delete: rt("delete"), clear: rt("clear"), forEach: _r(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(s => { n[s] = Dr(s, !1, !1), t[s] = Dr(s, !0, !1), e[s] = Dr(s, !1, !0), r[s] = Dr(s, !0, !0) }), [n, t, e, r] } var [Qg, Zg] = Xg(); function kf(n, e) { const t = n ? Zg : Qg; return (r, i, s) => i === "__v_isReactive" ? !n : i === "__v_isReadonly" ? n : i === "__v_raw" ? r : Reflect.get(es(t, i) && i in r ? t : r, i, s) } var ey = { get: kf(!1) }, ty = { get: kf(!0) }; function Ef(n, e, t) { const r = z(t); if (r !== t && e.call(n, r)) { const i = gf(n); console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`) } } var Cf = new WeakMap, ny = new WeakMap, Of = new WeakMap, ry = new WeakMap; function iy(n) { switch (n) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function sy(n) { return n.__v_skip || !Object.isExtensible(n) ? 0 : iy(gf(n)) } function xl(n) { return n && n.__v_isReadonly ? n : Mf(n, !1, Gg, ey, Cf) } function Tf(n) { return Mf(n, !0, Yg, ty, Of) } function Mf(n, e, t, r, i) { if (!ts(n)) return console.warn(`value cannot be made reactive: ${String(n)}`), n; if (n.__v_raw && !(e && n.__v_isReactive)) return n; const s = i.get(n); if (s) return s; const o = sy(n); if (o === 0) return n; const l = new Proxy(n, o === 2 ? r : t); return i.set(n, l), l } function z(n) { return n && z(n.__v_raw) || n } function xo(n) { return !!(n && n.__v_isRef === !0) } _e("nextTick", () => ul); _e("dispatch", n => Wn.bind(Wn, n)); _e("watch", (n, { evaluateLater: e, cleanup: t }) => (r, i) => { let s = e(r), l = ku(() => { let a; return s(c => a = c), a }, i); t(l) }); _e("store", Sg); _e("data", n => Ru(n)); _e("root", n => Xi(n)); _e("refs", n => (n._x_refs_proxy || (n._x_refs_proxy = Gt(oy(n))), n._x_refs_proxy)); function oy(n) { let e = []; return Xt(n, t => { t._x_refs && e.push(t._x_refs) }), e } var Ts = {}; function Af(n) { return Ts[n] || (Ts[n] = 0), ++Ts[n] } function ly(n, e) { return Xt(n, t => { if (t._x_ids && t._x_ids[e]) return !0 }) } function ay(n, e) { n._x_ids || (n._x_ids = {}), n._x_ids[e] || (n._x_ids[e] = Af(e)) } _e("id", (n, { cleanup: e }) => (t, r = null) => { let i = `${t}${r ? `-${r}` : ""}`; return cy(n, i, e, () => { let s = ly(n, t), o = s ? s._x_ids[t] : Af(t); return r ? `${t}-${o}-${r}` : `${t}-${o}` }) }); Zi((n, e) => { n._x_id && (e._x_id = n._x_id) }); function cy(n, e, t, r) { if (n._x_id || (n._x_id = {}), n._x_id[e]) return n._x_id[e]; let i = r(); return n._x_id[e] = i, t(() => { delete n._x_id[e] }), i } _e("el", n => n); Nf("Focus", "focus", "focus"); Nf("Persist", "persist", "persist"); function Nf(n, e, t) { _e(e, r => Oe(`You can't use [$${e}] without first installing the "${n}" plugin here: https://alpinejs.dev/plugins/${t}`, r)) } K("modelable", (n, { expression: e }, { effect: t, evaluateLater: r, cleanup: i }) => { let s = r(e), o = () => { let u; return s(f => u = f), u }, l = r(`${e} = __placeholder`), a = u => l(() => { }, { scope: { __placeholder: u } }), c = o(); a(c), queueMicrotask(() => { if (!n._x_model) return; n._x_removeModelListeners.default(); let u = n._x_model.get, f = n._x_model.set, d = ff({ get() { return u() }, set(p) { f(p) } }, { get() { return o() }, set(p) { a(p) } }); i(d) }) }); K("teleport", (n, { modifiers: e, expression: t }, { cleanup: r }) => { n.tagName.toLowerCase() !== "template" && Oe("x-teleport can only be used on a <template> tag", n); let i = Ma(t), s = n.content.cloneNode(!0).firstElementChild; n._x_teleport = s, s._x_teleportBack = n, n.setAttribute("data-teleport-template", !0), s.setAttribute("data-teleport-target", !0), n._x_forwardEvents && n._x_forwardEvents.forEach(l => { s.addEventListener(l, a => { a.stopPropagation(), n.dispatchEvent(new a.constructor(a.type, a)) }) }), Er(s, {}, n); let o = (l, a, c) => { c.includes("prepend") ? a.parentNode.insertBefore(l, a) : c.includes("append") ? a.parentNode.insertBefore(l, a.nextSibling) : a.appendChild(l) }; $(() => { o(s, i, e), kt(() => { Ye(s) })() }), n._x_teleportPutBack = () => { let l = Ma(t); $(() => { o(n._x_teleport, l, e) }) }, r(() => $(() => { s.remove(), Rn(s) })) }); var uy = document.createElement("div"); function Ma(n) { let e = kt(() => document.querySelector(n), () => uy)(); return e || Oe(`Cannot find x-teleport element for selector: "${n}"`), e } var Rf = () => { }; Rf.inline = (n, { modifiers: e }, { cleanup: t }) => { e.includes("self") ? n._x_ignoreSelf = !0 : n._x_ignore = !0, t(() => { e.includes("self") ? delete n._x_ignoreSelf : delete n._x_ignore }) }; K("ignore", Rf); K("effect", kt((n, { expression: e }, { effect: t }) => { t(ce(n, e)) })); function un(n, e, t, r) { let i = n, s = a => r(a), o = {}, l = (a, c) => u => c(a, u); if (t.includes("dot") && (e = fy(e)), t.includes("camel") && (e = dy(e)), t.includes("passive") && (o.passive = !0), t.includes("capture") && (o.capture = !0), t.includes("window") && (i = window), t.includes("document") && (i = document), t.includes("debounce")) { let a = t[t.indexOf("debounce") + 1] || "invalid-wait", c = ii(a.split("ms")[0]) ? Number(a.split("ms")[0]) : 250; s = cf(s, c) } if (t.includes("throttle")) { let a = t[t.indexOf("throttle") + 1] || "invalid-wait", c = ii(a.split("ms")[0]) ? Number(a.split("ms")[0]) : 250; s = uf(s, c) } return t.includes("prevent") && (s = l(s, (a, c) => { c.preventDefault(), a(c) })), t.includes("stop") && (s = l(s, (a, c) => { c.stopPropagation(), a(c) })), t.includes("once") && (s = l(s, (a, c) => { a(c), i.removeEventListener(e, s, o) })), (t.includes("away") || t.includes("outside")) && (i = document, s = l(s, (a, c) => { n.contains(c.target) || c.target.isConnected !== !1 && (n.offsetWidth < 1 && n.offsetHeight < 1 || n._x_isShown !== !1 && a(c)) })), t.includes("self") && (s = l(s, (a, c) => { c.target === n && a(c) })), (py(e) || vf(e)) && (s = l(s, (a, c) => { my(c, t) || a(c) })), i.addEventListener(e, s, o), () => { i.removeEventListener(e, s, o) } } function fy(n) { return n.replace(/-/g, ".") } function dy(n) { return n.toLowerCase().replace(/-(\w)/g, (e, t) => t.toUpperCase()) } function ii(n) { return !Array.isArray(n) && !isNaN(n) } function hy(n) { return [" ", "_"].includes(n) ? n : n.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase() } function py(n) { return ["keydown", "keyup"].includes(n) } function vf(n) { return ["contextmenu", "click", "mouse"].some(e => n.includes(e)) } function my(n, e) { let t = e.filter(s => !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll", "blur", "change", "lazy"].includes(s)); if (t.includes("debounce")) { let s = t.indexOf("debounce"); t.splice(s, ii((t[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (t.includes("throttle")) { let s = t.indexOf("throttle"); t.splice(s, ii((t[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (t.length === 0 || t.length === 1 && Aa(n.key).includes(t[0])) return !1; const i = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter(s => t.includes(s)); return t = t.filter(s => !i.includes(s)), !(i.length > 0 && i.filter(o => ((o === "cmd" || o === "super") && (o = "meta"), n[`${o}Key`])).length === i.length && (vf(n.type) || Aa(n.key).includes(t[0]))) } function Aa(n) { if (!n) return []; n = hy(n); let e = { ctrl: "control", slash: "/", space: " ", spacebar: " ", cmd: "meta", esc: "escape", up: "arrow-up", down: "arrow-down", left: "arrow-left", right: "arrow-right", period: ".", comma: ",", equal: "=", minus: "-", underscore: "_" }; return e[n] = n, Object.keys(e).map(t => { if (e[t] === n) return t }).filter(t => t) } K("model", (n, { modifiers: e, expression: t }, { effect: r, cleanup: i }) => { let s = n; e.includes("parent") && (s = n.parentNode); let o = ce(s, t), l; typeof t == "string" ? l = ce(s, `${t} = __placeholder`) : typeof t == "function" && typeof t() == "string" ? l = ce(s, `${t()} = __placeholder`) : l = () => { }; let a = () => { let g; return o(m => g = m), Na(g) ? g.get() : g }, c = g => { let m; o(y => m = y), Na(m) ? m.set(g) : l(() => { }, { scope: { __placeholder: g } }) }; typeof t == "string" && n.type === "radio" && $(() => { n.hasAttribute("name") || n.setAttribute("name", t) }); let u = e.includes("change") || e.includes("lazy"), f = e.includes("blur"), d = e.includes("enter"), p = u || f || d, h; if (xt) h = () => { }; else if (p) { let g = [], m = y => c(Ir(n, e, y, a())); u && g.push(un(n, "change", e, m)), f && g.push(un(n, "blur", e, m)), d && g.push(un(n, "keydown", e, y => { y.key === "Enter" && m(y) })), h = () => g.forEach(y => y()) } else { let g = n.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(n.type) ? "change" : "input"; h = un(n, g, e, m => { c(Ir(n, e, m, a())) }) } if (e.includes("fill") && ([void 0, null, ""].includes(a()) || dl(n) && Array.isArray(a()) || n.tagName.toLowerCase() === "select" && n.multiple) && c(Ir(n, e, { target: n }, a())), n._x_removeModelListeners || (n._x_removeModelListeners = {}), n._x_removeModelListeners.default = h, i(() => n._x_removeModelListeners.default()), n.form) { let g = un(n.form, "reset", [], m => { ul(() => n._x_model && n._x_model.set(Ir(n, e, { target: n }, a()))) }); i(() => g()) } n._x_model = { get() { return a() }, set(g) { c(g) } }, n._x_forceModelUpdate = g => { g === void 0 && typeof t == "string" && t.match(/\./) && (g = ""), window.fromModel = !0, $(() => rf(n, "value", g)), delete window.fromModel }, r(() => { let g = a(); e.includes("unintrusive") && document.activeElement.isSameNode(n) || n._x_forceModelUpdate(g) }) }); function Ir(n, e, t, r) { return $(() => { if (t instanceof CustomEvent && t.detail !== void 0) return t.detail !== null && t.detail !== void 0 ? t.detail : t.target.value; if (dl(n)) if (Array.isArray(r)) { let i = null; return e.includes("number") ? i = Ms(t.target.value) : e.includes("boolean") ? i = Gr(t.target.value) : i = t.target.value, t.target.checked ? r.includes(i) ? r : r.concat([i]) : r.filter(s => !gy(s, i)) } else return t.target.checked; else { if (n.tagName.toLowerCase() === "select" && n.multiple) return e.includes("number") ? Array.from(t.target.selectedOptions).map(i => { let s = i.value || i.text; return Ms(s) }) : e.includes("boolean") ? Array.from(t.target.selectedOptions).map(i => { let s = i.value || i.text; return Gr(s) }) : Array.from(t.target.selectedOptions).map(i => i.value || i.text); { let i; return af(n) ? t.target.checked ? i = t.target.value : i = r : i = t.target.value, e.includes("number") ? Ms(i) : e.includes("boolean") ? Gr(i) : e.includes("trim") ? i.trim() : i } } }) } function Ms(n) { let e = n ? parseFloat(n) : null; return yy(e) ? e : n } function gy(n, e) { return n == e } function yy(n) { return !Array.isArray(n) && !isNaN(n) } function Na(n) { return n !== null && typeof n == "object" && typeof n.get == "function" && typeof n.set == "function" } K("cloak", n => queueMicrotask(() => $(() => n.removeAttribute(Nn("cloak"))))); Xu(() => `[${Nn("init")}]`); K("init", kt((n, { expression: e }, { evaluate: t }) => typeof e == "string" ? !!e.trim() && t(e, {}, !1) : t(e, {}, !1))); K("text", (n, { expression: e }, { effect: t, evaluateLater: r }) => { let i = r(e); t(() => { i(s => { $(() => { n.textContent = s }) }) }) }); K("html", (n, { expression: e }, { effect: t, evaluateLater: r }) => { let i = r(e); t(() => { i(s => { $(() => { n.innerHTML = s, n._x_ignoreSelf = !0, Ye(n), delete n._x_ignoreSelf }) }) }) }); ll(Hu(":", ju(Nn("bind:")))); var _f = (n, { value: e, modifiers: t, expression: r, original: i }, { effect: s, cleanup: o }) => { if (!e) { let a = {}; kg(a), ce(n, r)(u => { hf(n, u, i) }, { scope: a }); return } if (e === "key") return by(n, r); if (n._x_inlineBindings && n._x_inlineBindings[e] && n._x_inlineBindings[e].extract) return; let l = ce(n, r); s(() => l(a => { a === void 0 && typeof r == "string" && r.match(/\./) && (a = ""), $(() => rf(n, e, a, t)) })), o(() => { n._x_undoAddedClasses && n._x_undoAddedClasses(), n._x_undoAddedStyles && n._x_undoAddedStyles() }) }; _f.inline = (n, { value: e, modifiers: t, expression: r }) => { e && (n._x_inlineBindings || (n._x_inlineBindings = {}), n._x_inlineBindings[e] = { expression: r, extract: !1 }) }; K("bind", _f); function by(n, e) { n._x_keyExpression = e } Yu(() => `[${Nn("data")}]`); K("data", (n, { expression: e }, { cleanup: t }) => { if (xy(n)) return; e = e === "" ? "{}" : e; let r = {}; rr(r, n); let i = {}; Cg(i, r); let s = zt(n, e, { scope: i }); (s === void 0 || s === !0) && (s = {}), rr(s, n); let o = Mn(s); il(o); let l = Er(n, o); o.init && zt(n, o.init), t(() => { o.destroy && zt(n, o.destroy), l() }) }); Zi((n, e) => { n._x_dataStack && (e._x_dataStack = n._x_dataStack, e.setAttribute("data-has-alpine-state", !0)) }); function xy(n) { return xt ? go ? !0 : n.hasAttribute("data-has-alpine-state") : !1 } K("show", (n, { modifiers: e, expression: t }, { effect: r }) => { let i = ce(n, t); n._x_doHide || (n._x_doHide = () => { $(() => { n.style.setProperty("display", "none", e.includes("important") ? "important" : void 0) }) }), n._x_doShow || (n._x_doShow = () => { $(() => { n.style.length === 1 && n.style.display === "none" ? n.removeAttribute("style") : n.style.removeProperty("display") }) }); let s = () => { n._x_doHide(), n._x_isShown = !1 }, o = () => { n._x_doShow(), n._x_isShown = !0 }, l = () => setTimeout(o), a = po(f => f ? o() : s(), f => { typeof n._x_toggleAndCascadeWithTransitions == "function" ? n._x_toggleAndCascadeWithTransitions(n, f, o, s) : f ? l() : s() }), c, u = !0; r(() => i(f => { !u && f === c || (e.includes("immediate") && (f ? l() : s()), a(f), c = f, u = !1) })) }); K("for", (n, { expression: e }, { effect: t, cleanup: r }) => { let i = wy(e), s = ce(n, i.items), o = ce(n, n._x_keyExpression || "index"); n._x_prevKeys = [], n._x_lookup = {}, t(() => Sy(n, i, s, o)), r(() => { Object.values(n._x_lookup).forEach(l => $(() => { Rn(l), l.remove() })), delete n._x_prevKeys, delete n._x_lookup }) }); function Sy(n, e, t, r) { let i = o => typeof o == "object" && !Array.isArray(o), s = n; t(o => { ky(o) && o >= 0 && (o = Array.from(Array(o).keys(), m => m + 1)), o === void 0 && (o = []); let l = n._x_lookup, a = n._x_prevKeys, c = [], u = []; if (i(o)) o = Object.entries(o).map(([m, y]) => { let S = Ra(e, y, m, o); r(k => { u.includes(k) && Oe("Duplicate key on x-for", n), u.push(k) }, { scope: { index: m, ...S } }), c.push(S) }); else for (let m = 0; m < o.length; m++) { let y = Ra(e, o[m], m, o); r(S => { u.includes(S) && Oe("Duplicate key on x-for", n), u.push(S) }, { scope: { index: m, ...y } }), c.push(y) } let f = [], d = [], p = [], h = []; for (let m = 0; m < a.length; m++) { let y = a[m]; u.indexOf(y) === -1 && p.push(y) } a = a.filter(m => !p.includes(m)); let g = "template"; for (let m = 0; m < u.length; m++) { let y = u[m], S = a.indexOf(y); if (S === -1) a.splice(m, 0, y), f.push([g, m]); else if (S !== m) { let k = a.splice(m, 1)[0], M = a.splice(S - 1, 1)[0]; a.splice(m, 0, M), a.splice(S, 0, k), d.push([k, M]) } else h.push(y); g = y } for (let m = 0; m < p.length; m++) { let y = p[m]; y in l && ($(() => { Rn(l[y]), l[y].remove() }), delete l[y]) } for (let m = 0; m < d.length; m++) { let [y, S] = d[m], k = l[y], M = l[S], T = document.createElement("div"); $(() => { M || Oe('x-for ":key" is undefined or invalid', s, S, l), M.after(T), k.after(M), M._x_currentIfEl && M.after(M._x_currentIfEl), T.before(k), k._x_currentIfEl && k.after(k._x_currentIfEl), T.remove() }), M._x_refreshXForScope(c[u.indexOf(S)]) } for (let m = 0; m < f.length; m++) { let [y, S] = f[m], k = y === "template" ? s : l[y]; k._x_currentIfEl && (k = k._x_currentIfEl); let M = c[S], T = u[S], D = document.importNode(s.content, !0).firstElementChild, C = Mn(M); Er(D, C, s), D._x_refreshXForScope = P => { Object.entries(P).forEach(([B, De]) => { C[B] = De }) }, $(() => { k.after(D), kt(() => Ye(D))() }), typeof T == "object" && Oe("x-for key cannot be an object, it must be a string or an integer", s), l[T] = D } for (let m = 0; m < h.length; m++)l[h[m]]._x_refreshXForScope(c[u.indexOf(h[m])]); s._x_prevKeys = u }) } function wy(n) { let e = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, t = /^\s*\(|\)\s*$/g, r = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, i = n.match(r); if (!i) return; let s = {}; s.items = i[2].trim(); let o = i[1].replace(t, "").trim(), l = o.match(e); return l ? (s.item = o.replace(e, "").trim(), s.index = l[1].trim(), l[2] && (s.collection = l[2].trim())) : s.item = o, s } function Ra(n, e, t, r) { let i = {}; return /^\[.*\]$/.test(n.item) && Array.isArray(e) ? n.item.replace("[", "").replace("]", "").split(",").map(o => o.trim()).forEach((o, l) => { i[o] = e[l] }) : /^\{.*\}$/.test(n.item) && !Array.isArray(e) && typeof e == "object" ? n.item.replace("{", "").replace("}", "").split(",").map(o => o.trim()).forEach(o => { i[o] = e[o] }) : i[n.item] = e, n.index && (i[n.index] = t), n.collection && (i[n.collection] = r), i } function ky(n) { return !Array.isArray(n) && !isNaN(n) } function Df() { } Df.inline = (n, { expression: e }, { cleanup: t }) => { let r = Xi(n); r._x_refs || (r._x_refs = {}), r._x_refs[e] = n, t(() => delete r._x_refs[e]) }; K("ref", Df); K("if", (n, { expression: e }, { effect: t, cleanup: r }) => { n.tagName.toLowerCase() !== "template" && Oe("x-if can only be used on a <template> tag", n); let i = ce(n, e), s = () => { if (n._x_currentIfEl) return n._x_currentIfEl; let l = n.content.cloneNode(!0).firstElementChild; return Er(l, {}, n), $(() => { n.after(l), kt(() => Ye(l))() }), n._x_currentIfEl = l, n._x_undoIf = () => { $(() => { Rn(l), l.remove() }), delete n._x_currentIfEl }, l }, o = () => { n._x_undoIf && (n._x_undoIf(), delete n._x_undoIf) }; t(() => i(l => { l ? s() : o() })), r(() => n._x_undoIf && n._x_undoIf()) }); K("id", (n, { expression: e }, { evaluate: t }) => { t(e).forEach(i => ay(n, i)) }); Zi((n, e) => { n._x_ids && (e._x_ids = n._x_ids) }); ll(Hu("@", ju(Nn("on:")))); K("on", kt((n, { value: e, modifiers: t, expression: r }, { cleanup: i }) => { let s = r ? ce(n, r) : () => { }; n.tagName.toLowerCase() === "template" && (n._x_forwardEvents || (n._x_forwardEvents = []), n._x_forwardEvents.includes(e) || n._x_forwardEvents.push(e)); let o = un(n, e, t, l => { s(() => { }, { scope: { $event: l }, params: [l] }) }); i(() => o()) })); rs("Collapse", "collapse", "collapse"); rs("Intersect", "intersect", "intersect"); rs("Focus", "trap", "focus"); rs("Mask", "mask", "mask"); function rs(n, e, t) { K(e, r => Oe(`You can't use [x-${e}] without first installing the "${n}" plugin here: https://alpinejs.dev/plugins/${t}`, r)) } vn.setEvaluator(Bu); vn.setRawEvaluator(Lm); vn.setReactivityEngine({ reactive: xl, effect: Ig, release: Pg, raw: z }); var Ey = vn, sn = Ey; function Cy(n) { n.directive("collapse", e), e.inline = (t, { modifiers: r }) => { r.includes("min") && (t._x_doShow = () => { }, t._x_doHide = () => { }) }; function e(t, { modifiers: r }) { let i = va(r, "duration", 250) / 1e3, s = va(r, "min", 0), o = !r.includes("min"); t._x_isShown || (t.style.height = `${s}px`), !t._x_isShown && o && (t.hidden = !0), t._x_isShown || (t.style.overflow = "hidden"); let l = (c, u) => { let f = n.setStyles(c, u); return u.height ? () => { } : f }, a = { transitionProperty: "height", transitionDuration: `${i}s`, transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)" }; t._x_transition = { in(c = () => { }, u = () => { }) { o && (t.hidden = !1), o && (t.style.display = null); let f = t.getBoundingClientRect().height; t.style.height = "auto"; let d = t.getBoundingClientRect().height; f === d && (f = s), n.transition(t, n.setStyles, { during: a, start: { height: f + "px" }, end: { height: d + "px" } }, () => t._x_isShown = !0, () => { Math.abs(t.getBoundingClientRect().height - d) < 1 && (t.style.overflow = null) }) }, out(c = () => { }, u = () => { }) { let f = t.getBoundingClientRect().height; n.transition(t, l, { during: a, start: { height: f + "px" }, end: { height: s + "px" } }, () => t.style.overflow = "hidden", () => { t._x_isShown = !1, t.style.height == `${s}px` && o && (t.style.display = "none", t.hidden = !0) }) } } } } function va(n, e, t) { if (n.indexOf(e) === -1) return t; const r = n[n.indexOf(e) + 1]; if (!r) return t; if (e === "duration") { let i = r.match(/([0-9]+)ms/); if (i) return i[1] } if (e === "min") { let i = r.match(/([0-9]+)px/); if (i) return i[1] } return r } var Oy = Cy; function Ty(n) { n.directive("intersect", n.skipDuringClone((e, { value: t, expression: r, modifiers: i }, { evaluateLater: s, cleanup: o }) => { let l = s(r), a = { rootMargin: Ny(i), threshold: My(i) }, c = new IntersectionObserver(u => { u.forEach(f => { f.isIntersecting !== (t === "leave") && (l(), i.includes("once") && c.disconnect()) }) }, a); c.observe(e), o(() => { c.disconnect() }) })) } function My(n) { if (n.includes("full")) return .99; if (n.includes("half")) return .5; if (!n.includes("threshold")) return 0; let e = n[n.indexOf("threshold") + 1]; return e === "100" ? 1 : e === "0" ? 0 : +`.${e}` } function Ay(n) { let e = n.match(/^(-?[0-9]+)(px|%)?$/); return e ? e[1] + (e[2] || "px") : void 0 } function Ny(n) { const e = "margin", t = "0px 0px 0px 0px", r = n.indexOf(e); if (r === -1) return t; let i = []; for (let s = 1; s < 5; s++)i.push(Ay(n[r + s] || "")); return i = i.filter(s => s !== void 0), i.length ? i.join(" ").trim() : t } var Ry = Ty; function ee(n) { this.content = n } ee.prototype = { constructor: ee, find: function (n) { for (var e = 0; e < this.content.length; e += 2)if (this.content[e] === n) return e; return -1 }, get: function (n) { var e = this.find(n); return e == -1 ? void 0 : this.content[e + 1] }, update: function (n, e, t) { var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice(); return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new ee(s) }, remove: function (n) { var e = this.find(n); if (e == -1) return this; var t = this.content.slice(); return t.splice(e, 2), new ee(t) }, addToStart: function (n, e) { return new ee([n, e].concat(this.remove(n).content)) }, addToEnd: function (n, e) { var t = this.remove(n).content.slice(); return t.push(n, e), new ee(t) }, addBefore: function (n, e, t) { var r = this.remove(e), i = r.content.slice(), s = r.find(n); return i.splice(s == -1 ? i.length : s, 0, e, t), new ee(i) }, forEach: function (n) { for (var e = 0; e < this.content.length; e += 2)n(this.content[e], this.content[e + 1]) }, prepend: function (n) { return n = ee.from(n), n.size ? new ee(n.content.concat(this.subtract(n).content)) : this }, append: function (n) { return n = ee.from(n), n.size ? new ee(this.subtract(n).content.concat(n.content)) : this }, subtract: function (n) { var e = this; n = ee.from(n); for (var t = 0; t < n.content.length; t += 2)e = e.remove(n.content[t]); return e }, toObject: function () { var n = {}; return this.forEach(function (e, t) { n[e] = t }), n }, get size() { return this.content.length >> 1 } }; ee.from = function (n) { if (n instanceof ee) return n; var e = []; if (n) for (var t in n) e.push(t, n[t]); return new ee(e) }; function If(n, e, t) { for (let r = 0; ; r++) { if (r == n.childCount || r == e.childCount) return n.childCount == e.childCount ? null : t; let i = n.child(r), s = e.child(r); if (i == s) { t += i.nodeSize; continue } if (!i.sameMarkup(s)) return t; if (i.isText && i.text != s.text) { for (let o = 0; i.text[o] == s.text[o]; o++)t++; return t } if (i.content.size || s.content.size) { let o = If(i.content, s.content, t + 1); if (o != null) return o } t += i.nodeSize } } function Pf(n, e, t, r) { for (let i = n.childCount, s = e.childCount; ;) { if (i == 0 || s == 0) return i == s ? null : { a: t, b: r }; let o = n.child(--i), l = e.child(--s), a = o.nodeSize; if (o == l) { t -= a, r -= a; continue } if (!o.sameMarkup(l)) return { a: t, b: r }; if (o.isText && o.text != l.text) { let c = 0, u = Math.min(o.text.length, l.text.length); for (; c < u && o.text[o.text.length - c - 1] == l.text[l.text.length - c - 1];)c++, t--, r--; return { a: t, b: r } } if (o.content.size || l.content.size) { let c = Pf(o.content, l.content, t - 1, r - 1); if (c) return c } t -= a, r -= a } } class x { constructor(e, t) { if (this.content = e, this.size = t || 0, t == null) for (let r = 0; r < e.length; r++)this.size += e[r].nodeSize } nodesBetween(e, t, r, i = 0, s) { for (let o = 0, l = 0; l < t; o++) { let a = this.content[o], c = l + a.nodeSize; if (c > e && r(a, i + l, s || null, o) !== !1 && a.content.size) { let u = l + 1; a.nodesBetween(Math.max(0, e - u), Math.min(a.content.size, t - u), r, i + u) } l = c } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, t, r, i) { let s = "", o = !0; return this.nodesBetween(e, t, (l, a) => { let c = l.isText ? l.text.slice(Math.max(e, a) - a, t - a) : l.isLeaf ? i ? typeof i == "function" ? i(l) : i : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : ""; l.isBlock && (l.isLeaf && c || l.isTextblock) && r && (o ? o = !1 : s += r), s += c }, 0), s } append(e) { if (!e.size) return this; if (!this.size) return e; let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0; for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)i.push(e.content[s]); return new x(i, this.size + e.size) } cut(e, t = this.size) { if (e == 0 && t == this.size) return this; let r = [], i = 0; if (t > e) for (let s = 0, o = 0; o < t; s++) { let l = this.content[s], a = o + l.nodeSize; a > e && ((o < e || a > t) && (l.isText ? l = l.cut(Math.max(0, e - o), Math.min(l.text.length, t - o)) : l = l.cut(Math.max(0, e - o - 1), Math.min(l.content.size, t - o - 1))), r.push(l), i += l.nodeSize), o = a } return new x(r, i) } cutByIndex(e, t) { return e == t ? x.empty : e == 0 && t == this.content.length ? this : new x(this.content.slice(e, t)) } replaceChild(e, t) { let r = this.content[e]; if (r == t) return this; let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize; return i[e] = t, new x(i, s) } addToStart(e) { return new x([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new x(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let t = 0; t < this.content.length; t++)if (!this.content[t].eq(e.content[t])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let t = this.content[e]; if (!t) throw new RangeError("Index " + e + " out of range for " + this); return t } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let t = 0, r = 0; t < this.content.length; t++) { let i = this.content[t]; e(i, r, t), r += i.nodeSize } } findDiffStart(e, t = 0) { return If(this, e, t) } findDiffEnd(e, t = this.size, r = e.size) { return Pf(this, e, t, r) } findIndex(e) { if (e == 0) return Pr(0, e); if (e == this.size) return Pr(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let t = 0, r = 0; ; t++) { let i = this.child(t), s = r + i.nodeSize; if (s >= e) return s == e ? Pr(t + 1, s) : Pr(t, r); r = s } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(e => e.toJSON()) : null } static fromJSON(e, t) { if (!t) return x.empty; if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new x(t.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return x.empty; let t, r = 0; for (let i = 0; i < e.length; i++) { let s = e[i]; r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s) } return new x(t || e, r) } static from(e) { if (!e) return x.empty; if (e instanceof x) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new x([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } x.empty = new x([], 0); const As = { index: 0, offset: 0 }; function Pr(n, e) { return As.index = n, As.offset = e, As } function si(n, e) { if (n === e) return !0; if (!(n && typeof n == "object") || !(e && typeof e == "object")) return !1; let t = Array.isArray(n); if (Array.isArray(e) != t) return !1; if (t) { if (n.length != e.length) return !1; for (let r = 0; r < n.length; r++)if (!si(n[r], e[r])) return !1 } else { for (let r in n) if (!(r in e) || !si(n[r], e[r])) return !1; for (let r in e) if (!(r in n)) return !1 } return !0 } let L = class So { constructor(e, t) { this.type = e, this.attrs = t } addToSet(e) { let t, r = !1; for (let i = 0; i < e.length; i++) { let s = e[i]; if (this.eq(s)) return e; if (this.type.excludes(s.type)) t || (t = e.slice(0, i)); else { if (s.type.excludes(this.type)) return e; !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s) } } return t || (t = e.slice()), r || t.push(this), t } removeFromSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1)); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && si(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Mark.fromJSON"); let r = e.marks[t.type]; if (!r) throw new RangeError(`There is no mark type ${t.type} in this schema`); let i = r.create(t.attrs); return r.checkAttrs(i.attrs), i } static sameSet(e, t) { if (e == t) return !0; if (e.length != t.length) return !1; for (let r = 0; r < e.length; r++)if (!e[r].eq(t[r])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && e.length == 0) return So.none; if (e instanceof So) return [e]; let t = e.slice(); return t.sort((r, i) => r.type.rank - i.type.rank), t } }; L.none = []; class oi extends Error { } class E { constructor(e, t, r) { this.content = e, this.openStart = t, this.openEnd = r } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, t) { let r = Bf(this.content, e + this.openStart, t); return r && new E(r, this.openStart, this.openEnd) } removeBetween(e, t) { return new E(Lf(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, t) { if (!t) return E.empty; let r = t.openStart || 0, i = t.openEnd || 0; if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid input for Slice.fromJSON"); return new E(x.fromJSON(e, t.content), r, i) } static maxOpen(e, t = !0) { let r = 0, i = 0; for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)r++; for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)i++; return new E(e, r, i) } } E.empty = new E(x.empty, 0, 0); function Lf(n, e, t) { let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: l } = n.findIndex(t); if (i == e || s.isText) { if (l != t && !n.child(o).isText) throw new RangeError("Removing non-flat range"); return n.cut(0, e).append(n.cut(t)) } if (r != o) throw new RangeError("Removing non-flat range"); return n.replaceChild(r, s.copy(Lf(s.content, e - i - 1, t - i - 1))) } function Bf(n, e, t, r) { let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i); if (s == e || o.isText) return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e)); let l = Bf(o.content, e - s - 1, t, o); return l && n.replaceChild(i, o.copy(l)) } function vy(n, e, t) { if (t.openStart > n.depth) throw new oi("Inserted content deeper than insertion position"); if (n.depth - t.openStart != e.depth - t.openEnd) throw new oi("Inconsistent open depths"); return Ff(n, e, t, 0) } function Ff(n, e, t, r) { let i = n.index(r), s = n.node(r); if (i == e.index(r) && r < n.depth - t.openStart) { let o = Ff(n, e, t, r + 1); return s.copy(s.content.replaceChild(i, o)) } else if (t.content.size) if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) { let o = n.parent, l = o.content; return Vt(o, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset))) } else { let { start: o, end: l } = _y(t, n); return Vt(s, $f(n, o, l, e, r)) } else return Vt(s, li(n, e, r)) } function zf(n, e) { if (!e.type.compatibleContent(n.type)) throw new oi("Cannot join " + e.type.name + " onto " + n.type.name) } function wo(n, e, t) { let r = n.node(t); return zf(r, e.node(t)), r } function jt(n, e) { let t = e.length - 1; t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n) } function qn(n, e, t, r) { let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount; n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (jt(n.nodeAfter, r), s++)); for (let l = s; l < o; l++)jt(i.child(l), r); e && e.depth == t && e.textOffset && jt(e.nodeBefore, r) } function Vt(n, e) { return n.type.checkContent(e), n.copy(e) } function $f(n, e, t, r, i) { let s = n.depth > i && wo(n, e, i + 1), o = r.depth > i && wo(t, r, i + 1), l = []; return qn(null, n, i, l), s && o && e.index(i) == t.index(i) ? (zf(s, o), jt(Vt(s, $f(n, e, t, r, i + 1)), l)) : (s && jt(Vt(s, li(n, e, i + 1)), l), qn(e, t, i, l), o && jt(Vt(o, li(t, r, i + 1)), l)), qn(r, null, i, l), new x(l) } function li(n, e, t) { let r = []; if (qn(null, n, t, r), n.depth > t) { let i = wo(n, e, t + 1); jt(Vt(i, li(n, e, t + 1)), r) } return qn(e, null, t, r), new x(r) } function _y(n, e) { let t = e.depth - n.openStart, i = e.node(t).copy(n.content); for (let s = t - 1; s >= 0; s--)i = e.node(s).copy(x.from(i)); return { start: i.resolveNoCache(n.openStart + t), end: i.resolveNoCache(i.content.size - n.openEnd - t) } } class or { constructor(e, t, r) { this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1 } resolveDepth(e) { return e == null ? this.depth : e < 0 ? this.depth + e : e } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(e) { return this.path[this.resolveDepth(e) * 3] } index(e) { return this.path[this.resolveDepth(e) * 3 + 1] } indexAfter(e) { return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1) } start(e) { return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1 } end(e) { return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size } before(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position before the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] } after(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position after the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let e = this.parent, t = this.index(this.depth); if (t == e.childCount) return null; let r = this.pos - this.path[this.path.length - 1], i = e.child(t); return r ? e.child(t).cut(r) : i } get nodeBefore() { let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1]; return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1) } posAtIndex(e, t) { t = this.resolveDepth(t); let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1; for (let s = 0; s < e; s++)i += r.child(s).nodeSize; return i } marks() { let e = this.parent, t = this.index(); if (e.content.size == 0) return L.none; if (this.textOffset) return e.child(t).marks; let r = e.maybeChild(t - 1), i = e.maybeChild(t); if (!r) { let l = r; r = i, i = l } let s = r.marks; for (var o = 0; o < s.length; o++)s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s)); return s } marksAcross(e) { let t = this.parent.maybeChild(this.index()); if (!t || !t.isInline) return null; let r = t.marks, i = e.parent.maybeChild(e.index()); for (var s = 0; s < r.length; s++)r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r)); return r } sharedDepth(e) { for (let t = this.depth; t > 0; t--)if (this.start(t) <= e && this.end(t) >= e) return t; return 0 } blockRange(e = this, t) { if (e.pos < this.pos) return e.blockRange(this); for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)if (e.pos <= this.end(r) && (!t || t(this.node(r)))) return new ai(this, e, r); return null } sameParent(e) { return this.pos - this.parentOffset == e.pos - e.parentOffset } max(e) { return e.pos > this.pos ? e : this } min(e) { return e.pos < this.pos ? e : this } toString() { let e = ""; for (let t = 1; t <= this.depth; t++)e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1); return e + ":" + this.parentOffset } static resolve(e, t) { if (!(t >= 0 && t <= e.content.size)) throw new RangeError("Position " + t + " out of range"); let r = [], i = 0, s = t; for (let o = e; ;) { let { index: l, offset: a } = o.content.findIndex(s), c = s - a; if (r.push(o, l, i + a), !c || (o = o.child(l), o.isText)) break; s = c - 1, i += a + 1 } return new or(t, r, s) } static resolveCached(e, t) { let r = _a.get(e); if (r) for (let s = 0; s < r.elts.length; s++) { let o = r.elts[s]; if (o.pos == t) return o } else _a.set(e, r = new Dy); let i = r.elts[r.i] = or.resolve(e, t); return r.i = (r.i + 1) % Iy, i } } class Dy { constructor() { this.elts = [], this.i = 0 } } const Iy = 12, _a = new WeakMap; class ai { constructor(e, t, r) { this.$from = e, this.$to = t, this.depth = r } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const Py = Object.create(null); let pt = class ko { constructor(e, t, r, i = L.none) { this.type = e, this.attrs = t, this.marks = i, this.content = r || x.empty } get children() { return this.content.content } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(e) { return this.content.child(e) } maybeChild(e) { return this.content.maybeChild(e) } forEach(e) { this.content.forEach(e) } nodesBetween(e, t, r, i = 0) { this.content.nodesBetween(e, t, r, i, this) } descendants(e) { this.nodesBetween(0, this.content.size, e) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(e, t, r, i) { return this.content.textBetween(e, t, r, i) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(e) { return this == e || this.sameMarkup(e) && this.content.eq(e.content) } sameMarkup(e) { return this.hasMarkup(e.type, e.attrs, e.marks) } hasMarkup(e, t, r) { return this.type == e && si(this.attrs, t || e.defaultAttrs || Py) && L.sameSet(this.marks, r || L.none) } copy(e = null) { return e == this.content ? this : new ko(this.type, this.attrs, e, this.marks) } mark(e) { return e == this.marks ? this : new ko(this.type, this.attrs, this.content, e) } cut(e, t = this.content.size) { return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t)) } slice(e, t = this.content.size, r = !1) { if (e == t) return E.empty; let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), l = i.start(o), c = i.node(o).content.cut(i.pos - l, s.pos - l); return new E(c, i.depth - o, s.depth - o) } replace(e, t, r) { return vy(this.resolve(e), this.resolve(t), r) } nodeAt(e) { for (let t = this; ;) { let { index: r, offset: i } = t.content.findIndex(e); if (t = t.maybeChild(r), !t) return null; if (i == e || t.isText) return t; e -= i + 1 } } childAfter(e) { let { index: t, offset: r } = this.content.findIndex(e); return { node: this.content.maybeChild(t), index: t, offset: r } } childBefore(e) { if (e == 0) return { node: null, index: 0, offset: 0 }; let { index: t, offset: r } = this.content.findIndex(e); if (r < e) return { node: this.content.child(t), index: t, offset: r }; let i = this.content.child(t - 1); return { node: i, index: t - 1, offset: r - i.nodeSize } } resolve(e) { return or.resolveCached(this, e) } resolveNoCache(e) { return or.resolve(this, e) } rangeHasMark(e, t, r) { let i = !1; return t > e && this.nodesBetween(e, t, s => (r.isInSet(s.marks) && (i = !0), !i)), i } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let e = this.type.name; return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Hf(this.marks, e) } contentMatchAt(e) { let t = this.type.contentMatch.matchFragment(this.content, 0, e); if (!t) throw new Error("Called contentMatchAt on a node with invalid content"); return t } canReplace(e, t, r = x.empty, i = 0, s = r.childCount) { let o = this.contentMatchAt(e).matchFragment(r, i, s), l = o && o.matchFragment(this.content, t); if (!l || !l.validEnd) return !1; for (let a = i; a < s; a++)if (!this.type.allowsMarks(r.child(a).marks)) return !1; return !0 } canReplaceWith(e, t, r, i) { if (i && !this.type.allowsMarks(i)) return !1; let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t); return o ? o.validEnd : !1 } canAppend(e) { return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type) } check() { this.type.checkContent(this.content), this.type.checkAttrs(this.attrs); let e = L.none; for (let t = 0; t < this.marks.length; t++) { let r = this.marks[t]; r.type.checkAttrs(r.attrs), e = r.addToSet(e) } if (!L.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(t => t.type.name)}`); this.content.forEach(t => t.check()) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map(t => t.toJSON())), e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Node.fromJSON"); let r; if (t.marks) { if (!Array.isArray(t.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); r = t.marks.map(e.markFromJSON) } if (t.type == "text") { if (typeof t.text != "string") throw new RangeError("Invalid text node in JSON"); return e.text(t.text, r) } let i = x.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r); return s.type.checkAttrs(s.attrs), s } }; pt.prototype.text = void 0; class ci extends pt { constructor(e, t, r, i) { if (super(e, t, null, i), !r) throw new RangeError("Empty text nodes are not allowed"); this.text = r } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Hf(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(e, t) { return this.text.slice(e, t) } get nodeSize() { return this.text.length } mark(e) { return e == this.marks ? this : new ci(this.type, this.attrs, this.text, e) } withText(e) { return e == this.text ? this : new ci(this.type, this.attrs, e, this.marks) } cut(e = 0, t = this.text.length) { return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t)) } eq(e) { return this.sameMarkup(e) && this.text == e.text } toJSON() { let e = super.toJSON(); return e.text = this.text, e } } function Hf(n, e) { for (let t = n.length - 1; t >= 0; t--)e = n[t].type.name + "(" + e + ")"; return e } class Qt {
  constructor(e) { this.validEnd = e, this.next = [], this.wrapCache = [] } static parse(e, t) { let r = new Ly(e, t); if (r.next == null) return Qt.empty; let i = jf(r); r.next && r.err("Unexpected trailing text"); let s = Vy(jy(i)); return Uy(s, r), s } matchType(e) { for (let t = 0; t < this.next.length; t++)if (this.next[t].type == e) return this.next[t].next; return null } matchFragment(e, t = 0, r = e.childCount) { let i = this; for (let s = t; i && s < r; s++)i = i.matchType(e.child(s).type); return i } get inlineContent() { return this.next.length != 0 && this.next[0].type.isInline } get defaultType() { for (let e = 0; e < this.next.length; e++) { let { type: t } = this.next[e]; if (!(t.isText || t.hasRequiredAttrs())) return t } return null } compatible(e) { for (let t = 0; t < this.next.length; t++)for (let r = 0; r < e.next.length; r++)if (this.next[t].type == e.next[r].type) return !0; return !1 } fillBefore(e, t = !1, r = 0) { let i = [this]; function s(o, l) { let a = o.matchFragment(e, r); if (a && (!t || a.validEnd)) return x.from(l.map(c => c.createAndFill())); for (let c = 0; c < o.next.length; c++) { let { type: u, next: f } = o.next[c]; if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(f) == -1) { i.push(f); let d = s(f, l.concat(u)); if (d) return d } } return null } return s(this, []) } findWrapping(e) { for (let r = 0; r < this.wrapCache.length; r += 2)if (this.wrapCache[r] == e) return this.wrapCache[r + 1]; let t = this.computeWrapping(e); return this.wrapCache.push(e, t), t } computeWrapping(e) { let t = Object.create(null), r = [{ match: this, type: null, via: null }]; for (; r.length;) { let i = r.shift(), s = i.match; if (s.matchType(e)) { let o = []; for (let l = i; l.type; l = l.via)o.push(l.type); return o.reverse() } for (let o = 0; o < s.next.length; o++) { let { type: l, next: a } = s.next[o]; !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || a.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(e) { if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`); return this.next[e] } toString() {
    let e = []; function t(r) { e.push(r); for (let i = 0; i < r.next.length; i++)e.indexOf(r.next[i].next) == -1 && t(r.next[i].next) } return t(this), e.map((r, i) => { let s = i + (r.validEnd ? "*" : " ") + " "; for (let o = 0; o < r.next.length; o++)s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next); return s }).join(`
`)
  }
} Qt.empty = new Qt(!0); class Ly { constructor(e, t) { this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(e) { return this.next == e && (this.pos++ || !0) } err(e) { throw new SyntaxError(e + " (in content expression '" + this.string + "')") } } function jf(n) { let e = []; do e.push(By(n)); while (n.eat("|")); return e.length == 1 ? e[0] : { type: "choice", exprs: e } } function By(n) { let e = []; do e.push(Fy(n)); while (n.next && n.next != ")" && n.next != "|"); return e.length == 1 ? e[0] : { type: "seq", exprs: e } } function Fy(n) { let e = Hy(n); for (; ;)if (n.eat("+")) e = { type: "plus", expr: e }; else if (n.eat("*")) e = { type: "star", expr: e }; else if (n.eat("?")) e = { type: "opt", expr: e }; else if (n.eat("{")) e = zy(n, e); else break; return e } function Da(n) { /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'"); let e = Number(n.next); return n.pos++, e } function zy(n, e) { let t = Da(n), r = t; return n.eat(",") && (n.next != "}" ? r = Da(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e } } function $y(n, e) { let t = n.nodeTypes, r = t[e]; if (r) return [r]; let i = []; for (let s in t) { let o = t[s]; o.isInGroup(e) && i.push(o) } return i.length == 0 && n.err("No node type or group '" + e + "' found"), i } function Hy(n) { if (n.eat("(")) { let e = jf(n); return n.eat(")") || n.err("Missing closing paren"), e } else if (/\W/.test(n.next)) n.err("Unexpected token '" + n.next + "'"); else { let e = $y(n, n.next).map(t => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t })); return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e } } } function jy(n) { let e = [[]]; return i(s(n, 0), t()), e; function t() { return e.push([]) - 1 } function r(o, l, a) { let c = { term: a, to: l }; return e[o].push(c), c } function i(o, l) { o.forEach(a => a.to = l) } function s(o, l) { if (o.type == "choice") return o.exprs.reduce((a, c) => a.concat(s(c, l)), []); if (o.type == "seq") for (let a = 0; ; a++) { let c = s(o.exprs[a], l); if (a == o.exprs.length - 1) return c; i(c, l = t()) } else if (o.type == "star") { let a = t(); return r(l, a), i(s(o.expr, a), a), [r(a)] } else if (o.type == "plus") { let a = t(); return i(s(o.expr, l), a), i(s(o.expr, a), a), [r(a)] } else { if (o.type == "opt") return [r(l)].concat(s(o.expr, l)); if (o.type == "range") { let a = l; for (let c = 0; c < o.min; c++) { let u = t(); i(s(o.expr, a), u), a = u } if (o.max == -1) i(s(o.expr, a), a); else for (let c = o.min; c < o.max; c++) { let u = t(); r(a, u), i(s(o.expr, a), u), a = u } return [r(a)] } else { if (o.type == "name") return [r(l, void 0, o.value)]; throw new Error("Unknown expr type") } } } } function Vf(n, e) { return e - n } function Ia(n, e) { let t = []; return r(e), t.sort(Vf); function r(i) { let s = n[i]; if (s.length == 1 && !s[0].term) return r(s[0].to); t.push(i); for (let o = 0; o < s.length; o++) { let { term: l, to: a } = s[o]; !l && t.indexOf(a) == -1 && r(a) } } } function Vy(n) { let e = Object.create(null); return t(Ia(n, 0)); function t(r) { let i = []; r.forEach(o => { n[o].forEach(({ term: l, to: a }) => { if (!l) return; let c; for (let u = 0; u < i.length; u++)i[u][0] == l && (c = i[u][1]); Ia(n, a).forEach(u => { c || i.push([l, c = []]), c.indexOf(u) == -1 && c.push(u) }) }) }); let s = e[r.join(",")] = new Qt(r.indexOf(n.length - 1) > -1); for (let o = 0; o < i.length; o++) { let l = i[o][1].sort(Vf); s.next.push({ type: i[o][0], next: e[l.join(",")] || t(l) }) } return s } } function Uy(n, e) { for (let t = 0, r = [n]; t < r.length; t++) { let i = r[t], s = !i.validEnd, o = []; for (let l = 0; l < i.next.length; l++) { let { type: a, next: c } = i.next[l]; o.push(a.name), s && !(a.isText || a.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c) } s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } } function Uf(n) { let e = Object.create(null); for (let t in n) { let r = n[t]; if (!r.hasDefault) return null; e[t] = r.default } return e } function Wf(n, e) { let t = Object.create(null); for (let r in n) { let i = e && e[r]; if (i === void 0) { let s = n[r]; if (s.hasDefault) i = s.default; else throw new RangeError("No value supplied for attribute " + r) } t[r] = i } return t } function Kf(n, e, t, r) { for (let i in e) if (!(i in n)) throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`); for (let i in n) { let s = n[i]; s.validate && s.validate(e[i]) } } function qf(n, e) { let t = Object.create(null); if (e) for (let r in e) t[r] = new Ky(n, r, e[r]); return t } let Pa = class Jf { constructor(e, t, r) { this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = qf(e, r.attrs), this.defaultAttrs = Uf(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text" } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == Qt.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } isInGroup(e) { return this.groups.indexOf(e) > -1 } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let e in this.attrs) if (this.attrs[e].isRequired) return !0; return !1 } compatibleContent(e) { return this == e || this.contentMatch.compatible(e.contentMatch) } computeAttrs(e) { return !e && this.defaultAttrs ? this.defaultAttrs : Wf(this.attrs, e) } create(e = null, t, r) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new pt(this, this.computeAttrs(e), x.from(t), L.setFrom(r)) } createChecked(e = null, t, r) { return t = x.from(t), this.checkContent(t), new pt(this, this.computeAttrs(e), t, L.setFrom(r)) } createAndFill(e = null, t, r) { if (e = this.computeAttrs(e), t = x.from(t), t.size) { let o = this.contentMatch.fillBefore(t); if (!o) return null; t = o.append(t) } let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(x.empty, !0); return s ? new pt(this, e, t.append(s), L.setFrom(r)) : null } validContent(e) { let t = this.contentMatch.matchFragment(e); if (!t || !t.validEnd) return !1; for (let r = 0; r < e.childCount; r++)if (!this.allowsMarks(e.child(r).marks)) return !1; return !0 } checkContent(e) { if (!this.validContent(e)) throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`) } checkAttrs(e) { Kf(this.attrs, e, "node", this.name) } allowsMarkType(e) { return this.markSet == null || this.markSet.indexOf(e) > -1 } allowsMarks(e) { if (this.markSet == null) return !0; for (let t = 0; t < e.length; t++)if (!this.allowsMarkType(e[t].type)) return !1; return !0 } allowedMarks(e) { if (this.markSet == null) return e; let t; for (let r = 0; r < e.length; r++)this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r)); return t ? t.length ? t : L.none : e } static compile(e, t) { let r = Object.create(null); e.forEach((s, o) => r[s] = new Jf(s, t, o)); let i = t.spec.topNode || "doc"; if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')"); if (!r.text) throw new RangeError("Every schema needs a 'text' type"); for (let s in r.text.attrs) throw new RangeError("The text node type should not have attributes"); return r } }; function Wy(n, e, t) { let r = t.split("|"); return i => { let s = i === null ? "null" : typeof i; if (r.indexOf(s) < 0) throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`) } } class Ky { constructor(e, t, r) { this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? Wy(e, t, r.validate) : r.validate } get isRequired() { return !this.hasDefault } } class is { constructor(e, t, r, i) { this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = qf(e, i.attrs), this.excluded = null; let s = Uf(this.attrs); this.instance = s ? new L(this, s) : null } create(e = null) { return !e && this.instance ? this.instance : new L(this, Wf(this.attrs, e)) } static compile(e, t) { let r = Object.create(null), i = 0; return e.forEach((s, o) => r[s] = new is(s, i++, t, o)), r } removeFromSet(e) { for (var t = 0; t < e.length; t++)e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (e[t].type == this) return e[t] } checkAttrs(e) { Kf(this.attrs, e, "mark", this.name) } excludes(e) { return this.excluded.indexOf(e) > -1 } } class Gf { constructor(e) { this.linebreakReplacement = null, this.cached = Object.create(null); let t = this.spec = {}; for (let i in e) t[i] = e[i]; t.nodes = ee.from(e.nodes), t.marks = ee.from(e.marks || {}), this.nodes = Pa.compile(this.spec.nodes, this), this.marks = is.compile(this.spec.marks, this); let r = Object.create(null); for (let i in this.nodes) { if (i in this.marks) throw new RangeError(i + " can not be both a node and a mark"); let s = this.nodes[i], o = s.spec.content || "", l = s.spec.marks; if (s.contentMatch = r[o] || (r[o] = Qt.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) { if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined"); if (!s.isInline || !s.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes"); this.linebreakReplacement = s } s.markSet = l == "_" ? null : l ? La(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null } for (let i in this.marks) { let s = this.marks[i], o = s.spec.excludes; s.excluded = o == null ? [s] : o == "" ? [] : La(this, o.split(" ")) } this.nodeFromJSON = i => pt.fromJSON(this, i), this.markFromJSON = i => L.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(e, t = null, r, i) { if (typeof e == "string") e = this.nodeType(e); else if (e instanceof Pa) { if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")") } else throw new RangeError("Invalid node type: " + e); return e.createChecked(t, r, i) } text(e, t) { let r = this.nodes.text; return new ci(r, r.defaultAttrs, e, L.setFrom(t)) } mark(e, t) { return typeof e == "string" && (e = this.marks[e]), e.create(t) } nodeType(e) { let t = this.nodes[e]; if (!t) throw new RangeError("Unknown node type: " + e); return t } } function La(n, e) { let t = []; for (let r = 0; r < e.length; r++) { let i = e[r], s = n.marks[i], o = s; if (s) t.push(s); else for (let l in n.marks) { let a = n.marks[l]; (i == "_" || a.spec.group && a.spec.group.split(" ").indexOf(i) > -1) && t.push(o = a) } if (!o) throw new SyntaxError("Unknown mark type: '" + e[r] + "'") } return t } function qy(n) { return n.tag != null } function Jy(n) { return n.style != null } class mt { constructor(e, t) { this.schema = e, this.rules = t, this.tags = [], this.styles = []; let r = this.matchedStyles = []; t.forEach(i => { if (qy(i)) this.tags.push(i); else if (Jy(i)) { let s = /[^=]*/.exec(i.style)[0]; r.indexOf(s) < 0 && r.push(s), this.styles.push(i) } }), this.normalizeLists = !this.tags.some(i => { if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1; let s = e.nodes[i.node]; return s.contentMatch.matchType(s) }) } parse(e, t = {}) { let r = new Fa(this, t, !1); return r.addAll(e, L.none, t.from, t.to), r.finish() } parseSlice(e, t = {}) { let r = new Fa(this, t, !0); return r.addAll(e, L.none, t.from, t.to), E.maxOpen(r.finish()) } matchTag(e, t, r) { for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) { let s = this.tags[i]; if (Xy(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) { if (s.getAttrs) { let o = s.getAttrs(e); if (o === !1) continue; s.attrs = o || void 0 } return s } } } matchStyle(e, t, r, i) { for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) { let o = this.styles[s], l = o.style; if (!(l.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) { if (o.getAttrs) { let a = o.getAttrs(t); if (a === !1) continue; o.attrs = a || void 0 } return o } } } static schemaRules(e) { let t = []; function r(i) { let s = i.priority == null ? 50 : i.priority, o = 0; for (; o < t.length; o++) { let l = t[o]; if ((l.priority == null ? 50 : l.priority) < s) break } t.splice(o, 0, i) } for (let i in e.marks) { let s = e.marks[i].spec.parseDOM; s && s.forEach(o => { r(o = za(o)), o.mark || o.ignore || o.clearMark || (o.mark = i) }) } for (let i in e.nodes) { let s = e.nodes[i].spec.parseDOM; s && s.forEach(o => { r(o = za(o)), o.node || o.ignore || o.mark || (o.node = i) }) } return t } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new mt(e, mt.schemaRules(e))) } } const Yf = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, Gy = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, Xf = { ol: !0, ul: !0 }, lr = 1, Eo = 2, Jn = 4; function Ba(n, e, t) { return e != null ? (e ? lr : 0) | (e === "full" ? Eo : 0) : n && n.whitespace == "pre" ? lr | Eo : t & ~Jn } class Lr { constructor(e, t, r, i, s, o) { this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = L.none, this.match = s || (o & Jn ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let t = this.type.contentMatch.fillBefore(x.from(e)); if (t) this.match = this.type.contentMatch.matchFragment(t); else { let r = this.type.contentMatch, i; return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null } } return this.match.findWrapping(e.type) } finish(e) { if (!(this.options & lr)) { let r = this.content[this.content.length - 1], i; if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) { let s = r; r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length)) } } let t = x.from(this.content); return !e && this.match && (t = t.append(this.match.fillBefore(x.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Yf.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } } class Fa {
  constructor(e, t, r) { this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1; let i = t.topNode, s, o = Ba(null, t.preserveWhitespace, 0) | (r ? Jn : 0); i ? s = new Lr(i.type, i.attrs, L.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new Lr(null, null, L.none, !0, null, o) : s = new Lr(e.schema.topNodeType, null, L.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e, t) { e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t) } addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, s = i.options & Eo ? "full" : this.localPreserveWS || (i.options & lr) > 0, { schema: o } = this.parser; if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s) if (s === "full") r = r.replace(/\r\n?/g, `
`); else if (o.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(o.linebreakReplacement.create())) { let l = r.split(/\r?\n|\r/); for (let a = 0; a < l.length; a++)a && this.insertNode(o.linebreakReplacement.create(), t, !0), l[a] && this.insertNode(o.text(l[a]), t, !/\S/.test(l[a])); r = "" } else r = r.replace(/\r?\n|\r/g, " "); else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) { let l = i.content[i.content.length - 1], a = e.previousSibling; (!l || a && a.nodeName == "BR" || l.isText && /[ \t\r\n\u000c]$/.test(l.text)) && (r = r.slice(1)) } r && this.insertNode(o.text(r), t, !/\S/.test(r)), this.findInText(e)
    } else this.findInside(e)
  } addElement(e, t, r) { let i = this.localPreserveWS, s = this.top; (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0); let o = e.nodeName.toLowerCase(), l; Xf.hasOwnProperty(o) && this.parser.normalizeLists && Yy(e); let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r)); e: if (a ? a.ignore : Gy.hasOwnProperty(o)) this.findInside(e), this.ignoreFallback(e, t); else if (!a || a.skip || a.closeParent) { a && a.closeParent ? this.open = Math.max(0, this.open - 1) : a && a.skip.nodeType && (e = a.skip); let c, u = this.needsBlock; if (Yf.hasOwnProperty(o)) s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0); else if (!e.firstChild) { this.leafFallback(e, t); break e } let f = a && a.skip ? t : this.readStyles(e, t); f && this.addAll(e, f), c && this.sync(s), this.needsBlock = u } else { let c = this.readStyles(e, t); c && this.addElementByRule(e, a, c, a.consuming === !1 ? l : void 0) } this.localPreserveWS = i } leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t)
  } ignoreFallback(e, t) { e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0) } readStyles(e, t) { let r = e.style; if (r && r.length) for (let i = 0; i < this.parser.matchedStyles.length; i++) { let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s); if (o) for (let l = void 0; ;) { let a = this.parser.matchStyle(s, o, this, l); if (!a) break; if (a.ignore) return null; if (a.clearMark ? t = t.filter(c => !a.clearMark(c)) : t = t.concat(this.parser.schema.marks[a.mark].create(a.attrs)), a.consuming === !1) l = a; else break } } return t } addElementByRule(e, t, r, i) { let s, o; if (t.node) if (o = this.parser.schema.nodes[t.node], o.isLeaf) this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r); else { let a = this.enter(o, t.attrs || null, r, t.preserveWhitespace); a && (s = !0, r = a) } else { let a = this.parser.schema.marks[t.mark]; r = r.concat(a.create(t.attrs)) } let l = this.top; if (o && o.isLeaf) this.findInside(e); else if (i) this.addElement(e, r, i); else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach(a => this.insertNode(a, r, !1)); else { let a = e; typeof t.contentElement == "string" ? a = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? a = t.contentElement(e) : t.contentElement && (a = t.contentElement), this.findAround(e, a, !0), this.addAll(a, r), this.findAround(e, a, !1) } s && this.sync(l) && this.open-- } addAll(e, t, r, i) { let s = r || 0; for (let o = r ? e.childNodes[r] : e.firstChild, l = i == null ? null : e.childNodes[i]; o != l; o = o.nextSibling, ++s)this.findAtPoint(e, s), this.addDOM(o, t); this.findAtPoint(e, s) } findPlace(e, t, r) { let i, s; for (let o = this.open, l = 0; o >= 0; o--) { let a = this.nodes[o], c = a.findWrapping(e); if (c && (!i || i.length > c.length + l) && (i = c, s = a, !c.length)) break; if (a.solid) { if (r) break; l += 2 } } if (!i) return null; this.sync(s); for (let o = 0; o < i.length; o++)t = this.enterInner(i[o], null, t, !1); return t } insertNode(e, t, r) { if (e.isInline && this.needsBlock && !this.top.type) { let s = this.textblockFromContext(); s && (t = this.enterInner(s, null, t)) } let i = this.findPlace(e, t, r); if (i) { this.closeExtra(); let s = this.top; s.match && (s.match = s.match.matchType(e.type)); let o = L.none; for (let l of i.concat(e.marks)) (s.type ? s.type.allowsMarkType(l.type) : $a(l.type, e.type)) && (o = l.addToSet(o)); return s.content.push(e.mark(o)), !0 } return !1 } enter(e, t, r, i) { let s = this.findPlace(e.create(t), r, !1); return s && (s = this.enterInner(e, t, r, !0, i)), s } enterInner(e, t, r, i = !1, s) { this.closeExtra(); let o = this.top; o.match = o.match && o.match.matchType(e); let l = Ba(e, s, o.options); o.options & Jn && o.content.length == 0 && (l |= Jn); let a = L.none; return r = r.filter(c => (o.type ? o.type.allowsMarkType(c.type) : $a(c.type, e)) ? (a = c.addToSet(a), !1) : !0), this.nodes.push(new Lr(e, t, a, i, null, l)), this.open++, r } closeExtra(e = !1) { let t = this.nodes.length - 1; if (t > this.open) { for (; t > this.open; t--)this.nodes[t - 1].content.push(this.nodes[t].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen)) } sync(e) { for (let t = this.open; t >= 0; t--) { if (this.nodes[t] == e) return this.open = t, !0; this.localPreserveWS && (this.nodes[t].options |= lr) } return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let t = this.open; t >= 0; t--) { let r = this.nodes[t].content; for (let i = r.length - 1; i >= 0; i--)e += r[i].nodeSize; t && e++ } return e } findAtPoint(e, t) { if (this.find) for (let r = 0; r < this.find.length; r++)this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos) } findInside(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos) } findAround(e, t, r) { if (e != t && this.find) for (let i = 0; i < this.find.length; i++)this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos) } findInText(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (l, a) => { for (; l >= 0; l--) { let c = t[l]; if (c == "") { if (l == t.length - 1 || l == 0) continue; for (; a >= s; a--)if (o(l - 1, a)) return !0; return !1 } else { let u = a > 0 || a == 0 && i ? this.nodes[a].type : r && a >= s ? r.node(a - s).type : null; if (!u || u.name != c && !u.isInGroup(c)) return !1; a-- } } return !0 }; return o(t.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let t = e.depth; t >= 0; t--) { let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType; if (r && r.isTextblock && r.defaultAttrs) return r } for (let t in this.parser.schema.nodes) { let r = this.parser.schema.nodes[t]; if (r.isTextblock && r.defaultAttrs) return r } }
} function Yy(n) { for (let e = n.firstChild, t = null; e; e = e.nextSibling) { let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null; r && Xf.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null) } } function Xy(n, e) { return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e) } function za(n) { let e = {}; for (let t in n) e[t] = n[t]; return e } function $a(n, e) { let t = e.schema.nodes; for (let r in t) { let i = t[r]; if (!i.allowsMarkType(n)) continue; let s = [], o = l => { s.push(l); for (let a = 0; a < l.edgeCount; a++) { let { type: c, next: u } = l.edge(a); if (c == e || s.indexOf(u) < 0 && o(u)) return !0 } }; if (o(i.contentMatch)) return !0 } } class on { constructor(e, t) { this.nodes = e, this.marks = t } serializeFragment(e, t = {}, r) { r || (r = Ns(t).createDocumentFragment()); let i = r, s = []; return e.forEach(o => { if (s.length || o.marks.length) { let l = 0, a = 0; for (; l < s.length && a < o.marks.length;) { let c = o.marks[a]; if (!this.marks[c.type.name]) { a++; continue } if (!c.eq(s[l][0]) || c.type.spec.spanning === !1) break; l++, a++ } for (; l < s.length;)i = s.pop()[1]; for (; a < o.marks.length;) { let c = o.marks[a++], u = this.serializeMark(c, o.isInline, t); u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom) } } i.appendChild(this.serializeNodeInner(o, t)) }), r } serializeNodeInner(e, t) { let { dom: r, contentDOM: i } = Yr(Ns(t), this.nodes[e.type.name](e), null, e.attrs); if (i) { if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(e.content, t, i) } return r } serializeNode(e, t = {}) { let r = this.serializeNodeInner(e, t); for (let i = e.marks.length - 1; i >= 0; i--) { let s = this.serializeMark(e.marks[i], e.isInline, t); s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom) } return r } serializeMark(e, t, r = {}) { let i = this.marks[e.type.name]; return i && Yr(Ns(r), i(e, t), null, e.attrs) } static renderSpec(e, t, r = null, i) { return Yr(e, t, r, i) } static fromSchema(e) { return e.cached.domSerializer || (e.cached.domSerializer = new on(this.nodesFromSchema(e), this.marksFromSchema(e))) } static nodesFromSchema(e) { let t = Ha(e.nodes); return t.text || (t.text = r => r.text), t } static marksFromSchema(e) { return Ha(e.marks) } } function Ha(n) { let e = {}; for (let t in n) { let r = n[t].spec.toDOM; r && (e[t] = r) } return e } function Ns(n) { return n.document || window.document } const ja = new WeakMap; function Qy(n) { let e = ja.get(n); return e === void 0 && ja.set(n, e = Zy(n)), e } function Zy(n) { let e = null; function t(r) { if (r && typeof r == "object") if (Array.isArray(r)) if (typeof r[0] == "string") e || (e = []), e.push(r); else for (let i = 0; i < r.length; i++)t(r[i]); else for (let i in r) t(r[i]) } return t(n), e } function Yr(n, e, t, r) { if (typeof e == "string") return { dom: n.createTextNode(e) }; if (e.nodeType != null) return { dom: e }; if (e.dom && e.dom.nodeType != null) return e; let i = e[0], s; if (typeof i != "string") throw new RangeError("Invalid array passed to renderSpec"); if (r && (s = Qy(r)) && s.indexOf(e) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."); let o = i.indexOf(" "); o > 0 && (t = i.slice(0, o), i = i.slice(o + 1)); let l, a = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1; if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) { u = 2; for (let f in c) if (c[f] != null) { let d = f.indexOf(" "); d > 0 ? a.setAttributeNS(f.slice(0, d), f.slice(d + 1), c[f]) : f == "style" && a.style ? a.style.cssText = c[f] : a.setAttribute(f, c[f]) } } for (let f = u; f < e.length; f++) { let d = e[f]; if (d === 0) { if (f < e.length - 1 || f > u) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: a, contentDOM: a } } else { let { dom: p, contentDOM: h } = Yr(n, d, t, r); if (a.appendChild(p), h) { if (l) throw new RangeError("Multiple content holes"); l = h } } } return { dom: a, contentDOM: l } } const Qf = 65535, Zf = Math.pow(2, 16); function eb(n, e) { return n + e * Zf } function Va(n) { return n & Qf } function tb(n) { return (n - (n & Qf)) / Zf } const ed = 1, td = 2, Xr = 4, nd = 8; class Co { constructor(e, t, r) { this.pos = e, this.delInfo = t, this.recover = r } get deleted() { return (this.delInfo & nd) > 0 } get deletedBefore() { return (this.delInfo & (ed | Xr)) > 0 } get deletedAfter() { return (this.delInfo & (td | Xr)) > 0 } get deletedAcross() { return (this.delInfo & Xr) > 0 } } class be { constructor(e, t = !1) { if (this.ranges = e, this.inverted = t, !e.length && be.empty) return be.empty } recover(e) { let t = 0, r = Va(e); if (!this.inverted) for (let i = 0; i < r; i++)t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; return this.ranges[r * 3] + t + tb(e) } mapResult(e, t = 1) { return this._map(e, t, !1) } map(e, t = 1) { return this._map(e, t, !0) } _map(e, t, r) { let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2; for (let l = 0; l < this.ranges.length; l += 3) { let a = this.ranges[l] - (this.inverted ? i : 0); if (a > e) break; let c = this.ranges[l + s], u = this.ranges[l + o], f = a + c; if (e <= f) { let d = c ? e == a ? -1 : e == f ? 1 : t : t, p = a + i + (d < 0 ? 0 : u); if (r) return p; let h = e == (t < 0 ? a : f) ? null : eb(l / 3, e - a), g = e == a ? td : e == f ? ed : Xr; return (t < 0 ? e != a : e != f) && (g |= nd), new Co(p, g, h) } i += u - c } return r ? e + i : new Co(e + i, 0, null) } touches(e, t) { let r = 0, i = Va(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2; for (let l = 0; l < this.ranges.length; l += 3) { let a = this.ranges[l] - (this.inverted ? r : 0); if (a > e) break; let c = this.ranges[l + s], u = a + c; if (e <= u && l == i * 3) return !0; r += this.ranges[l + o] - c } return !1 } forEach(e) { let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2; for (let i = 0, s = 0; i < this.ranges.length; i += 3) { let o = this.ranges[i], l = o - (this.inverted ? s : 0), a = o + (this.inverted ? 0 : s), c = this.ranges[i + t], u = this.ranges[i + r]; e(l, l + c, a, a + u), s += u - c } } invert() { return new be(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(e) { return e == 0 ? be.empty : new be(e < 0 ? [0, -e, 0] : [0, 0, e]) } } be.empty = new be([]); class ar { constructor(e, t, r = 0, i = e ? e.length : 0) { this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t) } get maps() { return this._maps } slice(e = 0, t = this.maps.length) { return new ar(this._maps, this.mirror, e, t) } appendMap(e, t) { this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t) } appendMapping(e) { for (let t = 0, r = this._maps.length; t < e._maps.length; t++) { let i = e.getMirror(t); this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0) } } getMirror(e) { if (this.mirror) { for (let t = 0; t < this.mirror.length; t++)if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)] } } setMirror(e, t) { this.mirror || (this.mirror = []), this.mirror.push(e, t) } appendMappingInverted(e) { for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) { let i = e.getMirror(t); this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0) } } invert() { let e = new ar; return e.appendMappingInverted(this), e } map(e, t = 1) { if (this.mirror) return this._map(e, t, !0); for (let r = this.from; r < this.to; r++)e = this._maps[r].map(e, t); return e } mapResult(e, t = 1) { return this._map(e, t, !1) } _map(e, t, r) { let i = 0; for (let s = this.from; s < this.to; s++) { let o = this._maps[s], l = o.mapResult(e, t); if (l.recover != null) { let a = this.getMirror(s); if (a != null && a > s && a < this.to) { s = a, e = this._maps[a].recover(l.recover); continue } } i |= l.delInfo, e = l.pos } return r ? e : new Co(e, i, null) } } const Rs = Object.create(null); class ae { getMap() { return be.empty } merge(e) { return null } static fromJSON(e, t) { if (!t || !t.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let r = Rs[t.stepType]; if (!r) throw new RangeError(`No step type ${t.stepType} defined`); return r.fromJSON(e, t) } static jsonID(e, t) { if (e in Rs) throw new RangeError("Duplicate use of step JSON ID " + e); return Rs[e] = t, t.prototype.jsonID = e, t } } class W { constructor(e, t) { this.doc = e, this.failed = t } static ok(e) { return new W(e, null) } static fail(e) { return new W(null, e) } static fromReplace(e, t, r, i) { try { return W.ok(e.replace(t, r, i)) } catch (s) { if (s instanceof oi) return W.fail(s.message); throw s } } } function Sl(n, e, t) { let r = []; for (let i = 0; i < n.childCount; i++) { let s = n.child(i); s.content.size && (s = s.copy(Sl(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s) } return x.fromArray(r) } class ft extends ae { constructor(e, t, r) { super(), this.from = e, this.to = t, this.mark = r } apply(e) { let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new E(Sl(t.content, (o, l) => !o.isAtom || !l.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd); return W.fromReplace(e, this.from, this.to, s) } invert() { return new ze(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return t.deleted && r.deleted || t.pos >= r.pos ? null : new ft(t.pos, r.pos, this.mark) } merge(e) { return e instanceof ft && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ft(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new ft(t.from, t.to, e.markFromJSON(t.mark)) } } ae.jsonID("addMark", ft); class ze extends ae { constructor(e, t, r) { super(), this.from = e, this.to = t, this.mark = r } apply(e) { let t = e.slice(this.from, this.to), r = new E(Sl(t.content, i => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd); return W.fromReplace(e, this.from, this.to, r) } invert() { return new ft(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return t.deleted && r.deleted || t.pos >= r.pos ? null : new ze(t.pos, r.pos, this.mark) } merge(e) { return e instanceof ze && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ze(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new ze(t.from, t.to, e.markFromJSON(t.mark)) } } ae.jsonID("removeMark", ze); class dt extends ae { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return W.fail("No node at mark step's position"); let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks)); return W.fromReplace(e, this.pos, this.pos + 1, new E(x.from(r), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); if (t) { let r = this.mark.addToSet(t.marks); if (r.length == t.marks.length) { for (let i = 0; i < t.marks.length; i++)if (!t.marks[i].isInSet(r)) return new dt(this.pos, t.marks[i]); return new dt(this.pos, this.mark) } } return new Zt(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new dt(t.pos, this.mark) } toJSON() { return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON"); return new dt(t.pos, e.markFromJSON(t.mark)) } } ae.jsonID("addNodeMark", dt); class Zt extends ae { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return W.fail("No node at mark step's position"); let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks)); return W.fromReplace(e, this.pos, this.pos + 1, new E(x.from(r), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); return !t || !this.mark.isInSet(t.marks) ? this : new dt(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Zt(t.pos, this.mark) } toJSON() { return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON"); return new Zt(t.pos, e.markFromJSON(t.mark)) } } ae.jsonID("removeNodeMark", Zt); class q extends ae { constructor(e, t, r, i = !1) { super(), this.from = e, this.to = t, this.slice = r, this.structure = i } apply(e) { return this.structure && Oo(e, this.from, this.to) ? W.fail("Structure replace would overwrite content") : W.fromReplace(e, this.from, this.to, this.slice) } getMap() { return new be([this.from, this.to - this.from, this.slice.size]) } invert(e) { return new q(this.from, this.from + this.slice.size, e.slice(this.from, this.to)) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return t.deletedAcross && r.deletedAcross ? null : new q(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure) } merge(e) { if (!(e instanceof q) || e.structure || this.structure) return null; if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) { let t = this.slice.size + e.slice.size == 0 ? E.empty : new E(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd); return new q(this.from, this.to + (e.to - e.from), t, this.structure) } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) { let t = this.slice.size + e.slice.size == 0 ? E.empty : new E(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd); return new q(e.from, this.to, t, this.structure) } else return null } toJSON() { let e = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new q(t.from, t.to, E.fromJSON(e, t.slice), !!t.structure) } } ae.jsonID("replace", q); class G extends ae { constructor(e, t, r, i, s, o, l = !1) { super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = l } apply(e) { if (this.structure && (Oo(e, this.from, this.gapFrom) || Oo(e, this.gapTo, this.to))) return W.fail("Structure gap-replace would overwrite content"); let t = e.slice(this.gapFrom, this.gapTo); if (t.openStart || t.openEnd) return W.fail("Gap is not a flat range"); let r = this.slice.insertAt(this.insert, t.content); return r ? W.fromReplace(e, this.from, this.to, r) : W.fail("Content does not fit in gap") } getMap() { return new be([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(e) { let t = this.gapTo - this.gapFrom; return new G(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1); return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new G(t.pos, r.pos, i, s, this.slice, this.insert, this.structure) } toJSON() { let e = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new G(t.from, t.to, t.gapFrom, t.gapTo, E.fromJSON(e, t.slice), t.insert, !!t.structure) } } ae.jsonID("replaceAround", G); function Oo(n, e, t) { let r = n.resolve(e), i = t - e, s = r.depth; for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount;)s--, i--; if (i > 0) { let o = r.node(s).maybeChild(r.indexAfter(s)); for (; i > 0;) { if (!o || o.isLeaf) return !0; o = o.firstChild, i-- } } return !1 } function nb(n, e, t, r) { let i = [], s = [], o, l; n.doc.nodesBetween(e, t, (a, c, u) => { if (!a.isInline) return; let f = a.marks; if (!r.isInSet(f) && u.type.allowsMarkType(r.type)) { let d = Math.max(c, e), p = Math.min(c + a.nodeSize, t), h = r.addToSet(f); for (let g = 0; g < f.length; g++)f[g].isInSet(h) || (o && o.to == d && o.mark.eq(f[g]) ? o.to = p : i.push(o = new ze(d, p, f[g]))); l && l.to == d ? l.to = p : s.push(l = new ft(d, p, r)) } }), i.forEach(a => n.step(a)), s.forEach(a => n.step(a)) } function rb(n, e, t, r) { let i = [], s = 0; n.doc.nodesBetween(e, t, (o, l) => { if (!o.isInline) return; s++; let a = null; if (r instanceof is) { let c = o.marks, u; for (; u = r.isInSet(c);)(a || (a = [])).push(u), c = u.removeFromSet(c) } else r ? r.isInSet(o.marks) && (a = [r]) : a = o.marks; if (a && a.length) { let c = Math.min(l + o.nodeSize, t); for (let u = 0; u < a.length; u++) { let f = a[u], d; for (let p = 0; p < i.length; p++) { let h = i[p]; h.step == s - 1 && f.eq(i[p].style) && (d = h) } d ? (d.to = c, d.step = s) : i.push({ style: f, from: Math.max(l, e), to: c, step: s }) } } }), i.forEach(o => n.step(new ze(o.from, o.to, o.style))) } function wl(n, e, t, r = t.contentMatch, i = !0) { let s = n.doc.nodeAt(e), o = [], l = e + 1; for (let a = 0; a < s.childCount; a++) { let c = s.child(a), u = l + c.nodeSize, f = r.matchType(c.type); if (!f) o.push(new q(l, u, E.empty)); else { r = f; for (let d = 0; d < c.marks.length; d++)t.allowsMarkType(c.marks[d].type) || n.step(new ze(l, u, c.marks[d])); if (i && c.isText && t.whitespace != "pre") { let d, p = /\r?\n|\r/g, h; for (; d = p.exec(c.text);)h || (h = new E(x.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new q(l + d.index, l + d.index + d[0].length, h)) } } l = u } if (!r.validEnd) { let a = r.fillBefore(x.empty, !0); n.replace(l, l, new E(a, 0, 0)) } for (let a = o.length - 1; a >= 0; a--)n.step(o[a]) } function ib(n, e, t) { return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t)) } function _n(n) { let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex); for (let r = n.depth, i = 0, s = 0; ; --r) { let o = n.$from.node(r), l = n.$from.index(r) + i, a = n.$to.indexAfter(r) - s; if (r < n.depth && o.canReplace(l, a, t)) return r; if (r == 0 || o.type.spec.isolating || !ib(o, l, a)) break; l && (i = 1), a < o.childCount && (s = 1) } return null } function sb(n, e, t) { let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), l = i.after(s + 1), a = o, c = l, u = x.empty, f = 0; for (let h = s, g = !1; h > t; h--)g || r.index(h) > 0 ? (g = !0, u = x.from(r.node(h).copy(u)), f++) : a--; let d = x.empty, p = 0; for (let h = s, g = !1; h > t; h--)g || i.after(h + 1) < i.end(h) ? (g = !0, d = x.from(i.node(h).copy(d)), p++) : c++; n.step(new G(a, c, o, l, new E(u.append(d), f, p), u.size - f, !0)) } function kl(n, e, t = null, r = n) { let i = ob(n, e), s = i && lb(r, e); return s ? i.map(Ua).concat({ type: e, attrs: t }).concat(s.map(Ua)) : null } function Ua(n) { return { type: n, attrs: null } } function ob(n, e) { let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e); if (!s) return null; let o = s.length ? s[0] : e; return t.canReplaceWith(r, i, o) ? s : null } function lb(n, e) { let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type); if (!o) return null; let a = (o.length ? o[o.length - 1] : e).contentMatch; for (let c = r; a && c < i; c++)a = a.matchType(t.child(c).type); return !a || !a.validEnd ? null : o } function ab(n, e, t) { let r = x.empty; for (let o = t.length - 1; o >= 0; o--) { if (r.size) { let l = t[o].type.contentMatch.matchFragment(r); if (!l || !l.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } r = x.from(t[o].type.create(t[o].attrs, r)) } let i = e.start, s = e.end; n.step(new G(i, s, i, s, new E(r, 0, 0), t.length, !0)) } function cb(n, e, t, r, i) { if (!r.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let s = n.steps.length; n.doc.nodesBetween(e, t, (o, l) => { let a = typeof i == "function" ? i(o) : i; if (o.isTextblock && !o.hasMarkup(r, a) && ub(n.doc, n.mapping.slice(s).map(l), r)) { let c = null; if (r.schema.linebreakReplacement) { let p = r.whitespace == "pre", h = !!r.contentMatch.matchType(r.schema.linebreakReplacement); p && !h ? c = !1 : !p && h && (c = !0) } c === !1 && id(n, o, l, s), wl(n, n.mapping.slice(s).map(l, 1), r, void 0, c === null); let u = n.mapping.slice(s), f = u.map(l, 1), d = u.map(l + o.nodeSize, 1); return n.step(new G(f, d, f + 1, d - 1, new E(x.from(r.create(a, null, o.marks)), 0, 0), 1, !0)), c === !0 && rd(n, o, l, s), !1 } }) } function rd(n, e, t, r) { e.forEach((i, s) => { if (i.isText) { let o, l = /\r?\n|\r/g; for (; o = l.exec(i.text);) { let a = n.mapping.slice(r).map(t + 1 + s + o.index); n.replaceWith(a, a + 1, e.type.schema.linebreakReplacement.create()) } } }) } function id(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + s); n.replaceWith(o, o + 1, e.type.schema.text(`
`))
    }
  })
} function ub(n, e, t) { let r = n.resolve(e), i = r.index(); return r.parent.canReplaceWith(i, i + 1, t) } function fb(n, e, t, r, i) { let s = n.doc.nodeAt(e); if (!s) throw new RangeError("No node at given position"); t || (t = s.type); let o = t.create(r, null, i || s.marks); if (s.isLeaf) return n.replaceWith(e, e + s.nodeSize, o); if (!t.validContent(s.content)) throw new RangeError("Invalid content for node type " + t.name); n.step(new G(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new E(x.from(o), 0, 0), 1, !0)) } function Je(n, e, t = 1, r) { let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent; if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))) return !1; for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) { let f = i.node(c), d = i.index(c); if (f.type.spec.isolating) return !1; let p = f.content.cutByIndex(d, f.childCount), h = r && r[u + 1]; h && (p = p.replaceChild(0, h.type.create(h.attrs))); let g = r && r[u] || f; if (!f.canReplace(d + 1, f.childCount) || !g.type.validContent(p)) return !1 } let l = i.indexAfter(s), a = r && r[0]; return i.node(s).canReplaceWith(l, l, a ? a.type : i.node(s + 1).type) } function db(n, e, t = 1, r) { let i = n.doc.resolve(e), s = x.empty, o = x.empty; for (let l = i.depth, a = i.depth - t, c = t - 1; l > a; l--, c--) { s = x.from(i.node(l).copy(s)); let u = r && r[c]; o = x.from(u ? u.type.create(u.attrs, o) : i.node(l).copy(o)) } n.step(new q(e, e, new E(s.append(o), t, t), !0)) } function Et(n, e) { let t = n.resolve(e), r = t.index(); return sd(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1) } function hb(n, e) { e.content.size || n.type.compatibleContent(e.type); let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema; for (let i = 0; i < e.childCount; i++) { let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type; if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks)) return !1 } return t.validEnd } function sd(n, e) { return !!(n && e && !n.isLeaf && hb(n, e)) } function ss(n, e, t = -1) { let r = n.resolve(e); for (let i = r.depth; ; i--) { let s, o, l = r.index(i); if (i == r.depth ? (s = r.nodeBefore, o = r.nodeAfter) : t > 0 ? (s = r.node(i + 1), l++, o = r.node(i).maybeChild(l)) : (s = r.node(i).maybeChild(l - 1), o = r.node(i + 1)), s && !s.isTextblock && sd(s, o) && r.node(i).canReplace(l, l + 1)) return e; if (i == 0) break; e = t < 0 ? r.before(i) : r.after(i) } } function pb(n, e, t) { let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type; if (i && o.inlineContent) { let u = o.whitespace == "pre", f = !!o.contentMatch.matchType(i); u && !f ? r = !1 : !u && f && (r = !0) } let l = n.steps.length; if (r === !1) { let u = n.doc.resolve(e + t); id(n, u.node(), u.before(), l) } o.inlineContent && wl(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null); let a = n.mapping.slice(l), c = a.map(e - t); if (n.step(new q(c, a.map(e + t, -1), E.empty, !0)), r === !0) { let u = n.doc.resolve(c); rd(n, u.node(), u.before(), n.steps.length) } return n } function mb(n, e, t) { let r = n.resolve(e); if (r.parent.canReplaceWith(r.index(), r.index(), t)) return e; if (r.parentOffset == 0) for (let i = r.depth - 1; i >= 0; i--) { let s = r.index(i); if (r.node(i).canReplaceWith(s, s, t)) return r.before(i + 1); if (s > 0) return null } if (r.parentOffset == r.parent.content.size) for (let i = r.depth - 1; i >= 0; i--) { let s = r.indexAfter(i); if (r.node(i).canReplaceWith(s, s, t)) return r.after(i + 1); if (s < r.node(i).childCount) return null } return null } function od(n, e, t) { let r = n.resolve(e); if (!t.content.size) return e; let i = t.content; for (let s = 0; s < t.openStart; s++)i = i.firstChild.content; for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)for (let o = r.depth; o >= 0; o--) { let l = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, a = r.index(o) + (l > 0 ? 1 : 0), c = r.node(o), u = !1; if (s == 1) u = c.canReplace(a, a, i); else { let f = c.contentMatchAt(a).findWrapping(i.firstChild.type); u = f && c.canReplaceWith(a, a, f[0]) } if (u) return l == 0 ? r.pos : l < 0 ? r.before(o + 1) : r.after(o + 1) } return null } function ls(n, e, t = e, r = E.empty) { if (e == t && !r.size) return null; let i = n.resolve(e), s = n.resolve(t); return ld(i, s, r) ? new q(e, t, r) : new gb(i, s, r).fit() } function ld(n, e, t) { return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content) } class gb { constructor(e, t, r) { this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = x.empty; for (let i = 0; i <= e.depth; i++) { let s = e.node(i); this.frontier.push({ type: s.type, match: s.contentMatchAt(e.indexAfter(i)) }) } for (let i = e.depth; i > 0; i--)this.placed = x.from(e.node(i).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let c = this.findFittable(); c ? this.placeNodes(c) : this.openMore() || this.dropNode() } let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e)); if (!i) return null; let s = this.placed, o = r.depth, l = i.depth; for (; o && l && s.childCount == 1;)s = s.firstChild.content, o--, l--; let a = new E(s, o, l); return e > -1 ? new G(r.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || r.pos != this.$to.pos ? new q(r.pos, i.pos, a) : null } findFittable() { let e = this.unplaced.openStart; for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) { let s = t.firstChild; if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) { e = r; break } t = s.content } for (let t = 1; t <= 2; t++)for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) { let i, s = null; r ? (s = vs(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content; let o = i.firstChild; for (let l = this.depth; l >= 0; l--) { let { type: a, match: c } = this.frontier[l], u, f = null; if (t == 1 && (o ? c.matchType(o.type) || (f = c.fillBefore(x.from(o), !1)) : s && a.compatibleContent(s.type))) return { sliceDepth: r, frontierDepth: l, parent: s, inject: f }; if (t == 2 && o && (u = c.findWrapping(o.type))) return { sliceDepth: r, frontierDepth: l, parent: s, wrap: u }; if (s && c.matchType(s.type)) break } } } openMore() { let { content: e, openStart: t, openEnd: r } = this.unplaced, i = vs(e, t); return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new E(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0) } dropNode() { let { content: e, openStart: t, openEnd: r } = this.unplaced, i = vs(e, t); if (i.childCount <= 1 && t > 0) { let s = e.size - t <= t + i.size; this.unplaced = new E(Hn(e, t - 1, 1), t - 1, s ? t - 1 : r) } else this.unplaced = new E(Hn(e, t, 1), t, r) } placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) { for (; this.depth > t;)this.closeFrontierNode(); if (s) for (let g = 0; g < s.length; g++)this.openFrontierNode(s[g]); let o = this.unplaced, l = r ? r.content : o.content, a = o.openStart - e, c = 0, u = [], { match: f, type: d } = this.frontier[t]; if (i) { for (let g = 0; g < i.childCount; g++)u.push(i.child(g)); f = f.matchFragment(i) } let p = l.size + e - (o.content.size - o.openEnd); for (; c < l.childCount;) { let g = l.child(c), m = f.matchType(g.type); if (!m) break; c++, (c > 1 || a == 0 || g.content.size) && (f = m, u.push(ad(g.mark(d.allowedMarks(g.marks)), c == 1 ? a : 0, c == l.childCount ? p : -1))) } let h = c == l.childCount; h || (p = -1), this.placed = jn(this.placed, t, x.from(u)), this.frontier[t].match = f, h && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let g = 0, m = l; g < p; g++) { let y = m.lastChild; this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), m = y.content } this.unplaced = h ? e == 0 ? E.empty : new E(Hn(o.content, e - 1, 1), e - 1, p < 0 ? o.openEnd : e - 1) : new E(Hn(o.content, e, c), o.openStart, o.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let e = this.frontier[this.depth], t; if (!e.type.isTextblock || !_s(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth) return -1; let { depth: r } = this.$to, i = this.$to.after(r); for (; r > 1 && i == this.$to.end(--r);)++i; return i } findCloseLevel(e) { e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) { let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = _s(e, t, i, r, s); if (o) { for (let l = t - 1; l >= 0; l--) { let { match: a, type: c } = this.frontier[l], u = _s(e, l, c, a, !0); if (!u || u.childCount) continue e } return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e } } } } close(e) { let t = this.findCloseLevel(e); if (!t) return null; for (; this.depth > t.depth;)this.closeFrontierNode(); t.fit.childCount && (this.placed = jn(this.placed, t.depth, t.fit)), e = t.move; for (let r = t.depth + 1; r <= e.depth; r++) { let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r)); this.openFrontierNode(i.type, i.attrs, s) } return e } openFrontierNode(e, t = null, r) { let i = this.frontier[this.depth]; i.match = i.match.matchType(e), this.placed = jn(this.placed, this.depth, x.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch }) } closeFrontierNode() { let t = this.frontier.pop().match.fillBefore(x.empty, !0); t.childCount && (this.placed = jn(this.placed, this.frontier.length, t)) } } function Hn(n, e, t) { return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(Hn(n.firstChild.content, e - 1, t))) } function jn(n, e, t) { return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(jn(n.lastChild.content, e - 1, t))) } function vs(n, e) { for (let t = 0; t < e; t++)n = n.firstChild.content; return n } function ad(n, e, t) { if (e <= 0) return n; let r = n.content; return e > 1 && (r = r.replaceChild(0, ad(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(x.empty, !0)))), n.copy(r) } function _s(n, e, t, r, i) { let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e); if (o == s.childCount && !t.compatibleContent(s.type)) return null; let l = r.fillBefore(s.content, !0, o); return l && !yb(t, s.content, o) ? l : null } function yb(n, e, t) { for (let r = t; r < e.childCount; r++)if (!n.allowsMarks(e.child(r).marks)) return !0; return !1 } function bb(n) { return n.spec.defining || n.spec.definingForContent } function xb(n, e, t, r) { if (!r.size) return n.deleteRange(e, t); let i = n.doc.resolve(e), s = n.doc.resolve(t); if (ld(i, s, r)) return n.step(new q(e, t, r)); let o = ud(i, s); o[o.length - 1] == 0 && o.pop(); let l = -(i.depth + 1); o.unshift(l); for (let d = i.depth, p = i.pos - 1; d > 0; d--, p--) { let h = i.node(d).type.spec; if (h.defining || h.definingAsContext || h.isolating) break; o.indexOf(d) > -1 ? l = d : i.before(d) == p && o.splice(1, 0, -d) } let a = o.indexOf(l), c = [], u = r.openStart; for (let d = r.content, p = 0; ; p++) { let h = d.firstChild; if (c.push(h), p == r.openStart) break; d = h.content } for (let d = u - 1; d >= 0; d--) { let p = c[d], h = bb(p.type); if (h && !p.sameMarkup(i.node(Math.abs(l) - 1))) u = d; else if (h || !p.type.isTextblock) break } for (let d = r.openStart; d >= 0; d--) { let p = (d + u + 1) % (r.openStart + 1), h = c[p]; if (h) for (let g = 0; g < o.length; g++) { let m = o[(g + a) % o.length], y = !0; m < 0 && (y = !1, m = -m); let S = i.node(m - 1), k = i.index(m - 1); if (S.canReplaceWith(k, k, h.type, h.marks)) return n.replace(i.before(m), y ? s.after(m) : t, new E(cd(r.content, 0, r.openStart, p), p, r.openEnd)) } } let f = n.steps.length; for (let d = o.length - 1; d >= 0 && (n.replace(e, t, r), !(n.steps.length > f)); d--) { let p = o[d]; p < 0 || (e = i.before(p), t = s.after(p)) } } function cd(n, e, t, r, i) { if (e < t) { let s = n.firstChild; n = n.replaceChild(0, s.copy(cd(s.content, e + 1, t, r, s))) } if (e > r) { let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n); n = o.append(s.matchFragment(o).fillBefore(x.empty, !0)) } return n } function Sb(n, e, t, r) { if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) { let i = mb(n.doc, e, r.type); i != null && (e = t = i) } n.replaceRange(e, t, new E(x.from(r), 0, 0)) } function wb(n, e, t) { let r = n.doc.resolve(e), i = n.doc.resolve(t), s = ud(r, i); for (let o = 0; o < s.length; o++) { let l = s[o], a = o == s.length - 1; if (a && l == 0 || r.node(l).type.contentMatch.validEnd) return n.delete(r.start(l), i.end(l)); if (l > 0 && (a || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1)))) return n.delete(r.before(l), i.after(l)) } for (let o = 1; o <= r.depth && o <= i.depth; o++)if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1))) return n.delete(r.before(o), t); n.delete(e, t) } function ud(n, e) { let t = [], r = Math.min(n.depth, e.depth); for (let i = r; i >= 0; i--) { let s = n.start(i); if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating) break; (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i) } return t } class yn extends ae { constructor(e, t, r) { super(), this.pos = e, this.attr = t, this.value = r } apply(e) { let t = e.nodeAt(this.pos); if (!t) return W.fail("No node at attribute step's position"); let r = Object.create(null); for (let s in t.attrs) r[s] = t.attrs[s]; r[this.attr] = this.value; let i = t.type.create(r, null, t.marks); return W.fromReplace(e, this.pos, this.pos + 1, new E(x.from(i), 0, t.isLeaf ? 0 : 1)) } getMap() { return be.empty } invert(e) { return new yn(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new yn(t.pos, this.attr, this.value) } toJSON() { return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value } } static fromJSON(e, t) { if (typeof t.pos != "number" || typeof t.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON"); return new yn(t.pos, t.attr, t.value) } } ae.jsonID("attr", yn); class cr extends ae { constructor(e, t) { super(), this.attr = e, this.value = t } apply(e) { let t = Object.create(null); for (let i in e.attrs) t[i] = e.attrs[i]; t[this.attr] = this.value; let r = e.type.create(t, e.content, e.marks); return W.ok(r) } getMap() { return be.empty } invert(e) { return new cr(this.attr, e.attrs[this.attr]) } map(e) { return this } toJSON() { return { stepType: "docAttr", attr: this.attr, value: this.value } } static fromJSON(e, t) { if (typeof t.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON"); return new cr(t.attr, t.value) } } ae.jsonID("docAttr", cr); let wn = class extends Error { }; wn = function n(e) { let t = Error.call(this, e); return t.__proto__ = n.prototype, t }; wn.prototype = Object.create(Error.prototype); wn.prototype.constructor = wn; wn.prototype.name = "TransformError"; class fd { constructor(e) { this.doc = e, this.steps = [], this.docs = [], this.mapping = new ar } get before() { return this.docs.length ? this.docs[0] : this.doc } step(e) { let t = this.maybeStep(e); if (t.failed) throw new wn(t.failed); return this } maybeStep(e) { let t = e.apply(this.doc); return t.failed || this.addStep(e, t.doc), t } get docChanged() { return this.steps.length > 0 } changedRange() { let e = 1e9, t = -1e9; for (let r = 0; r < this.mapping.maps.length; r++) { let i = this.mapping.maps[r]; r && (e = i.map(e, 1), t = i.map(t, -1)), i.forEach((s, o, l, a) => { e = Math.min(e, l), t = Math.max(t, a) }) } return e == 1e9 ? null : { from: e, to: t } } addStep(e, t) { this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t } replace(e, t = e, r = E.empty) { let i = ls(this.doc, e, t, r); return i && this.step(i), this } replaceWith(e, t, r) { return this.replace(e, t, new E(x.from(r), 0, 0)) } delete(e, t) { return this.replace(e, t, E.empty) } insert(e, t) { return this.replaceWith(e, e, t) } replaceRange(e, t, r) { return xb(this, e, t, r), this } replaceRangeWith(e, t, r) { return Sb(this, e, t, r), this } deleteRange(e, t) { return wb(this, e, t), this } lift(e, t) { return sb(this, e, t), this } join(e, t = 1) { return pb(this, e, t), this } wrap(e, t) { return ab(this, e, t), this } setBlockType(e, t = e, r, i = null) { return cb(this, e, t, r, i), this } setNodeMarkup(e, t, r = null, i) { return fb(this, e, t, r, i), this } setNodeAttribute(e, t, r) { return this.step(new yn(e, t, r)), this } setDocAttribute(e, t) { return this.step(new cr(e, t)), this } addNodeMark(e, t) { return this.step(new dt(e, t)), this } removeNodeMark(e, t) { let r = this.doc.nodeAt(e); if (!r) throw new RangeError("No node at position " + e); if (t instanceof L) t.isInSet(r.marks) && this.step(new Zt(e, t)); else { let i = r.marks, s, o = []; for (; s = t.isInSet(i);)o.push(new Zt(e, s)), i = s.removeFromSet(i); for (let l = o.length - 1; l >= 0; l--)this.step(o[l]) } return this } split(e, t = 1, r) { return db(this, e, t, r), this } addMark(e, t, r) { return nb(this, e, t, r), this } removeMark(e, t, r) { return rb(this, e, t, r), this } clearIncompatible(e, t, r) { return wl(this, e, t, r), this } } const Ds = Object.create(null); class _ { constructor(e, t, r) { this.$anchor = e, this.$head = t, this.ranges = r || [new kb(e.min(t), e.max(t))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let e = this.ranges; for (let t = 0; t < e.length; t++)if (e[t].$from.pos != e[t].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(e, t = E.empty) { let r = t.content.lastChild, i = null; for (let l = 0; l < t.openEnd; l++)i = r, r = r.lastChild; let s = e.steps.length, o = this.ranges; for (let l = 0; l < o.length; l++) { let { $from: a, $to: c } = o[l], u = e.mapping.slice(s); e.replaceRange(u.map(a.pos), u.map(c.pos), l ? E.empty : t), l == 0 && qa(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1) } } replaceWith(e, t) { let r = e.steps.length, i = this.ranges; for (let s = 0; s < i.length; s++) { let { $from: o, $to: l } = i[s], a = e.mapping.slice(r), c = a.map(o.pos), u = a.map(l.pos); s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), qa(e, r, t.isInline ? -1 : 1)) } } static findFrom(e, t, r = !1) { let i = e.parent.inlineContent ? new R(e) : fn(e.node(0), e.parent, e.pos, e.index(), t, r); if (i) return i; for (let s = e.depth - 1; s >= 0; s--) { let o = t < 0 ? fn(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : fn(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r); if (o) return o } return null } static near(e, t = 1) { return this.findFrom(e, t) || this.findFrom(e, -t) || new Se(e.node(0)) } static atStart(e) { return fn(e, e, 0, 0, 1) || new Se(e) } static atEnd(e) { return fn(e, e, e.content.size, e.childCount, -1) || new Se(e) } static fromJSON(e, t) { if (!t || !t.type) throw new RangeError("Invalid input for Selection.fromJSON"); let r = Ds[t.type]; if (!r) throw new RangeError(`No selection type ${t.type} defined`); return r.fromJSON(e, t) } static jsonID(e, t) { if (e in Ds) throw new RangeError("Duplicate use of selection JSON ID " + e); return Ds[e] = t, t.prototype.jsonID = e, t } getBookmark() { return R.between(this.$anchor, this.$head).getBookmark() } } _.prototype.visible = !0; class kb { constructor(e, t) { this.$from = e, this.$to = t } } let Wa = !1; function Ka(n) { !Wa && !n.parent.inlineContent && (Wa = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")")) } class R extends _ { constructor(e, t = e) { Ka(e), Ka(t), super(e, t) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(e, t) { let r = e.resolve(t.map(this.head)); if (!r.parent.inlineContent) return _.near(r); let i = e.resolve(t.map(this.anchor)); return new R(i.parent.inlineContent ? i : r, r) } replace(e, t = E.empty) { if (super.replace(e, t), t == E.empty) { let r = this.$from.marksAcross(this.$to); r && e.ensureMarks(r) } } eq(e) { return e instanceof R && e.anchor == this.anchor && e.head == this.head } getBookmark() { return new as(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(e, t) { if (typeof t.anchor != "number" || typeof t.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON"); return new R(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, r = t) { let i = e.resolve(t); return new this(i, r == t ? i : e.resolve(r)) } static between(e, t, r) { let i = e.pos - t.pos; if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) { let s = _.findFrom(t, r, !0) || _.findFrom(t, -r, !0); if (s) t = s.$head; else return _.near(t, r) } return e.parent.inlineContent || (i == 0 ? e = t : (e = (_.findFrom(e, -r, !0) || _.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new R(e, t) } } _.jsonID("text", R); class as { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new as(e.map(this.anchor), e.map(this.head)) } resolve(e) { return R.between(e.resolve(this.anchor), e.resolve(this.head)) } } class A extends _ { constructor(e) { let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize); super(e, r), this.node = t } map(e, t) { let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i); return r ? _.near(s) : new A(s) } content() { return new E(x.from(this.node), 0, 0) } eq(e) { return e instanceof A && e.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new El(this.anchor) } static fromJSON(e, t) { if (typeof t.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new A(e.resolve(t.anchor)) } static create(e, t) { return new A(e.resolve(t)) } static isSelectable(e) { return !e.isText && e.type.spec.selectable !== !1 } } A.prototype.visible = !1; _.jsonID("node", A); class El { constructor(e) { this.anchor = e } map(e) { let { deleted: t, pos: r } = e.mapResult(this.anchor); return t ? new as(r, r) : new El(r) } resolve(e) { let t = e.resolve(this.anchor), r = t.nodeAfter; return r && A.isSelectable(r) ? new A(t) : _.near(t) } } class Se extends _ { constructor(e) { super(e.resolve(0), e.resolve(e.content.size)) } replace(e, t = E.empty) { if (t == E.empty) { e.delete(0, e.doc.content.size); let r = _.atStart(e.doc); r.eq(e.selection) || e.setSelection(r) } else super.replace(e, t) } toJSON() { return { type: "all" } } static fromJSON(e) { return new Se(e) } map(e) { return new Se(e) } eq(e) { return e instanceof Se } getBookmark() { return Eb } } _.jsonID("all", Se); const Eb = { map() { return this }, resolve(n) { return new Se(n) } }; function fn(n, e, t, r, i, s = !1) { if (e.inlineContent) return R.create(n, t); for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) { let l = e.child(o); if (l.isAtom) { if (!s && A.isSelectable(l)) return A.create(n, t - (i < 0 ? l.nodeSize : 0)) } else { let a = fn(n, l, t + i, i < 0 ? l.childCount : 0, i, s); if (a) return a } t += l.nodeSize * i } return null } function qa(n, e, t) { let r = n.steps.length - 1; if (r < e) return; let i = n.steps[r]; if (!(i instanceof q || i instanceof G)) return; let s = n.mapping.maps[r], o; s.forEach((l, a, c, u) => { o == null && (o = u) }), n.setSelection(_.near(n.doc.resolve(o), t)) } const Ja = 1, Br = 2, Ga = 4; class Cb extends fd { constructor(e) { super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(e) { if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Ja) & ~Br, this.storedMarks = null, this } get selectionSet() { return (this.updated & Ja) > 0 } setStoredMarks(e) { return this.storedMarks = e, this.updated |= Br, this } ensureMarks(e) { return L.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this } addStoredMark(e) { return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(e) { return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (this.updated & Br) > 0 } addStep(e, t) { super.addStep(e, t), this.updated = this.updated & ~Br, this.storedMarks = null } setTime(e) { return this.time = e, this } replaceSelection(e) { return this.selection.replace(this, e), this } replaceSelectionWith(e, t = !0) { let r = this.selection; return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || L.none))), r.replaceWith(this, e), this } deleteSelection() { return this.selection.replace(this), this } insertText(e, t, r) { let i = this.doc.type.schema; if (t == null) return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection(); { if (r == null && (r = t), !e) return this.deleteRange(t, r); let s = this.storedMarks; if (!s) { let o = this.doc.resolve(t); s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r)) } return this.replaceRangeWith(t, r, i.text(e, s)), !this.selection.empty && this.selection.to == t + e.length && this.setSelection(_.near(this.selection.$to)), this } } setMeta(e, t) { return this.meta[typeof e == "string" ? e : e.key] = t, this } getMeta(e) { return this.meta[typeof e == "string" ? e : e.key] } get isGeneric() { for (let e in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= Ga, this } get scrolledIntoView() { return (this.updated & Ga) > 0 } } function Ya(n, e) { return !e || !n ? n : n.bind(e) } class Vn { constructor(e, t, r) { this.name = e, this.init = Ya(t.init, r), this.apply = Ya(t.apply, r) } } const Ob = [new Vn("doc", { init(n) { return n.doc || n.schema.topNodeType.createAndFill() }, apply(n) { return n.doc } }), new Vn("selection", { init(n, e) { return n.selection || _.atStart(e.doc) }, apply(n) { return n.selection } }), new Vn("storedMarks", { init(n) { return n.storedMarks || null }, apply(n, e, t, r) { return r.selection.$cursor ? n.storedMarks : null } }), new Vn("scrollToSelection", { init() { return 0 }, apply(n, e) { return n.scrolledIntoView ? e + 1 : e } })]; class Is { constructor(e, t) { this.schema = e, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = Ob.slice(), t && t.forEach(r => { if (this.pluginsByKey[r.key]) throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")"); this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Vn(r.key, r.spec.state, r)) }) } } class pn { constructor(e) { this.config = e } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(e) { return this.applyTransaction(e).state } filterTransaction(e, t = -1) { for (let r = 0; r < this.config.plugins.length; r++)if (r != t) { let i = this.config.plugins[r]; if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return !1 } return !0 } applyTransaction(e) { if (!this.filterTransaction(e)) return { state: this, transactions: [] }; let t = [e], r = this.applyInner(e), i = null; for (; ;) { let s = !1; for (let o = 0; o < this.config.plugins.length; o++) { let l = this.config.plugins[o]; if (l.spec.appendTransaction) { let a = i ? i[o].n : 0, c = i ? i[o].state : this, u = a < t.length && l.spec.appendTransaction.call(l, a ? t.slice(a) : t, c, r); if (u && r.filterTransaction(u, o)) { if (u.setMeta("appendedTransaction", e), !i) { i = []; for (let f = 0; f < this.config.plugins.length; f++)i.push(f < o ? { state: r, n: t.length } : { state: this, n: 0 }) } t.push(u), r = r.applyInner(u), s = !0 } i && (i[o] = { state: r, n: t.length }) } } if (!s) return { state: r, transactions: t } } } applyInner(e) { if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let t = new pn(this.config), r = this.config.fields; for (let i = 0; i < r.length; i++) { let s = r[i]; t[s.name] = s.apply(e, this[s.name], this, t) } return t } get tr() { return new Cb(this) } static create(e) { let t = new Is(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new pn(t); for (let i = 0; i < t.fields.length; i++)r[t.fields[i].name] = t.fields[i].init(e, r); return r } reconfigure(e) { let t = new Is(this.schema, e.plugins), r = t.fields, i = new pn(t); for (let s = 0; s < r.length; s++) { let o = r[s].name; i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i) } return i } toJSON(e) { let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (t.storedMarks = this.storedMarks.map(r => r.toJSON())), e && typeof e == "object") for (let r in e) { if (r == "doc" || r == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let i = e[r], s = i.spec.state; s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key])) } return t } static fromJSON(e, t, r) { if (!t) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!e.schema) throw new RangeError("Required config field 'schema' missing"); let i = new Is(e.schema, e.plugins), s = new pn(i); return i.fields.forEach(o => { if (o.name == "doc") s.doc = pt.fromJSON(e.schema, t.doc); else if (o.name == "selection") s.selection = _.fromJSON(s.doc, t.selection); else if (o.name == "storedMarks") t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON)); else { if (r) for (let l in r) { let a = r[l], c = a.spec.state; if (a.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) { s[o.name] = c.fromJSON.call(a, e, t[l], s); return } } s[o.name] = o.init(e, s) } }), s } } function dd(n, e, t) { for (let r in n) { let i = n[r]; i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = dd(i, e, {})), t[r] = i } return t } class Q { constructor(e) { this.spec = e, this.props = {}, e.props && dd(e.props, this, this.props), this.key = e.key ? e.key.key : hd("plugin") } getState(e) { return e[this.key] } } const Ps = Object.create(null); function hd(n) { return n in Ps ? n + "$" + ++Ps[n] : (Ps[n] = 0, n + "$") } class ye { constructor(e = "key") { this.key = hd(e) } get(e) { return e.config.pluginsByKey[this.key] } getState(e) { return e[this.key] } } const te = function (n) { for (var e = 0; ; e++)if (n = n.previousSibling, !n) return e }, kn = function (n) { let e = n.assignedSlot || n.parentNode; return e && e.nodeType == 11 ? e.host : e }; let To = null; const Ke = function (n, e, t) { let r = To || (To = document.createRange()); return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r }, Tb = function () { To = null }, en = function (n, e, t, r) { return t && (Xa(n, e, t, r, -1) || Xa(n, e, t, r, 1)) }, Mb = /^(img|br|input|textarea|hr)$/i; function Xa(n, e, t, r, i) { for (var s; ;) { if (n == t && e == r) return !0; if (e == (i < 0 ? 0 : Ce(n))) { let o = n.parentNode; if (!o || o.nodeType != 1 || Cr(n) || Mb.test(n.nodeName) || n.contentEditable == "false") return !1; e = te(n) + (i < 0 ? 0 : 1), n = o } else if (n.nodeType == 1) { let o = n.childNodes[e + (i < 0 ? -1 : 0)]; if (o.nodeType == 1 && o.contentEditable == "false") if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection) e += i; else return !1; else n = o, e = i < 0 ? Ce(n) : 0 } else return !1 } } function Ce(n) { return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length } function Ab(n, e) { for (; ;) { if (n.nodeType == 3 && e) return n; if (n.nodeType == 1 && e > 0) { if (n.contentEditable == "false") return null; n = n.childNodes[e - 1], e = Ce(n) } else if (n.parentNode && !Cr(n)) e = te(n), n = n.parentNode; else return null } } function Nb(n, e) { for (; ;) { if (n.nodeType == 3 && e < n.nodeValue.length) return n; if (n.nodeType == 1 && e < n.childNodes.length) { if (n.contentEditable == "false") return null; n = n.childNodes[e], e = 0 } else if (n.parentNode && !Cr(n)) e = te(n) + 1, n = n.parentNode; else return null } } function Rb(n, e, t) { for (let r = e == 0, i = e == Ce(n); r || i;) { if (n == t) return !0; let s = te(n); if (n = n.parentNode, !n) return !1; r = r && s == 0, i = i && s == Ce(n) } } function Cr(n) { let e; for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode); return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n) } const cs = function (n) { return n.focusNode && en(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) }; function Nt(n, e) { let t = document.createEvent("Event"); return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t } function vb(n) { let e = n.activeElement; for (; e && e.shadowRoot;)e = e.shadowRoot.activeElement; return e } function _b(n, e, t) { if (n.caretPositionFromPoint) try { let r = n.caretPositionFromPoint(e, t); if (r) return { node: r.offsetNode, offset: Math.min(Ce(r.offsetNode), r.offset) } } catch { } if (n.caretRangeFromPoint) { let r = n.caretRangeFromPoint(e, t); if (r) return { node: r.startContainer, offset: Math.min(Ce(r.startContainer), r.startOffset) } } } const $e = typeof navigator < "u" ? navigator : null, Qa = typeof document < "u" ? document : null, Ct = $e && $e.userAgent || "", Mo = /Edge\/(\d+)/.exec(Ct), pd = /MSIE \d/.exec(Ct), Ao = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ct), me = !!(pd || Ao || Mo), gt = pd ? document.documentMode : Ao ? +Ao[1] : Mo ? +Mo[1] : 0, Te = !me && /gecko\/(\d+)/i.test(Ct); Te && +(/Firefox\/(\d+)/.exec(Ct) || [0, 0])[1]; const No = !me && /Chrome\/(\d+)/.exec(Ct), J = !!No, md = No ? +No[1] : 0, re = !me && !!$e && /Apple Computer/.test($e.vendor), En = re && (/Mobile\/\w+/.test(Ct) || !!$e && $e.maxTouchPoints > 2), Ee = En || ($e ? /Mac/.test($e.platform) : !1), gd = $e ? /Win/.test($e.platform) : !1, qe = /Android \d/.test(Ct), Or = !!Qa && "webkitFontSmoothing" in Qa.documentElement.style, Db = Or ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0; function Ib(n) { let e = n.defaultView && n.defaultView.visualViewport; return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: n.documentElement.clientWidth, top: 0, bottom: n.documentElement.clientHeight } } function je(n, e) { return typeof n == "number" ? n : n[e] } function Pb(n) { let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1; return { left: e.left, right: e.left + n.clientWidth * t, top: e.top, bottom: e.top + n.clientHeight * r } } function Za(n, e, t) { let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument; for (let o = t || n.dom; o;) { if (o.nodeType != 1) { o = kn(o); continue } let l = o, a = l == s.body, c = a ? Ib(s) : Pb(l), u = 0, f = 0; if (e.top < c.top + je(r, "top") ? f = -(c.top - e.top + je(i, "top")) : e.bottom > c.bottom - je(r, "bottom") && (f = e.bottom - e.top > c.bottom - c.top ? e.top + je(i, "top") - c.top : e.bottom - c.bottom + je(i, "bottom")), e.left < c.left + je(r, "left") ? u = -(c.left - e.left + je(i, "left")) : e.right > c.right - je(r, "right") && (u = e.right - c.right + je(i, "right")), u || f) if (a) s.defaultView.scrollBy(u, f); else { let p = l.scrollLeft, h = l.scrollTop; f && (l.scrollTop += f), u && (l.scrollLeft += u); let g = l.scrollLeft - p, m = l.scrollTop - h; e = { left: e.left - g, top: e.top - m, right: e.right - g, bottom: e.bottom - m } } let d = a ? "fixed" : getComputedStyle(o).position; if (/^(fixed|sticky)$/.test(d)) break; o = d == "absolute" ? o.offsetParent : kn(o) } } function Lb(n) { let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i; for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) { let l = n.root.elementFromPoint(s, o); if (!l || l == n.dom || !n.dom.contains(l)) continue; let a = l.getBoundingClientRect(); if (a.top >= t - 20) { r = l, i = a.top; break } } return { refDOM: r, refTop: i, stack: yd(n.dom) } } function yd(n) { let e = [], t = n.ownerDocument; for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = kn(r)); return e } function Bb({ refDOM: n, refTop: e, stack: t }) { let r = n ? n.getBoundingClientRect().top : 0; bd(t, r == 0 ? 0 : r - e) } function bd(n, e) { for (let t = 0; t < n.length; t++) { let { dom: r, top: i, left: s } = n[t]; r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s) } } let an = null; function Fb(n) { if (n.setActive) return n.setActive(); if (an) return n.focus(an); let e = yd(n); n.focus(an == null ? { get preventScroll() { return an = { preventScroll: !0 }, !0 } } : void 0), an || (an = !1, bd(e, 0)) } function xd(n, e) { let t, r = 2e8, i, s = 0, o = e.top, l = e.top, a, c; for (let u = n.firstChild, f = 0; u; u = u.nextSibling, f++) { let d; if (u.nodeType == 1) d = u.getClientRects(); else if (u.nodeType == 3) d = Ke(u).getClientRects(); else continue; for (let p = 0; p < d.length; p++) { let h = d[p]; if (h.top <= o && h.bottom >= l) { o = Math.max(h.bottom, o), l = Math.min(h.top, l); let g = h.left > e.left ? h.left - e.left : h.right < e.left ? e.left - h.right : 0; if (g < r) { t = u, r = g, i = g && t.nodeType == 3 ? { left: h.right < e.left ? h.right : h.left, top: e.top } : e, u.nodeType == 1 && g && (s = f + (e.left >= (h.left + h.right) / 2 ? 1 : 0)); continue } } else h.top > e.top && !a && h.left <= e.left && h.right >= e.left && (a = u, c = { left: Math.max(h.left, Math.min(h.right, e.left)), top: h.top }); !t && (e.left >= h.right && e.top >= h.top || e.left >= h.left && e.top >= h.bottom) && (s = f + 1) } } return !t && a && (t = a, i = c, r = 0), t && t.nodeType == 3 ? zb(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : xd(t, i) } function zb(n, e) { let t = n.nodeValue.length, r = document.createRange(), i; for (let s = 0; s < t; s++) { r.setEnd(n, s + 1), r.setStart(n, s); let o = st(r, 1); if (o.top != o.bottom && Cl(e, o)) { i = { node: n, offset: s + (e.left >= (o.left + o.right) / 2 ? 1 : 0) }; break } } return r.detach(), i || { node: n, offset: 0 } } function Cl(n, e) { return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1 } function $b(n, e) { let t = n.parentNode; return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n } function Hb(n, e, t) { let { node: r, offset: i } = xd(e, t), s = -1; if (r.nodeType == 1 && !r.firstChild) { let o = r.getBoundingClientRect(); s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1 } return n.docView.posFromDOM(r, i, s) } function jb(n, e, t, r) { let i = -1; for (let s = e, o = !1; s != n.dom;) { let l = n.docView.nearestDesc(s, !0), a; if (!l) return null; if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && ((a = l.dom.getBoundingClientRect()).width || a.height) && (l.node.isBlock && l.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(l.dom.nodeName) && (!o && a.left > r.left || a.top > r.top ? i = l.posBefore : (!o && a.right < r.left || a.bottom < r.top) && (i = l.posAfter), o = !0), !l.contentDOM && i < 0 && !l.node.isText)) return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2) ? l.posBefore : l.posAfter; s = l.dom.parentNode } return i > -1 ? i : n.docView.posFromDOM(e, t, -1) } function Sd(n, e, t) { let r = n.childNodes.length; if (r && t.top < t.bottom) for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ;) { let o = n.childNodes[s]; if (o.nodeType == 1) { let l = o.getClientRects(); for (let a = 0; a < l.length; a++) { let c = l[a]; if (Cl(e, c)) return Sd(o, e, c) } } if ((s = (s + 1) % r) == i) break } return n } function Vb(n, e) { let t = n.dom.ownerDocument, r, i = 0, s = _b(t, e.left, e.top); s && ({ node: r, offset: i } = s); let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), l; if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) { let c = n.dom.getBoundingClientRect(); if (!Cl(e, c) || (o = Sd(n.dom, e, c), !o)) return null } if (re) for (let c = o; r && c; c = kn(c))c.draggable && (r = void 0); if (o = $b(o, e), r) { if (Te && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) { let u = r.childNodes[i], f; u.nodeName == "IMG" && (f = u.getBoundingClientRect()).right <= e.left && f.bottom > e.top && i++ } let c; Or && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = jb(n, r, i, e)) } l == null && (l = Hb(n, o, e)); let a = n.docView.nearestDesc(o, !0); return { pos: l, inside: a ? a.posAtStart - a.border : -1 } } function ec(n) { return n.top < n.bottom || n.left < n.right } function st(n, e) { let t = n.getClientRects(); if (t.length) { let r = t[e < 0 ? 0 : t.length - 1]; if (ec(r)) return r } return Array.prototype.find.call(t, ec) || n.getBoundingClientRect() } const Ub = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function wd(n, e, t) { let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = Or || Te; if (r.nodeType == 3) if (o && (Ub.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) { let a = st(Ke(r, i, i), t); if (Te && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) { let c = st(Ke(r, i - 1, i - 1), -1); if (c.top == a.top) { let u = st(Ke(r, i, i + 1), -1); if (u.top != a.top) return Fn(u, u.left < c.left) } } return a } else { let a = i, c = i, u = t < 0 ? 1 : -1; return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (a--, u = 1) : t < 0 ? a-- : c++, Fn(st(Ke(r, a, c), u), u < 0) } if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) { if (s == null && i && (t < 0 || i == Ce(r))) { let a = r.childNodes[i - 1]; if (a.nodeType == 1) return Ls(a.getBoundingClientRect(), !1) } if (s == null && i < Ce(r)) { let a = r.childNodes[i]; if (a.nodeType == 1) return Ls(a.getBoundingClientRect(), !0) } return Ls(r.getBoundingClientRect(), t >= 0) } if (s == null && i && (t < 0 || i == Ce(r))) { let a = r.childNodes[i - 1], c = a.nodeType == 3 ? Ke(a, Ce(a) - (o ? 0 : 1)) : a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling) ? a : null; if (c) return Fn(st(c, 1), !1) } if (s == null && i < Ce(r)) { let a = r.childNodes[i]; for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords;)a = a.nextSibling; let c = a ? a.nodeType == 3 ? Ke(a, 0, o ? 0 : 1) : a.nodeType == 1 ? a : null : null; if (c) return Fn(st(c, -1), !0) } return Fn(st(r.nodeType == 3 ? Ke(r) : r, -t), t >= 0) } function Fn(n, e) { if (n.width == 0) return n; let t = e ? n.left : n.right; return { top: n.top, bottom: n.bottom, left: t, right: t } } function Ls(n, e) { if (n.height == 0) return n; let t = e ? n.top : n.bottom; return { top: t, bottom: t, left: n.left, right: n.right } } function kd(n, e, t) { let r = n.state, i = n.root.activeElement; r != e && n.updateState(e), i != n.dom && n.focus(); try { return t() } finally { r != e && n.updateState(r), i != n.dom && i && i.focus() } } function Wb(n, e, t) { let r = e.selection, i = t == "up" ? r.$from : r.$to; return kd(n, e, () => { let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1); for (; ;) { let l = n.docView.nearestDesc(s, !0); if (!l) break; if (l.node.isBlock) { s = l.contentDOM || l.dom; break } s = l.dom.parentNode } let o = wd(n, i.pos, 1); for (let l = s.firstChild; l; l = l.nextSibling) { let a; if (l.nodeType == 1) a = l.getClientRects(); else if (l.nodeType == 3) a = Ke(l, 0, l.nodeValue.length).getClientRects(); else continue; for (let c = 0; c < a.length; c++) { let u = a[c]; if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2)) return !1 } } return !0 }) } const Kb = /[\u0590-\u08ac]/; function qb(n, e, t) { let { $head: r } = e.selection; if (!r.parent.isTextblock) return !1; let i = r.parentOffset, s = !i, o = i == r.parent.content.size, l = n.domSelection(); return l ? !Kb.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? s : o : kd(n, e, () => { let { focusNode: a, focusOffset: c, anchorNode: u, anchorOffset: f } = n.domSelectionRange(), d = l.caretBidiLevel; l.modify("move", t, "character"); let p = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: h, focusOffset: g } = n.domSelectionRange(), m = h && !p.contains(h.nodeType == 1 ? h : h.parentNode) || a == h && c == g; try { l.collapse(u, f), a && (a != u || c != f) && l.extend && l.extend(a, c) } catch { } return d != null && (l.caretBidiLevel = d), m }) : r.pos == r.start() || r.pos == r.end() } let tc = null, nc = null, rc = !1; function Jb(n, e, t) { return tc == e && nc == t ? rc : (tc = e, nc = t, rc = t == "up" || t == "down" ? Wb(n, e, t) : qb(n, e, t)) } const Me = 0, ic = 1, Dt = 2, He = 3; class Tr {
  constructor(e, t, r, i) { this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = Me, r.pmViewDesc = this } matchesWidget(e) { return !1 } matchesMark(e) { return !1 } matchesNode(e, t, r) { return !1 } matchesHack(e) { return !1 } parseRule() { return null } stopEvent(e) { return !1 } get size() { let e = 0; for (let t = 0; t < this.children.length; t++)e += this.children[t].size; return e } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let e = 0; e < this.children.length; e++)this.children[e].destroy() } posBeforeChild(e) { for (let t = 0, r = this.posAtStart; ; t++) { let i = this.children[t]; if (i == e) return r; r += i.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(e, t, r) { if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)) if (r < 0) { let s, o; if (e == this.contentDOM) s = e.childNodes[t - 1]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; s = e.previousSibling } for (; s && !((o = s.pmViewDesc) && o.parent == this);)s = s.previousSibling; return s ? this.posBeforeChild(o) + o.size : this.posAtStart } else { let s, o; if (e == this.contentDOM) s = e.childNodes[t]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; s = e.nextSibling } for (; s && !((o = s.pmViewDesc) && o.parent == this);)s = s.nextSibling; return s ? this.posBeforeChild(o) : this.posAtEnd } let i; if (e == this.dom && this.contentDOM) i = t > te(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) i = e.compareDocumentPosition(this.contentDOM) & 2; else if (this.dom.firstChild) { if (t == 0) for (let s = e; ; s = s.parentNode) { if (s == this.dom) { i = !1; break } if (s.previousSibling) break } if (i == null && t == e.childNodes.length) for (let s = e; ; s = s.parentNode) { if (s == this.dom) { i = !0; break } if (s.nextSibling) break } } return i ?? r > 0 ? this.posAtEnd : this.posAtStart } nearestDesc(e, t = !1) { for (let r = !0, i = e; i; i = i.parentNode) { let s = this.getDesc(i), o; if (s && (!t || s.node)) if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e)) r = !1; else return s } } getDesc(e) { let t = e.pmViewDesc; for (let r = t; r; r = r.parent)if (r == this) return t } posFromDOM(e, t, r) { for (let i = e; i; i = i.parentNode) { let s = this.getDesc(i); if (s) return s.localPosFromDOM(e, t, r) } return -1 } descAt(e) { for (let t = 0, r = 0; t < this.children.length; t++) { let i = this.children[t], s = r + i.size; if (r == e && s != r) { for (; !i.border && i.children.length;)for (let o = 0; o < i.children.length; o++) { let l = i.children[o]; if (l.size) { i = l; break } } return i } if (e < s) return i.descAt(e - r - i.border); r = s } } domFromPos(e, t) { if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 }; let r = 0, i = 0; for (let s = 0; r < this.children.length; r++) { let o = this.children[r], l = s + o.size; if (l > e || o instanceof Cd) { i = e - s; break } s = l } if (i) return this.children[r].domFromPos(i - this.children[r].border, t); for (let s; r && !(s = this.children[r - 1]).size && s instanceof Ed && s.side >= 0; r--); if (t <= 0) { let s, o = !0; for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1); return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? te(s.dom) + 1 : 0 } } else { let s, o = !0; for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1); return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? te(s.dom) : this.contentDOM.childNodes.length } } } parseRange(e, t, r = 0) { if (this.children.length == 0) return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let i = -1, s = -1; for (let o = r, l = 0; ; l++) { let a = this.children[l], c = o + a.size; if (i == -1 && e <= c) { let u = o + a.border; if (e >= u && t <= c - a.border && a.node && a.contentDOM && this.contentDOM.contains(a.contentDOM)) return a.parseRange(e, t, u); e = o; for (let f = l; f > 0; f--) { let d = this.children[f - 1]; if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(1)) { i = te(d.dom) + 1; break } e -= d.size } i == -1 && (i = 0) } if (i > -1 && (c > t || l == this.children.length - 1)) { t = c; for (let u = l + 1; u < this.children.length; u++) { let f = this.children[u]; if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) { s = te(f.dom); break } t += f.size } s == -1 && (s = this.contentDOM.childNodes.length); break } o = c } return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s } } emptyChildAt(e) { if (this.border || !this.contentDOM || !this.children.length) return !1; let t = this.children[e < 0 ? 0 : this.children.length - 1]; return t.size == 0 || t.emptyChildAt(e) } domAfterPos(e) { let { node: t, offset: r } = this.domFromPos(e, 0); if (t.nodeType != 1 || r == t.childNodes.length) throw new RangeError("No node after pos " + e); return t.childNodes[r] } setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t); for (let p = 0, h = 0; p < this.children.length; p++) { let g = this.children[p], m = h + g.size; if (s > h && o < m) return g.setSelection(e - h - g.border, t - h - g.border, r, i); h = m } let l = this.domFromPos(e, e ? -1 : 1), a = t == e ? l : this.domFromPos(t, t ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), f = !1; if ((Te || re) && e == t) {
      let { node: p, offset: h } = l; if (p.nodeType == 3) {
        if (f = !!(h && p.nodeValue[h - 1] == `
`), f && h == p.nodeValue.length) for (let g = p, m; g; g = g.parentNode) { if (m = g.nextSibling) { m.nodeName == "BR" && (l = a = { node: m.parentNode, offset: te(m) + 1 }); break } let y = g.pmViewDesc; if (y && y.node && y.node.isBlock) break }
      } else { let g = p.childNodes[h - 1]; f = g && (g.nodeName == "BR" || g.contentEditable == "false") }
    } if (Te && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) { let p = u.focusNode.childNodes[u.focusOffset]; p && p.contentEditable == "false" && (i = !0) } if (!(i || f && re) && en(l.node, l.offset, u.anchorNode, u.anchorOffset) && en(a.node, a.offset, u.focusNode, u.focusOffset)) return; let d = !1; if ((c.extend || e == t) && !(f && Te)) { c.collapse(l.node, l.offset); try { e != t && c.extend(a.node, a.offset), d = !0 } catch { } } if (!d) { if (e > t) { let h = l; l = a, a = h } let p = document.createRange(); p.setEnd(a.node, a.offset), p.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(p) }
  } ignoreMutation(e) { return !this.contentDOM && e.type != "selection" } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(e, t) { for (let r = 0, i = 0; i < this.children.length; i++) { let s = this.children[i], o = r + s.size; if (r == o ? e <= o && t >= r : e < o && t > r) { let l = r + s.border, a = o - s.border; if (e >= l && t <= a) { this.dirty = e == r || t == o ? Dt : ic, e == l && t == a && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = He : s.markDirty(e - l, t - l); return } else s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Dt : He } r = o } this.dirty = Dt } markParentsDirty() { let e = 1; for (let t = this.parent; t; t = t.parent, e++) { let r = e == 1 ? Dt : ic; t.dirty < r && (t.dirty = r) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } get ignoreForSelection() { return !1 } isText(e) { return !1 }
} class Ed extends Tr { constructor(e, t, r, i) { let s, o = t.type.toDOM; if (typeof o == "function" && (o = o(r, () => { if (!s) return i; if (s.parent) return s.parent.posBeforeChild(s) })), !t.type.spec.raw) { if (o.nodeType != 1) { let l = document.createElement("span"); l.appendChild(o), o = l } o.contentEditable = "false", o.classList.add("ProseMirror-widget") } super(e, [], o, null), this.widget = t, this.widget = t, s = this } matchesWidget(e) { return this.dirty == Me && e.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(e) { let t = this.widget.spec.stopEvent; return t ? t(e) : !1 } ignoreMutation(e) { return e.type != "selection" || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get ignoreForSelection() { return !!this.widget.type.spec.relaxedSide } get side() { return this.widget.type.side } } class Gb extends Tr { constructor(e, t, r, i) { super(e, [], t, null), this.textDOM = r, this.text = i } get size() { return this.text.length } localPosFromDOM(e, t) { return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t } domFromPos(e) { return { node: this.textDOM, offset: e } } ignoreMutation(e) { return e.type === "characterData" && e.target.nodeValue == e.oldValue } } class tn extends Tr { constructor(e, t, r, i, s) { super(e, [], r, i), this.mark = t, this.spec = s } static create(e, t, r, i) { let s = i.nodeViews[t.type.name], o = s && s(t, i, r); return (!o || !o.dom) && (o = on.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new tn(e, t, o.dom, o.contentDOM || o.dom, o) } parseRule() { return this.dirty & He || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM } } matchesMark(e) { return this.dirty != He && this.mark.eq(e) } markDirty(e, t) { if (super.markDirty(e, t), this.dirty != Me) { let r = this.parent; for (; !r.node;)r = r.parent; r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Me } } slice(e, t, r) { let i = tn.create(this.parent, this.mark, !0, r), s = this.children, o = this.size; t < o && (s = vo(s, t, o, r)), e > 0 && (s = vo(s, 0, e, r)); for (let l = 0; l < s.length; l++)s[l].parent = i; return i.children = s, i } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } } class yt extends Tr { constructor(e, t, r, i, s, o, l, a, c) { super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l } static create(e, t, r, i, s, o) { let l = s.nodeViews[t.type.name], a, c = l && l(t, s, () => { if (!a) return o; if (a.parent) return a.parent.posBeforeChild(a) }, r, i), u = c && c.dom, f = c && c.contentDOM; if (t.isText) { if (!u) u = document.createTextNode(t.text); else if (u.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node") } else u || ({ dom: u, contentDOM: f } = on.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs)); !f && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0)); let d = u; return u = Md(u, r, t), c ? a = new Yb(e, t, r, i, u, f || null, d, c, s, o + 1) : t.isText ? new us(e, t, r, i, u, d, s) : new yt(e, t, r, i, u, f || null, d, s, o + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let e = { node: this.node.type.name, attrs: this.node.attrs }; if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM) e.getContent = () => this.node.content; else if (!this.contentLost) e.contentElement = this.contentDOM; else { for (let t = this.children.length - 1; t >= 0; t--) { let r = this.children[t]; if (this.dom.contains(r.dom.parentNode)) { e.contentElement = r.dom.parentNode; break } } e.contentElement || (e.getContent = () => x.empty) } return e } matchesNode(e, t, r) { return this.dirty == Me && e.eq(this.node) && ui(t, this.outerDeco) && r.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(e, t) { let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, l = s && s.pos < 0, a = new Qb(this, o && o.node, e); t0(this.node, this.innerDeco, (c, u, f) => { c.spec.marks ? a.syncToMarks(c.spec.marks, r, e, u) : c.type.side >= 0 && !f && a.syncToMarks(u == this.node.childCount ? L.none : this.node.child(u).marks, r, e, u), a.placeWidget(c, e, i) }, (c, u, f, d) => { a.syncToMarks(c.marks, r, e, d); let p; a.findNodeMatch(c, u, f, d) || l && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (p = a.findIndexWithChild(s.node)) > -1 && a.updateNodeAt(c, u, f, p, e) || a.updateNextNode(c, u, f, e, d, i) || a.addNode(c, u, f, e, i), i += c.nodeSize }), a.syncToMarks([], r, e, 0), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || this.dirty == Dt) && (o && this.protectLocalComposition(e, o), Od(this.contentDOM, this.children, e), En && n0(this.dom)) } localCompositionInfo(e, t) { let { from: r, to: i } = e.state.selection; if (!(e.state.selection instanceof R) || r < t || i > t + this.node.content.size) return null; let s = e.input.compositionNode; if (!s || !this.dom.contains(s.parentNode)) return null; if (this.node.inlineContent) { let o = s.nodeValue, l = r0(this.node.content, o, r - t, i - t); return l < 0 ? null : { node: s, pos: l, text: o } } else return { node: s, pos: -1, text: "" } } protectLocalComposition(e, { node: t, pos: r, text: i }) { if (this.getDesc(t)) return; let s = t; for (; s.parentNode != this.contentDOM; s = s.parentNode) { for (; s.previousSibling;)s.parentNode.removeChild(s.previousSibling); for (; s.nextSibling;)s.parentNode.removeChild(s.nextSibling); s.pmViewDesc && (s.pmViewDesc = void 0) } let o = new Gb(this, s, t, i); e.input.compositionNodes.push(o), this.children = vo(this.children, r, r + i.length, e, o) } update(e, t, r, i) { return this.dirty == He || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0) } updateInner(e, t, r, i) { this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Me } updateOuterDeco(e) { if (ui(e, this.outerDeco)) return; let t = this.nodeDOM.nodeType != 1, r = this.dom; this.dom = Td(this.dom, this.nodeDOM, Ro(this.outerDeco, this.node, t), Ro(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e } selectNode() { this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0)) } deselectNode() { this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable")) } get domAtom() { return this.node.isAtom } } function sc(n, e, t, r, i) { Md(r, e, n); let s = new yt(void 0, n, e, t, r, r, r, i, 0); return s.contentDOM && s.updateChildren(i, 0), s } class us extends yt { constructor(e, t, r, i, s, o, l) { super(e, t, r, i, s, null, o, l, 0) } parseRule() { let e = this.nodeDOM.parentNode; for (; e && e != this.dom && !e.pmIsDeco;)e = e.parentNode; return { skip: e || !0 } } update(e, t, r, i) { return this.dirty == He || this.dirty != Me && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Me || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Me, !0) } inParent() { let e = this.parent.contentDOM; for (let t = this.nodeDOM; t; t = t.parentNode)if (t == e) return !0; return !1 } domFromPos(e) { return { node: this.nodeDOM, offset: e } } localPosFromDOM(e, t, r) { return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r) } ignoreMutation(e) { return e.type != "characterData" && e.type != "selection" } slice(e, t, r) { let i = this.node.cut(e, t), s = document.createTextNode(i.text); return new us(this.parent, i, this.outerDeco, this.innerDeco, s, s, r) } markDirty(e, t) { super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = He) } get domAtom() { return !1 } isText(e) { return this.node.text == e } } class Cd extends Tr { parseRule() { return { ignore: !0 } } matchesHack(e) { return this.dirty == Me && this.dom.nodeName == e } get domAtom() { return !0 } get ignoreForCoords() { return this.dom.nodeName == "IMG" } } class Yb extends yt { constructor(e, t, r, i, s, o, l, a, c, u) { super(e, t, r, i, s, o, l, c, u), this.spec = a } update(e, t, r, i) { if (this.dirty == He) return !1; if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) { let s = this.spec.update(e, t, r); return s && this.updateInner(e, t, r, i), s } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(e, t, r, i) { this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(e) { return this.spec.stopEvent ? this.spec.stopEvent(e) : !1 } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } } function Od(n, e, t) { let r = n.firstChild, i = !1; for (let s = 0; s < e.length; s++) { let o = e[s], l = o.dom; if (l.parentNode == n) { for (; l != r;)r = oc(r), i = !0; r = r.nextSibling } else i = !0, n.insertBefore(l, r); if (o instanceof tn) { let a = r ? r.previousSibling : n.lastChild; Od(o.contentDOM, o.children, t), r = a ? a.nextSibling : n.firstChild } } for (; r;)r = oc(r), i = !0; i && t.trackWrites == n && (t.trackWrites = null) } const Gn = function (n) { n && (this.nodeName = n) }; Gn.prototype = Object.create(null); const It = [new Gn]; function Ro(n, e, t) { if (n.length == 0) return It; let r = t ? It[0] : new Gn, i = [r]; for (let s = 0; s < n.length; s++) { let o = n[s].type.attrs; if (o) { o.nodeName && i.push(r = new Gn(o.nodeName)); for (let l in o) { let a = o[l]; a != null && (t && i.length == 1 && i.push(r = new Gn(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + a : l == "style" ? r.style = (r.style ? r.style + ";" : "") + a : l != "nodeName" && (r[l] = a)) } } } return i } function Td(n, e, t, r) { if (t == It && r == It) return e; let i = e; for (let s = 0; s < r.length; s++) { let o = r[s], l = t[s]; if (s) { let a; l && l.nodeName == o.nodeName && i != n && (a = i.parentNode) && a.nodeName.toLowerCase() == o.nodeName || (a = document.createElement(o.nodeName), a.pmIsDeco = !0, a.appendChild(i), l = It[0]), i = a } Xb(i, l || It[0], o) } return i } function Xb(n, e, t) { for (let r in e) r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r); for (let r in t) r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]); if (e.class != t.class) { let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : []; for (let s = 0; s < r.length; s++)i.indexOf(r[s]) == -1 && n.classList.remove(r[s]); for (let s = 0; s < i.length; s++)r.indexOf(i[s]) == -1 && n.classList.add(i[s]); n.classList.length == 0 && n.removeAttribute("class") } if (e.style != t.style) { if (e.style) { let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i; for (; i = r.exec(e.style);)n.style.removeProperty(i[1]) } t.style && (n.style.cssText += t.style) } } function Md(n, e, t) { return Td(n, n, It, Ro(e, t, n.nodeType != 1)) } function ui(n, e) { if (n.length != e.length) return !1; for (let t = 0; t < n.length; t++)if (!n[t].type.eq(e[t].type)) return !1; return !0 } function oc(n) { let e = n.nextSibling; return n.parentNode.removeChild(n), e } class Qb { constructor(e, t, r) { this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = Zb(e.node.content, e) } destroyBetween(e, t) { if (e != t) { for (let r = e; r < t; r++)this.top.children[r].destroy(); this.top.children.splice(e, t - e), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(e, t, r, i) { let s = 0, o = this.stack.length >> 1, l = Math.min(o, e.length); for (; s < l && (s == o - 1 ? this.top : this.stack[s + 1 << 1]).matchesMark(e[s]) && e[s].type.spec.spanning !== !1;)s++; for (; s < o;)this.destroyRest(), this.top.dirty = Me, this.index = this.stack.pop(), this.top = this.stack.pop(), o--; for (; o < e.length;) { this.stack.push(this.top, this.index + 1); let a = -1, c = this.top.children.length; i < this.preMatch.index && (c = Math.min(this.index + 3, c)); for (let u = this.index; u < c; u++) { let f = this.top.children[u]; if (f.matchesMark(e[o]) && !this.isLocked(f.dom)) { a = u; break } } if (a > -1) a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index]; else { let u = tn.create(this.top, e[o], t, r); this.top.children.splice(this.index, 0, u), this.top = u, this.changed = !0 } this.index = 0, o++ } } findNodeMatch(e, t, r, i) { let s = -1, o; if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r)) s = this.top.children.indexOf(o, this.index); else for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) { let c = this.top.children[l]; if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) { s = l; break } } return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0) } updateNodeAt(e, t, r, i, s) { let o = this.top.children[i]; return o.dirty == He && o.dom == o.contentDOM && (o.dirty = Dt), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1 } findIndexWithChild(e) { for (; ;) { let t = e.parentNode; if (!t) return -1; if (t == this.top.contentDOM) { let r = e.pmViewDesc; if (r) { for (let i = this.index; i < this.top.children.length; i++)if (this.top.children[i] == r) return i } return -1 } e = t } } updateNextNode(e, t, r, i, s, o) { for (let l = this.index; l < this.top.children.length; l++) { let a = this.top.children[l]; if (a instanceof yt) { let c = this.preMatch.matched.get(a); if (c != null && c != s) return !1; let u = a.dom, f, d = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != He && ui(t, a.outerDeco)); if (!d && a.update(e, t, r, i)) return this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0; if (!d && (f = this.recreateWrapper(a, e, t, r, i, o))) return this.destroyBetween(this.index, l), this.top.children[this.index] = f, f.contentDOM && (f.dirty = Dt, f.updateChildren(i, o + 1), f.dirty = Me), this.changed = !0, this.index++, !0; break } } return !1 } recreateWrapper(e, t, r, i, s, o) { if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !ui(r, e.outerDeco) || !i.eq(e.innerDeco)) return null; let l = yt.create(this.top, t, r, i, s, o); if (l.contentDOM) { l.children = e.children, e.children = []; for (let a of l.children) a.parent = l } return e.destroy(), l } addNode(e, t, r, i, s) { let o = yt.create(this.top, e, t, r, i, s); o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0 } placeWidget(e, t, r) { let i = this.index < this.top.children.length ? this.top.children[this.index] : null; if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++; else { let s = new Ed(this.top, e, t, r); this.top.children.splice(this.index++, 0, s), this.changed = !0 } } addTextblockHacks() { let e = this.top.children[this.index - 1], t = this.top; for (; e instanceof tn;)t = e, e = t.children[t.children.length - 1]; (!e || !(e instanceof us) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((re || J) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top)) } addHackNode(e, t) { if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) this.index++; else { let r = document.createElement(e); e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak"); let i = new Cd(this.top, [], r, null); t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0 } } isLocked(e) { return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode)) } } function Zb(n, e) { let t = e, r = t.children.length, i = n.childCount, s = new Map, o = []; e: for (; i > 0;) { let l; for (; ;)if (r) { let c = t.children[r - 1]; if (c instanceof tn) t = c, r = c.children.length; else { l = c, r--; break } } else { if (t == e) break e; r = t.parent.children.indexOf(t), t = t.parent } let a = l.node; if (a) { if (a != n.child(i - 1)) break; --i, s.set(l, i), o.push(l) } } return { index: i, matched: s, matches: o.reverse() } } function e0(n, e) { return n.type.side - e.type.side } function t0(n, e, t, r) { let i = e.locals(n), s = 0; if (i.length == 0) { for (let c = 0; c < n.childCount; c++) { let u = n.child(c); r(u, i, e.forChild(s, u), c), s += u.nodeSize } return } let o = 0, l = [], a = null; for (let c = 0; ;) { let u, f; for (; o < i.length && i[o].to == s;) { let m = i[o++]; m.widget && (u ? (f || (f = [u])).push(m) : u = m) } if (u) if (f) { f.sort(e0); for (let m = 0; m < f.length; m++)t(f[m], c, !!a) } else t(u, c, !!a); let d, p; if (a) p = -1, d = a, a = null; else if (c < n.childCount) p = c, d = n.child(c++); else break; for (let m = 0; m < l.length; m++)l[m].to <= s && l.splice(m--, 1); for (; o < i.length && i[o].from <= s && i[o].to > s;)l.push(i[o++]); let h = s + d.nodeSize; if (d.isText) { let m = h; o < i.length && i[o].from < m && (m = i[o].from); for (let y = 0; y < l.length; y++)l[y].to < m && (m = l[y].to); m < h && (a = d.cut(m - s), d = d.cut(0, m - s), h = m, p = -1) } else for (; o < i.length && i[o].to < h;)o++; let g = d.isInline && !d.isLeaf ? l.filter(m => !m.inline) : l.slice(); r(d, g, e.forChild(s, d), p), s = h } } function n0(n) { if (n.nodeName == "UL" || n.nodeName == "OL") { let e = n.style.cssText; n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e } } function r0(n, e, t, r) { for (let i = 0, s = 0; i < n.childCount && s <= r;) { let o = n.child(i++), l = s; if (s += o.nodeSize, !o.isText) continue; let a = o.text; for (; i < n.childCount;) { let c = n.child(i++); if (s += c.nodeSize, !c.isText) break; a += c.text } if (s >= t) { if (s >= r && a.slice(r - e.length - l, r - l) == e) return r - e.length; let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1; if (c >= 0 && c + e.length + l >= t) return l + c; if (t == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e) return r } } return -1 } function vo(n, e, t, r, i) { let s = []; for (let o = 0, l = 0; o < n.length; o++) { let a = n[o], c = l, u = l += a.size; c >= t || u <= e ? s.push(a) : (c < e && s.push(a.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > t && s.push(a.slice(t - c, a.size, r))) } return s } function Ol(n, e = null) { let t = n.domSelectionRange(), r = n.state.doc; if (!t.focusNode) return null; let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1); if (o < 0) return null; let l = r.resolve(o), a, c; if (cs(t)) { for (a = o; i && !i.node;)i = i.parent; let f = i.node; if (i && f.isAtom && A.isSelectable(f) && i.parent && !(f.isInline && Rb(t.focusNode, t.focusOffset, i.dom))) { let d = i.posBefore; c = new A(o == d ? l : r.resolve(d)) } } else { if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) { let f = o, d = o; for (let p = 0; p < t.rangeCount; p++) { let h = t.getRangeAt(p); f = Math.min(f, n.docView.posFromDOM(h.startContainer, h.startOffset, 1)), d = Math.max(d, n.docView.posFromDOM(h.endContainer, h.endOffset, -1)) } if (f < 0) return null;[a, o] = d == n.state.selection.anchor ? [d, f] : [f, d], l = r.resolve(o) } else a = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1); if (a < 0) return null } let u = r.resolve(a); if (!c) { let f = e == "pointer" || n.state.selection.head < l.pos && !s ? 1 : -1; c = Tl(n, u, l, f) } return c } function Ad(n) { return n.editable ? n.hasFocus() : Rd(n) && document.activeElement && document.activeElement.contains(n.dom) } function Ge(n, e = !1) { let t = n.state.selection; if (Nd(n, t), !!Ad(n)) { if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && J) { let r = n.domSelectionRange(), i = n.domObserver.currentSelection; if (r.anchorNode && i.anchorNode && en(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) { n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection(); return } } if (n.domObserver.disconnectSelection(), n.cursorWrapper) s0(n); else { let { anchor: r, head: i } = t, s, o; lc && !(t instanceof R) && (t.$from.parent.inlineContent || (s = ac(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = ac(n, t.to))), n.docView.setSelection(r, i, n, e), lc && (s && cc(s), o && cc(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && i0(n)) } n.domObserver.setCurSelection(), n.domObserver.connectSelection() } } const lc = re || J && md < 63; function ac(n, e) { let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null; if (re && i && i.contentEditable == "false") return Bs(i); if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) { if (i) return Bs(i); if (s) return Bs(s) } } function Bs(n) { return n.contentEditable = "true", re && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n } function cc(n) { n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null) } function i0(n) { let e = n.dom.ownerDocument; e.removeEventListener("selectionchange", n.input.hideSelectionGuard); let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset; e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => { (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => { (!Ad(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection") }, 20)) }) } function s0(n) { let e = n.domSelection(); if (!e) return; let t = n.cursorWrapper.dom, r = t.nodeName == "IMG"; r ? e.collapse(t.parentNode, te(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && me && gt <= 11 && (t.disabled = !0, t.disabled = !1) } function Nd(n, e) { if (e instanceof A) { let t = n.docView.descAt(e.from); t != n.lastSelectedViewDesc && (uc(n), t && t.selectNode(), n.lastSelectedViewDesc = t) } else uc(n) } function uc(n) { n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0) } function Tl(n, e, t, r) { return n.someProp("createSelectionBetween", i => i(n, e, t)) || R.between(e, t, r) } function fc(n) { return n.editable && !n.hasFocus() ? !1 : Rd(n) } function Rd(n) { let e = n.domSelectionRange(); if (!e.anchorNode) return !1; try { return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode)) } catch { return !1 } } function o0(n) { let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange(); return en(e.node, e.offset, t.anchorNode, t.anchorOffset) } function _o(n, e) { let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i; return s && _.findFrom(s, e) } function ot(n, e) { return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0 } function dc(n, e, t) { let r = n.state.selection; if (r instanceof R) if (t.indexOf("s") > -1) { let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter; if (!s || s.isText || !s.isLeaf) return !1; let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1)); return ot(n, new R(r.$anchor, o)) } else if (r.empty) { if (n.endOfTextblock(e > 0 ? "forward" : "backward")) { let i = _o(n.state, e); return i && i instanceof A ? ot(n, i) : !1 } else if (!(Ee && t.indexOf("m") > -1)) { let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o; if (!s || s.isText) return !1; let l = e < 0 ? i.pos - s.nodeSize : i.pos; return s.isAtom || (o = n.docView.descAt(l)) && !o.contentDOM ? A.isSelectable(s) ? ot(n, new A(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : Or ? ot(n, new R(n.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1 } } else return !1; else { if (r instanceof A && r.node.isInline) return ot(n, new R(e > 0 ? r.$to : r.$from)); { let i = _o(n.state, e); return i ? ot(n, i) : !1 } } } function fi(n) { return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length } function Yn(n, e) { let t = n.pmViewDesc; return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR") } function cn(n, e) { return e < 0 ? l0(n) : a0(n) } function l0(n) { let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset; if (!t) return; let i, s, o = !1; for (Te && t.nodeType == 1 && r < fi(t) && Yn(t.childNodes[r], -1) && (o = !0); ;)if (r > 0) { if (t.nodeType != 1) break; { let l = t.childNodes[r - 1]; if (Yn(l, -1)) i = t, s = --r; else if (l.nodeType == 3) t = l, r = t.nodeValue.length; else break } } else { if (vd(t)) break; { let l = t.previousSibling; for (; l && Yn(l, -1);)i = t.parentNode, s = te(l), l = l.previousSibling; if (l) t = l, r = fi(t); else { if (t = t.parentNode, t == n.dom) break; r = 0 } } } o ? Do(n, t, r) : i && Do(n, i, s) } function a0(n) { let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset; if (!t) return; let i = fi(t), s, o; for (; ;)if (r < i) { if (t.nodeType != 1) break; let l = t.childNodes[r]; if (Yn(l, 1)) s = t, o = ++r; else break } else { if (vd(t)) break; { let l = t.nextSibling; for (; l && Yn(l, 1);)s = l.parentNode, o = te(l) + 1, l = l.nextSibling; if (l) t = l, r = 0, i = fi(t); else { if (t = t.parentNode, t == n.dom) break; r = i = 0 } } } s && Do(n, s, o) } function vd(n) { let e = n.pmViewDesc; return e && e.node && e.node.isBlock } function c0(n, e) { for (; n && e == n.childNodes.length && !Cr(n);)e = te(n) + 1, n = n.parentNode; for (; n && e < n.childNodes.length;) { let t = n.childNodes[e]; if (t.nodeType == 3) return t; if (t.nodeType == 1 && t.contentEditable == "false") break; n = t, e = 0 } } function u0(n, e) { for (; n && !e && !Cr(n);)e = te(n), n = n.parentNode; for (; n && e;) { let t = n.childNodes[e - 1]; if (t.nodeType == 3) return t; if (t.nodeType == 1 && t.contentEditable == "false") break; n = t, e = n.childNodes.length } } function Do(n, e, t) { if (e.nodeType != 3) { let s, o; (o = c0(e, t)) ? (e = o, t = 0) : (s = u0(e, t)) && (e = s, t = s.nodeValue.length) } let r = n.domSelection(); if (!r) return; if (cs(r)) { let s = document.createRange(); s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s) } else r.extend && r.extend(e, t); n.domObserver.setCurSelection(); let { state: i } = n; setTimeout(() => { n.state == i && Ge(n) }, 50) } function hc(n, e) { let t = n.state.doc.resolve(e); if (!(J || gd) && t.parent.inlineContent) { let i = n.coordsAtPos(e); if (e > t.start()) { let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2; if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1) return s.left < i.left ? "ltr" : "rtl" } if (e < t.end()) { let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2; if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1) return s.left > i.left ? "ltr" : "rtl" } } return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr" } function pc(n, e, t) { let r = n.state.selection; if (r instanceof R && !r.empty || t.indexOf("s") > -1 || Ee && t.indexOf("m") > -1) return !1; let { $from: i, $to: s } = r; if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) { let o = _o(n.state, e); if (o && o instanceof A) return ot(n, o) } if (!i.parent.inlineContent) { let o = e < 0 ? i : s, l = r instanceof Se ? _.near(o, e) : _.findFrom(o, e); return l ? ot(n, l) : !1 } return !1 } function mc(n, e) { if (!(n.state.selection instanceof R)) return !0; let { $head: t, $anchor: r, empty: i } = n.state.selection; if (!t.sameParent(r)) return !0; if (!i) return !1; if (n.endOfTextblock(e > 0 ? "forward" : "backward")) return !0; let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter); if (s && !s.isText) { let o = n.state.tr; return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0 } return !1 } function gc(n, e, t) { n.domObserver.stop(), e.contentEditable = t, n.domObserver.start() } function f0(n) { if (!re || n.state.selection.$head.parentOffset > 0) return !1; let { focusNode: e, focusOffset: t } = n.domSelectionRange(); if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") { let r = e.firstChild; gc(n, r, "true"), setTimeout(() => gc(n, r, "false"), 20) } return !1 } function d0(n) { let e = ""; return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e } function h0(n, e) { let t = e.keyCode, r = d0(e); if (t == 8 || Ee && t == 72 && r == "c") return mc(n, -1) || cn(n, -1); if (t == 46 && !e.shiftKey || Ee && t == 68 && r == "c") return mc(n, 1) || cn(n, 1); if (t == 13 || t == 27) return !0; if (t == 37 || Ee && t == 66 && r == "c") { let i = t == 37 ? hc(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1; return dc(n, i, r) || cn(n, i) } else if (t == 39 || Ee && t == 70 && r == "c") { let i = t == 39 ? hc(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1; return dc(n, i, r) || cn(n, i) } else { if (t == 38 || Ee && t == 80 && r == "c") return pc(n, -1, r) || cn(n, -1); if (t == 40 || Ee && t == 78 && r == "c") return f0(n) || pc(n, 1, r) || cn(n, 1); if (r == (Ee ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90)) return !0 } return !1 } function Ml(n, e) {
  n.someProp("transformCopied", p => { e = p(e, n) }); let t = [], { content: r, openStart: i, openEnd: s } = e; for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1;) { i--, s--; let p = r.firstChild; t.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), r = p.content } let o = n.someProp("clipboardSerializer") || on.fromSchema(n.state.schema), l = Bd(), a = l.createElement("div"); a.appendChild(o.serializeFragment(r, { document: l })); let c = a.firstChild, u, f = 0; for (; c && c.nodeType == 1 && (u = Ld[c.nodeName.toLowerCase()]);) { for (let p = u.length - 1; p >= 0; p--) { let h = l.createElement(u[p]); for (; a.firstChild;)h.appendChild(a.firstChild); a.appendChild(h), f++ } c = a.firstChild } c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${f ? ` -${f}` : ""} ${JSON.stringify(t)}`); let d = n.someProp("clipboardTextSerializer", p => p(e, n)) || e.content.textBetween(0, e.content.size, `

`); return { dom: a, text: d, slice: e }
} function _d(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, l; if (!t && !e) return null; let a = !!e && (r || s || !t); if (a) {
    if (n.someProp("transformPastedText", d => { e = d(e, s || r, n) }), s) return l = new E(x.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", d => { l = d(l, n, !0) }), l; let f = n.someProp("clipboardTextParser", d => d(e, i, r, n)); if (f) l = f; else { let d = i.marks(), { schema: p } = n.state, h = on.fromSchema(p); o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach(g => { let m = o.appendChild(document.createElement("p")); g && m.appendChild(h.serializeNode(p.text(g, d))) }) }
  } else n.someProp("transformPastedHTML", f => { t = f(t, n) }), o = y0(t), Or && b0(o); let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || ""); if (u && u[3]) for (let f = +u[3]; f > 0; f--) { let d = o.firstChild; for (; d && d.nodeType != 1;)d = d.nextSibling; if (!d) break; o = d } if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || mt.fromSchema(n.state.schema)).parseSlice(o, { preserveWhitespace: !!(a || u), context: i, ruleFromNode(d) { return d.nodeName == "BR" && !d.nextSibling && d.parentNode && !p0.test(d.parentNode.nodeName) ? { ignore: !0 } : null } })), u) l = x0(yc(l, +u[1], +u[2]), u[4]); else if (l = E.maxOpen(m0(l.content, i), !0), l.openStart || l.openEnd) { let f = 0, d = 0; for (let p = l.content.firstChild; f < l.openStart && !p.type.spec.isolating; f++, p = p.firstChild); for (let p = l.content.lastChild; d < l.openEnd && !p.type.spec.isolating; d++, p = p.lastChild); l = yc(l, f, d) } return n.someProp("transformPasted", f => { l = f(l, n, a) }), l
} const p0 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function m0(n, e) { if (n.childCount < 2) return n; for (let t = e.depth; t >= 0; t--) { let i = e.node(t).contentMatchAt(e.index(t)), s, o = []; if (n.forEach(l => { if (!o) return; let a = i.findWrapping(l.type), c; if (!a) return o = null; if (c = o.length && s.length && Id(a, s, l, o[o.length - 1], 0)) o[o.length - 1] = c; else { o.length && (o[o.length - 1] = Pd(o[o.length - 1], s.length)); let u = Dd(l, a); o.push(u), i = i.matchType(u.type), s = a } }), o) return x.from(o) } return n } function Dd(n, e, t = 0) { for (let r = e.length - 1; r >= t; r--)n = e[r].create(null, x.from(n)); return n } function Id(n, e, t, r, i) { if (i < n.length && i < e.length && n[i] == e[i]) { let s = Id(n, e, t, r.lastChild, i + 1); if (s) return r.copy(r.content.replaceChild(r.childCount - 1, s)); if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1])) return r.copy(r.content.append(x.from(Dd(t, n, i + 1)))) } } function Pd(n, e) { if (e == 0) return n; let t = n.content.replaceChild(n.childCount - 1, Pd(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(x.empty, !0); return n.copy(t.append(r)) } function Io(n, e, t, r, i, s) { let o = e < 0 ? n.firstChild : n.lastChild, l = o.content; return n.childCount > 1 && (s = 0), i < r - 1 && (l = Io(l, e, t, r, i + 1, s)), i >= t && (l = e < 0 ? o.contentMatchAt(0).fillBefore(l, s <= i).append(l) : l.append(o.contentMatchAt(o.childCount).fillBefore(x.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(l)) } function yc(n, e, t) { return e < n.openStart && (n = new E(Io(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new E(Io(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n } const Ld = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let bc = null; function Bd() { return bc || (bc = document.implementation.createHTMLDocument("title")) } let Fs = null; function g0(n) { let e = window.trustedTypes; return e ? (Fs || (Fs = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: t => t })), Fs.createHTML(n)) : n } function y0(n) { let e = /^(\s*<meta [^>]*>)*/.exec(n); e && (n = n.slice(e[0].length)); let t = Bd().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i; if ((i = r && Ld[r[1].toLowerCase()]) && (n = i.map(s => "<" + s + ">").join("") + n + i.map(s => "</" + s + ">").reverse().join("")), t.innerHTML = g0(n), i) for (let s = 0; s < i.length; s++)t = t.querySelector(i[s]) || t; return t } function b0(n) { let e = n.querySelectorAll(J ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let t = 0; t < e.length; t++) { let r = e[t]; r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r) } } function x0(n, e) { if (!n.size) return n; let t = n.content.firstChild.type.schema, r; try { r = JSON.parse(e) } catch { return n } let { content: i, openStart: s, openEnd: o } = n; for (let l = r.length - 2; l >= 0; l -= 2) { let a = t.nodes[r[l]]; if (!a || a.hasRequiredAttrs()) break; i = x.from(a.create(r[l + 1], i)), s++, o++ } return new E(i, s, o) } const ue = {}, fe = {}, S0 = { touchstart: !0, touchmove: !0 }; class w0 { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.badSafariComposition = !1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function k0(n) { for (let e in ue) { let t = ue[e]; n.dom.addEventListener(e, n.input.eventHandlers[e] = r => { C0(n, r) && !Al(n, r) && (n.editable || !(r.type in fe)) && t(n, r) }, S0[e] ? { passive: !0 } : void 0) } re && n.dom.addEventListener("input", () => null), Po(n) } function ht(n, e) { n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now() } function E0(n) { n.domObserver.stop(); for (let e in n.input.eventHandlers) n.dom.removeEventListener(e, n.input.eventHandlers[e]); clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout) } function Po(n) { n.someProp("handleDOMEvents", e => { for (let t in e) n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = r => Al(n, r)) }) } function Al(n, e) { return n.someProp("handleDOMEvents", t => { let r = t[e.type]; return r ? r(n, e) || e.defaultPrevented : !1 }) } function C0(n, e) { if (!e.bubbles) return !0; if (e.defaultPrevented) return !1; for (let t = e.target; t != n.dom; t = t.parentNode)if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e)) return !1; return !0 } function O0(n, e) { !Al(n, e) && ue[e.type] && (n.editable || !(e.type in fe)) && ue[e.type](n, e) } fe.keydown = (n, e) => { let t = e; if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !zd(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(qe && J && t.keyCode == 13))) if (t.keyCode != 229 && n.domObserver.forceFlush(), En && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) { let r = Date.now(); n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => { n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", i => i(n, Nt(13, "Enter"))), n.input.lastIOSEnter = 0) }, 200) } else n.someProp("handleKeyDown", r => r(n, t)) || h0(n, t) ? t.preventDefault() : ht(n, "key") }; fe.keyup = (n, e) => { e.keyCode == 16 && (n.input.shiftKey = !1) }; fe.keypress = (n, e) => { let t = e; if (zd(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Ee && t.metaKey) return; if (n.someProp("handleKeyPress", i => i(n, t))) { t.preventDefault(); return } let r = n.state.selection; if (!(r instanceof R) || !r.$from.sameParent(r.$to)) { let i = String.fromCharCode(t.charCode), s = () => n.state.tr.insertText(i).scrollIntoView(); !/[\r\n]/.test(i) && !n.someProp("handleTextInput", o => o(n, r.$from.pos, r.$to.pos, i, s)) && n.dispatch(s()), t.preventDefault() } }; function fs(n) { return { left: n.clientX, top: n.clientY } } function T0(n, e) { let t = e.x - n.clientX, r = e.y - n.clientY; return t * t + r * r < 100 } function Nl(n, e, t, r, i) { if (r == -1) return !1; let s = n.state.doc.resolve(r); for (let o = s.depth + 1; o > 0; o--)if (n.someProp(e, l => o > s.depth ? l(n, t, s.nodeAfter, s.before(o), i, !0) : l(n, t, s.node(o), s.before(o), i, !1))) return !0; return !1 } function bn(n, e, t) { if (n.focused || n.focus(), n.state.selection.eq(e)) return; let r = n.state.tr.setSelection(e); r.setMeta("pointer", !0), n.dispatch(r) } function M0(n, e) { if (e == -1) return !1; let t = n.state.doc.resolve(e), r = t.nodeAfter; return r && r.isAtom && A.isSelectable(r) ? (bn(n, new A(t)), !0) : !1 } function A0(n, e) { if (e == -1) return !1; let t = n.state.selection, r, i; t instanceof A && (r = t.node); let s = n.state.doc.resolve(e); for (let o = s.depth + 1; o > 0; o--) { let l = o > s.depth ? s.nodeAfter : s.node(o); if (A.isSelectable(l)) { r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o); break } } return i != null ? (bn(n, A.create(n.state.doc, i)), !0) : !1 } function N0(n, e, t, r, i) { return Nl(n, "handleClickOn", e, t, r) || n.someProp("handleClick", s => s(n, e, r)) || (i ? A0(n, t) : M0(n, t)) } function R0(n, e, t, r) { return Nl(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", i => i(n, e, r)) } function v0(n, e, t, r) { return Nl(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", i => i(n, e, r)) || _0(n, t, r) } function _0(n, e, t) { if (t.button != 0) return !1; let r = n.state.doc; if (e == -1) return r.inlineContent ? (bn(n, R.create(r, 0, r.content.size)), !0) : !1; let i = r.resolve(e); for (let s = i.depth + 1; s > 0; s--) { let o = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s); if (o.inlineContent) bn(n, R.create(r, l + 1, l + 1 + o.content.size)); else if (A.isSelectable(o)) bn(n, A.create(r, l)); else continue; return !0 } } function Rl(n) { return di(n) } const Fd = Ee ? "metaKey" : "ctrlKey"; ue.mousedown = (n, e) => { let t = e; n.input.shiftKey = t.shiftKey; let r = Rl(n), i = Date.now(), s = "singleClick"; i - n.input.lastClick.time < 500 && T0(t, n.input.lastClick) && !t[Fd] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button }; let o = n.posAtCoords(fs(t)); o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new D0(n, o, t, !!r)) : (s == "doubleClick" ? R0 : v0)(n, o.pos, o.inside, t) ? t.preventDefault() : ht(n, "pointer")) }; class D0 { constructor(e, t, r, i) { this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[Fd], this.allowDefault = r.shiftKey; let s, o; if (t.inside > -1) s = e.state.doc.nodeAt(t.inside), o = t.inside; else { let u = e.state.doc.resolve(t.pos); s = u.parent, o = u.depth ? u.before() : 0 } const l = i ? null : r.target, a = l ? e.docView.nearestDesc(l, !0) : null; this.target = a && a.nodeDOM.nodeType == 1 ? a.nodeDOM : null; let { selection: c } = e.state; (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof A && c.from <= o && c.to > o) && (this.mightDrag = { node: s, pos: o, addAttr: !!(this.target && !this.target.draggable), setUneditable: !!(this.target && Te && !this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), ht(e, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Ge(this.view)), this.view.input.mouseDown = null } up(e) { if (this.done(), !this.view.dom.contains(e.target)) return; let t = this.pos; this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(fs(e))), this.updateAllowDefault(e), this.allowDefault || !t ? ht(this.view, "pointer") : N0(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || re && this.mightDrag && !this.mightDrag.node.isAtom || J && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (bn(this.view, _.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : ht(this.view, "pointer") } move(e) { this.updateAllowDefault(e), ht(this.view, "pointer"), e.buttons == 0 && this.done() } updateAllowDefault(e) { !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0) } } ue.touchstart = n => { n.input.lastTouch = Date.now(), Rl(n), ht(n, "pointer") }; ue.touchmove = n => { n.input.lastTouch = Date.now(), ht(n, "pointer") }; ue.contextmenu = n => Rl(n); function zd(n, e) { return n.composing ? !0 : re && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1 } const I0 = qe ? 5e3 : -1; fe.compositionstart = fe.compositionupdate = n => { if (!n.composing) { n.domObserver.flush(); let { state: e } = n, t = e.selection.$to; if (e.selection instanceof R && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some(r => r.type.spec.inclusive === !1) || J && gd && P0(n))) n.markCursor = n.state.storedMarks || t.marks(), di(n, !0), n.markCursor = null; else if (di(n, !e.selection.empty), Te && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) { let r = n.domSelectionRange(); for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0;) { let o = s < 0 ? i.lastChild : i.childNodes[s - 1]; if (!o) break; if (o.nodeType == 3) { let l = n.domSelection(); l && l.collapse(o, o.nodeValue.length); break } else i = o, s = -1 } } n.input.composing = !0 } $d(n, I0) }; function P0(n) { let { focusNode: e, focusOffset: t } = n.domSelectionRange(); if (!e || e.nodeType != 1 || t >= e.childNodes.length) return !1; let r = e.childNodes[t]; return r.nodeType == 1 && r.contentEditable == "false" } fe.compositionend = (n, e) => { n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.badSafariComposition ? n.domObserver.forceFlush() : n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, $d(n, 20)) }; function $d(n, e) { clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => di(n), e)) } function Hd(n) { for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = B0()); n.input.compositionNodes.length > 0;)n.input.compositionNodes.pop().markParentsDirty() } function L0(n) { let e = n.domSelectionRange(); if (!e.focusNode) return null; let t = Ab(e.focusNode, e.focusOffset), r = Nb(e.focusNode, e.focusOffset); if (t && r && t != r) { let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode; if (t == s || r == s) return s; if (!i || !i.isText(r.nodeValue)) return r; if (n.input.compositionNode == r) { let o = t.pmViewDesc; if (!(!o || !o.isText(t.nodeValue))) return r } } return t || r } function B0() { let n = document.createEvent("Event"); return n.initEvent("event", !0, !0), n.timeStamp } function di(n, e = !1) { if (!(qe && n.domObserver.flushingSoon >= 0)) { if (n.domObserver.forceFlush(), Hd(n), e || n.docView && n.docView.dirty) { let t = Ol(n), r = n.state.selection; return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0 } return !1 } } function F0(n, e) { if (!n.dom.parentNode) return; let t = n.dom.parentNode.appendChild(document.createElement("div")); t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px"; let r = getSelection(), i = document.createRange(); i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => { t.parentNode && t.parentNode.removeChild(t), n.focus() }, 50) } const ur = me && gt < 15 || En && Db < 604; ue.copy = fe.cut = (n, e) => { let t = e, r = n.state.selection, i = t.type == "cut"; if (r.empty) return; let s = ur ? null : t.clipboardData, o = r.content(), { dom: l, text: a } = Ml(n, o); s ? (t.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", a)) : F0(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }; function z0(n) { return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null } function $0(n, e) { if (!n.dom.parentNode) return; let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div")); t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(); let i = n.input.shiftKey && n.input.lastKeyCode != 45; setTimeout(() => { n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? fr(n, r.value, null, i, e) : fr(n, r.textContent, r.innerHTML, i, e) }, 50) } function fr(n, e, t, r, i) { let s = _d(n, e, t, r, n.state.selection.$from); if (n.someProp("handlePaste", a => a(n, i, s || E.empty))) return !0; if (!s) return !1; let o = z0(s), l = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s); return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } function jd(n) { let e = n.getData("text/plain") || n.getData("Text"); if (e) return e; let t = n.getData("text/uri-list"); return t ? t.replace(/\r?\n/g, " ") : "" } fe.paste = (n, e) => { let t = e; if (n.composing && !qe) return; let r = ur ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45; r && fr(n, jd(r), r.getData("text/html"), i, t) ? t.preventDefault() : $0(n, t) }; class Vd { constructor(e, t, r) { this.slice = e, this.move = t, this.node = r } } const H0 = Ee ? "altKey" : "ctrlKey"; function Ud(n, e) { let t = n.someProp("dragCopies", r => !r(e)); return t ?? !e[H0] } ue.dragstart = (n, e) => { let t = e, r = n.input.mouseDown; if (r && r.done(), !t.dataTransfer) return; let i = n.state.selection, s = i.empty ? null : n.posAtCoords(fs(t)), o; if (!(s && s.pos >= i.from && s.pos <= (i instanceof A ? i.to - 1 : i.to))) { if (r && r.mightDrag) o = A.create(n.state.doc, r.mightDrag.pos); else if (t.target && t.target.nodeType == 1) { let f = n.docView.nearestDesc(t.target, !0); f && f.node.type.spec.draggable && f != n.docView && (o = A.create(n.state.doc, f.posBefore)) } } let l = (o || n.state.selection).content(), { dom: a, text: c, slice: u } = Ml(n, l); (!t.dataTransfer.files.length || !J || md > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(ur ? "Text" : "text/html", a.innerHTML), t.dataTransfer.effectAllowed = "copyMove", ur || t.dataTransfer.setData("text/plain", c), n.dragging = new Vd(u, Ud(n, t), o) }; ue.dragend = n => { let e = n.dragging; window.setTimeout(() => { n.dragging == e && (n.dragging = null) }, 50) }; fe.dragover = fe.dragenter = (n, e) => e.preventDefault(); fe.drop = (n, e) => { try { j0(n, e, n.dragging) } finally { n.dragging = null } }; function j0(n, e, t) { if (!e.dataTransfer) return; let r = n.posAtCoords(fs(e)); if (!r) return; let i = n.state.doc.resolve(r.pos), s = t && t.slice; s ? n.someProp("transformPasted", p => { s = p(s, n, !1) }) : s = _d(n, jd(e.dataTransfer), ur ? null : e.dataTransfer.getData("text/html"), !1, i); let o = !!(t && Ud(n, e)); if (n.someProp("handleDrop", p => p(n, e, s || E.empty, o))) { e.preventDefault(); return } if (!s) return; e.preventDefault(); let l = s ? od(n.state.doc, i.pos, s) : i.pos; l == null && (l = i.pos); let a = n.state.tr; if (o) { let { node: p } = t; p ? p.replace(a) : a.deleteSelection() } let c = a.mapping.map(l), u = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, f = a.doc; if (u ? a.replaceRangeWith(c, c, s.content.firstChild) : a.replaceRange(c, c, s), a.doc.eq(f)) return; let d = a.doc.resolve(c); if (u && A.isSelectable(s.content.firstChild) && d.nodeAfter && d.nodeAfter.sameMarkup(s.content.firstChild)) a.setSelection(new A(d)); else { let p = a.mapping.map(l); a.mapping.maps[a.mapping.maps.length - 1].forEach((h, g, m, y) => p = y), a.setSelection(Tl(n, d, a.doc.resolve(p))) } n.focus(), n.dispatch(a.setMeta("uiEvent", "drop")) } ue.focus = n => { n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => { n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && Ge(n) }, 20)) }; ue.blur = (n, e) => { let t = e; n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1) }; ue.beforeinput = (n, e) => { if (J && qe && e.inputType == "deleteContentBackward") { n.domObserver.flushSoon(); let { domChangeCount: r } = n.input; setTimeout(() => { if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", s => s(n, Nt(8, "Backspace"))))) return; let { $cursor: i } = n.state.selection; i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView()) }, 50) } }; for (let n in fe) ue[n] = fe[n]; function dr(n, e) { if (n == e) return !0; for (let t in n) if (n[t] !== e[t]) return !1; for (let t in e) if (!(t in n)) return !1; return !0 } class hi { constructor(e, t) { this.toDOM = e, this.spec = t || Ut, this.side = this.spec.side || 0 } map(e, t, r, i) { let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1); return o ? null : new xe(s - r, s - r, this) } valid() { return !0 } eq(e) { return this == e || e instanceof hi && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && dr(this.spec, e.spec)) } destroy(e) { this.spec.destroy && this.spec.destroy(e) } } class bt { constructor(e, t) { this.attrs = e, this.spec = t || Ut } map(e, t, r, i) { let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r; return s >= o ? null : new xe(s, o, this) } valid(e, t) { return t.from < t.to } eq(e) { return this == e || e instanceof bt && dr(this.attrs, e.attrs) && dr(this.spec, e.spec) } static is(e) { return e.type instanceof bt } destroy() { } } class vl { constructor(e, t) { this.attrs = e, this.spec = t || Ut } map(e, t, r, i) { let s = e.mapResult(t.from + i, 1); if (s.deleted) return null; let o = e.mapResult(t.to + i, -1); return o.deleted || o.pos <= s.pos ? null : new xe(s.pos - r, o.pos - r, this) } valid(e, t) { let { index: r, offset: i } = e.content.findIndex(t.from), s; return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to } eq(e) { return this == e || e instanceof vl && dr(this.attrs, e.attrs) && dr(this.spec, e.spec) } destroy() { } } class xe { constructor(e, t, r) { this.from = e, this.to = t, this.type = r } copy(e, t) { return new xe(e, t, this.type) } eq(e, t = 0) { return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to } map(e, t, r) { return this.type.map(e, this, t, r) } static widget(e, t, r) { return new xe(e, e, new hi(t, r)) } static inline(e, t, r, i) { return new xe(e, t, new bt(r, i)) } static node(e, t, r, i) { return new xe(e, t, new vl(r, i)) } get spec() { return this.type.spec } get inline() { return this.type instanceof bt } get widget() { return this.type instanceof hi } } const dn = [], Ut = {}; class U { constructor(e, t) { this.local = e.length ? e : dn, this.children = t.length ? t : dn } static create(e, t) { return t.length ? pi(t, e, 0, Ut) : se } find(e, t, r) { let i = []; return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i } findInner(e, t, r, i, s) { for (let o = 0; o < this.local.length; o++) { let l = this.local[o]; l.from <= t && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i)) } for (let o = 0; o < this.children.length; o += 3)if (this.children[o] < t && this.children[o + 1] > e) { let l = this.children[o] + 1; this.children[o + 2].findInner(e - l, t - l, r, i + l, s) } } map(e, t, r) { return this == se || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || Ut) } mapInner(e, t, r, i, s) { let o; for (let l = 0; l < this.local.length; l++) { let a = this.local[l].map(e, r, i); a && a.type.valid(t, a) ? (o || (o = [])).push(a) : s.onRemove && s.onRemove(this.local[l].spec) } return this.children.length ? V0(this.children, o || [], e, t, r, i, s) : o ? new U(o.sort(Wt), dn) : se } add(e, t) { return t.length ? this == se ? U.create(e, t) : this.addInner(e, t, 0) : this } addInner(e, t, r) { let i, s = 0; e.forEach((l, a) => { let c = a + r, u; if (u = Kd(t, l, c)) { for (i || (i = this.children.slice()); s < i.length && i[s] < a;)s += 3; i[s] == a ? i[s + 2] = i[s + 2].addInner(l, u, c + 1) : i.splice(s, 0, a, a + l.nodeSize, pi(u, l, c + 1, Ut)), s += 3 } }); let o = Wd(s ? qd(t) : t, -r); for (let l = 0; l < o.length; l++)o[l].type.valid(e, o[l]) || o.splice(l--, 1); return new U(o.length ? this.local.concat(o).sort(Wt) : this.local, i || this.children) } remove(e) { return e.length == 0 || this == se ? this : this.removeInner(e, 0) } removeInner(e, t) { let r = this.children, i = this.local; for (let s = 0; s < r.length; s += 3) { let o, l = r[s] + t, a = r[s + 1] + t; for (let u = 0, f; u < e.length; u++)(f = e[u]) && f.from > l && f.to < a && (e[u] = null, (o || (o = [])).push(f)); if (!o) continue; r == this.children && (r = this.children.slice()); let c = r[s + 2].removeInner(o, l + 1); c != se ? r[s + 2] = c : (r.splice(s, 3), s -= 3) } if (i.length) { for (let s = 0, o; s < e.length; s++)if (o = e[s]) for (let l = 0; l < i.length; l++)i[l].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1)) } return r == this.children && i == this.local ? this : i.length || r.length ? new U(i, r) : se } forChild(e, t) { if (this == se) return this; if (t.isLeaf) return U.empty; let r, i; for (let l = 0; l < this.children.length; l += 3)if (this.children[l] >= e) { this.children[l] == e && (r = this.children[l + 2]); break } let s = e + 1, o = s + t.content.size; for (let l = 0; l < this.local.length; l++) { let a = this.local[l]; if (a.from < o && a.to > s && a.type instanceof bt) { let c = Math.max(s, a.from) - s, u = Math.min(o, a.to) - s; c < u && (i || (i = [])).push(a.copy(c, u)) } } if (i) { let l = new U(i.sort(Wt), dn); return r ? new ct([l, r]) : l } return r || se } eq(e) { if (this == e) return !0; if (!(e instanceof U) || this.local.length != e.local.length || this.children.length != e.children.length) return !1; for (let t = 0; t < this.local.length; t++)if (!this.local[t].eq(e.local[t])) return !1; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) return !1; return !0 } locals(e) { return _l(this.localsInner(e)) } localsInner(e) { if (this == se) return dn; if (e.inlineContent || !this.local.some(bt.is)) return this.local; let t = []; for (let r = 0; r < this.local.length; r++)this.local[r].type instanceof bt || t.push(this.local[r]); return t } forEachSet(e) { e(this) } } U.empty = new U([], []); U.removeOverlap = _l; const se = U.empty; class ct { constructor(e) { this.members = e } map(e, t) { const r = this.members.map(i => i.map(e, t, Ut)); return ct.from(r) } forChild(e, t) { if (t.isLeaf) return U.empty; let r = []; for (let i = 0; i < this.members.length; i++) { let s = this.members[i].forChild(e, t); s != se && (s instanceof ct ? r = r.concat(s.members) : r.push(s)) } return ct.from(r) } eq(e) { if (!(e instanceof ct) || e.members.length != this.members.length) return !1; for (let t = 0; t < this.members.length; t++)if (!this.members[t].eq(e.members[t])) return !1; return !0 } locals(e) { let t, r = !0; for (let i = 0; i < this.members.length; i++) { let s = this.members[i].localsInner(e); if (s.length) if (!t) t = s; else { r && (t = t.slice(), r = !1); for (let o = 0; o < s.length; o++)t.push(s[o]) } } return t ? _l(r ? t : t.sort(Wt)) : dn } static from(e) { switch (e.length) { case 0: return se; case 1: return e[0]; default: return new ct(e.every(t => t instanceof U) ? e : e.reduce((t, r) => t.concat(r instanceof U ? r : r.members), [])) } } forEachSet(e) { for (let t = 0; t < this.members.length; t++)this.members[t].forEachSet(e) } } function V0(n, e, t, r, i, s, o) { let l = n.slice(); for (let c = 0, u = s; c < t.maps.length; c++) { let f = 0; t.maps[c].forEach((d, p, h, g) => { let m = g - h - (p - d); for (let y = 0; y < l.length; y += 3) { let S = l[y + 1]; if (S < 0 || d > S + u - f) continue; let k = l[y] + u - f; p >= k ? l[y + 1] = d <= k ? -2 : -1 : d >= u && m && (l[y] += m, l[y + 1] += m) } f += m }), u = t.maps[c].map(u, -1) } let a = !1; for (let c = 0; c < l.length; c += 3)if (l[c + 1] < 0) { if (l[c + 1] == -2) { a = !0, l[c + 1] = -1; continue } let u = t.map(n[c] + s), f = u - i; if (f < 0 || f >= r.content.size) { a = !0; continue } let d = t.map(n[c + 1] + s, -1), p = d - i, { index: h, offset: g } = r.content.findIndex(f), m = r.maybeChild(h); if (m && g == f && g + m.nodeSize == p) { let y = l[c + 2].mapInner(t, m, u + 1, n[c] + s + 1, o); y != se ? (l[c] = f, l[c + 1] = p, l[c + 2] = y) : (l[c + 1] = -2, a = !0) } else a = !0 } if (a) { let c = U0(l, n, e, t, i, s, o), u = pi(c, r, 0, o); e = u.local; for (let f = 0; f < l.length; f += 3)l[f + 1] < 0 && (l.splice(f, 3), f -= 3); for (let f = 0, d = 0; f < u.children.length; f += 3) { let p = u.children[f]; for (; d < l.length && l[d] < p;)d += 3; l.splice(d, 0, u.children[f], u.children[f + 1], u.children[f + 2]) } } return new U(e.sort(Wt), l) } function Wd(n, e) { if (!e || !n.length) return n; let t = []; for (let r = 0; r < n.length; r++) { let i = n[r]; t.push(new xe(i.from + e, i.to + e, i.type)) } return t } function U0(n, e, t, r, i, s, o) { function l(a, c) { for (let u = 0; u < a.local.length; u++) { let f = a.local[u].map(r, i, c); f ? t.push(f) : o.onRemove && o.onRemove(a.local[u].spec) } for (let u = 0; u < a.children.length; u += 3)l(a.children[u + 2], a.children[u] + c + 1) } for (let a = 0; a < n.length; a += 3)n[a + 1] == -1 && l(n[a + 2], e[a] + s + 1); return t } function Kd(n, e, t) { if (e.isLeaf) return null; let r = t + e.nodeSize, i = null; for (let s = 0, o; s < n.length; s++)(o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null); return i } function qd(n) { let e = []; for (let t = 0; t < n.length; t++)n[t] != null && e.push(n[t]); return e } function pi(n, e, t, r) { let i = [], s = !1; e.forEach((l, a) => { let c = Kd(n, l, a + t); if (c) { s = !0; let u = pi(c, l, t + a + 1, r); u != se && i.push(a, a + l.nodeSize, u) } }); let o = Wd(s ? qd(n) : n, -t).sort(Wt); for (let l = 0; l < o.length; l++)o[l].type.valid(e, o[l]) || (r.onRemove && r.onRemove(o[l].spec), o.splice(l--, 1)); return o.length || i.length ? new U(o, i) : se } function Wt(n, e) { return n.from - e.from || n.to - e.to } function _l(n) { let e = n; for (let t = 0; t < e.length - 1; t++) { let r = e[t]; if (r.from != r.to) for (let i = t + 1; i < e.length; i++) { let s = e[i]; if (s.from == r.from) { s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), xc(e, i + 1, s.copy(r.to, s.to))); continue } else { s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), xc(e, i, r.copy(s.from, r.to))); break } } } return e } function xc(n, e, t) { for (; e < n.length && Wt(t, n[e]) > 0;)e++; n.splice(e, 0, t) } function zs(n) { let e = []; return n.someProp("decorations", t => { let r = t(n.state); r && r != se && e.push(r) }), n.cursorWrapper && e.push(U.create(n.state.doc, [n.cursorWrapper.deco])), ct.from(e) } const W0 = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, K0 = me && gt <= 11; class q0 { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(e) { this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(e) { return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset } } class J0 { constructor(e, t) { this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new q0, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver(r => { for (let i = 0; i < r.length; i++)this.queue.push(r[i]); me && gt <= 11 && r.some(i => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : re && e.composing && r.some(i => i.type == "childList" && i.target.nodeName == "TR") ? (e.input.badSafariComposition = !0, this.flushSoon()) : this.flush() }), K0 && (this.onCharData = r => { this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1, this.flush() }, 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, W0)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let e = this.observer.takeRecords(); if (e.length) { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); window.setTimeout(() => this.flush(), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50) } onSelectionChange() { if (fc(this.view)) { if (this.suppressingSelectionUpdates) return Ge(this.view); if (me && gt <= 11 && !this.view.state.selection.empty) { let e = this.view.domSelectionRange(); if (e.focusNode && en(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelectionRange()) } ignoreSelectionChange(e) { if (!e.focusNode) return !0; let t = new Set, r; for (let s = e.focusNode; s; s = kn(s))t.add(s); for (let s = e.anchorNode; s; s = kn(s))if (t.has(s)) { r = s; break } let i = r && this.view.docView.nearestDesc(r); if (i && i.ignoreMutation({ type: "selection", target: r.nodeType == 3 ? r.parentNode : r })) return this.setCurSelection(), !0 } pendingRecords() { if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e); return this.queue } flush() { let { view: e } = this; if (!e.docView || this.flushingSoon > -1) return; let t = this.pendingRecords(); t.length && (this.queue = []); let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && fc(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, l = !1, a = []; if (e.editable) for (let u = 0; u < t.length; u++) { let f = this.registerMutation(t[u], a); f && (s = s < 0 ? f.from : Math.min(f.from, s), o = o < 0 ? f.to : Math.max(f.to, o), f.typeOver && (l = !0)) } if (Te && a.length) { let u = a.filter(f => f.nodeName == "BR"); if (u.length == 2) { let [f, d] = u; f.parentNode && f.parentNode.parentNode == d.parentNode ? d.remove() : f.remove() } else { let { focusNode: f } = this.currentSelection; for (let d of u) { let p = d.parentNode; p && p.nodeName == "LI" && (!f || X0(e, f) != p) && d.remove() } } } else if ((J || re) && a.some(u => u.nodeName == "BR") && (e.input.lastKeyCode == 8 || e.input.lastKeyCode == 46)) { for (let u of a) if (u.nodeName == "BR" && u.parentNode) { let f = u.nextSibling; f && f.nodeType == 1 && f.contentEditable == "false" && u.parentNode.removeChild(u) } } let c = null; s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && cs(r) && (c = Ol(e)) && c.eq(_.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Ge(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), G0(e)), e.input.badSafariComposition && (e.input.badSafariComposition = !1, Q0(e, a)), this.handleDOMChange(s, o, l, a), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Ge(e), this.currentSelection.set(r)) } registerMutation(e, t) { if (t.indexOf(e.target) > -1) return null; let r = this.view.docView.nearestDesc(e.target); if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e)) return null; if (e.type == "childList") { for (let u = 0; u < e.addedNodes.length; u++) { let f = e.addedNodes[u]; t.push(f), f.nodeType == 3 && (this.lastChangedTextNode = f) } if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target)) return { from: r.posBefore, to: r.posAfter }; let i = e.previousSibling, s = e.nextSibling; if (me && gt <= 11 && e.addedNodes.length) for (let u = 0; u < e.addedNodes.length; u++) { let { previousSibling: f, nextSibling: d } = e.addedNodes[u]; (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f), (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (s = d) } let o = i && i.parentNode == e.target ? te(i) + 1 : 0, l = r.localPosFromDOM(e.target, o, -1), a = s && s.parentNode == e.target ? te(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, a, 1); return { from: l, to: c } } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }) } } let Sc = new WeakMap, wc = !1; function G0(n) { if (!Sc.has(n) && (Sc.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) { if (n.requiresGeckoHackNode = Te, wc) return; console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), wc = !0 } } function kc(n, e) { let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor); return en(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s } } function Y0(n, e) { if (e.getComposedRanges) { let i = e.getComposedRanges(n.root)[0]; if (i) return kc(n, i) } let t; function r(i) { i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0] } return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? kc(n, t) : null } function X0(n, e) { for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) { let r = n.docView.nearestDesc(t, !0); if (r && r.node.isBlock) return t } return null } function Q0(n, e) { var t; let { focusNode: r, focusOffset: i } = n.domSelectionRange(); for (let s of e) if (((t = s.parentNode) === null || t === void 0 ? void 0 : t.nodeName) == "TR") { let o = s.nextSibling; for (; o && o.nodeName != "TD" && o.nodeName != "TH";)o = o.nextSibling; if (o) { let l = o; for (; ;) { let a = l.firstChild; if (!a || a.nodeType != 1 || a.contentEditable == "false" || /^(BR|IMG)$/.test(a.nodeName)) break; l = a } l.insertBefore(s, l.firstChild), r == s && n.domSelection().collapse(s, i) } else s.parentNode.removeChild(s) } } function Z0(n, e, t) { let { node: r, fromOffset: i, toOffset: s, from: o, to: l } = n.docView.parseRange(e, t), a = n.domSelectionRange(), c, u = a.anchorNode; if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: a.anchorOffset }], cs(a) || c.push({ node: a.focusNode, offset: a.focusOffset })), J && n.input.lastKeyCode === 8) for (let m = s; m > i; m--) { let y = r.childNodes[m - 1], S = y.pmViewDesc; if (y.nodeName == "BR" && !S) { s = m; break } if (!S || S.size) break } let f = n.state.doc, d = n.someProp("domParser") || mt.fromSchema(n.state.schema), p = f.resolve(o), h = null, g = d.parse(r, { topNode: p.parent, topMatch: p.parent.contentMatchAt(p.index()), topOpen: !0, from: i, to: s, preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0, findPositions: c, ruleFromNode: ex, context: p }); if (c && c[0].pos != null) { let m = c[0].pos, y = c[1] && c[1].pos; y == null && (y = m), h = { anchor: m + o, head: y + o } } return { doc: g, sel: h, from: o, to: l } } function ex(n) { let e = n.pmViewDesc; if (e) return e.parseRule(); if (n.nodeName == "BR" && n.parentNode) { if (re && /^(ul|ol)$/i.test(n.parentNode.nodeName)) { let t = document.createElement("div"); return t.appendChild(document.createElement("li")), { skip: t } } else if (n.parentNode.lastChild == n || re && /^(tr|table)$/i.test(n.parentNode.nodeName)) return { ignore: !0 } } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } const tx = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i; function nx(n, e, t, r, i) { let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0); if (n.input.compositionPendingChanges = 0, e < 0) { let C = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, P = Ol(n, C); if (P && !n.state.selection.eq(P)) { if (J && qe && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", De => De(n, Nt(13, "Enter")))) return; let B = n.state.tr.setSelection(P); C == "pointer" ? B.setMeta("pointer", !0) : C == "key" && B.scrollIntoView(), s && B.setMeta("composition", s), n.dispatch(B) } return } let o = n.state.doc.resolve(e), l = o.sharedDepth(t); e = o.before(l + 1), t = n.state.doc.resolve(t).after(l + 1); let a = n.state.selection, c = Z0(n, e, t), u = n.state.doc, f = u.slice(c.from, c.to), d, p; n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (d = n.state.selection.to, p = "end") : (d = n.state.selection.from, p = "start"), n.input.lastKeyCode = null; let h = sx(f.content, c.doc.content, c.from, d, p); if (h && n.input.domChangeCount++, (En && n.input.lastIOSEnter > Date.now() - 225 || qe) && i.some(C => C.nodeType == 1 && !tx.test(C.nodeName)) && (!h || h.endA >= h.endB) && n.someProp("handleKeyDown", C => C(n, Nt(13, "Enter")))) { n.input.lastIOSEnter = 0; return } if (!h) if (r && a instanceof R && !a.empty && a.$head.sameParent(a.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head)) h = { start: a.from, endA: a.to, endB: a.to }; else { if (c.sel) { let C = Ec(n, n.state.doc, c.sel); if (C && !C.eq(n.state.selection)) { let P = n.state.tr.setSelection(C); s && P.setMeta("composition", s), n.dispatch(P) } } return } n.state.selection.from < n.state.selection.to && h.start == h.endB && n.state.selection instanceof R && (h.start > n.state.selection.from && h.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? h.start = n.state.selection.from : h.endA < n.state.selection.to && h.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (h.endB += n.state.selection.to - h.endA, h.endA = n.state.selection.to)), me && gt <= 11 && h.endB == h.start + 1 && h.endA == h.start && h.start > c.from && c.doc.textBetween(h.start - c.from - 1, h.start - c.from + 1) == " " && (h.start--, h.endA--, h.endB--); let g = c.doc.resolveNoCache(h.start - c.from), m = c.doc.resolveNoCache(h.endB - c.from), y = u.resolve(h.start), S = g.sameParent(m) && g.parent.inlineContent && y.end() >= h.endA; if ((En && n.input.lastIOSEnter > Date.now() - 225 && (!S || i.some(C => C.nodeName == "DIV" || C.nodeName == "P")) || !S && g.pos < c.doc.content.size && (!g.sameParent(m) || !g.parent.inlineContent) && g.pos < m.pos && !/\S/.test(c.doc.textBetween(g.pos, m.pos, "", ""))) && n.someProp("handleKeyDown", C => C(n, Nt(13, "Enter")))) { n.input.lastIOSEnter = 0; return } if (n.state.selection.anchor > h.start && ix(u, h.start, h.endA, g, m) && n.someProp("handleKeyDown", C => C(n, Nt(8, "Backspace")))) { qe && J && n.domObserver.suppressSelectionUpdates(); return } J && h.endB == h.start && (n.input.lastChromeDelete = Date.now()), qe && !S && g.start() != m.start() && m.parentOffset == 0 && g.depth == m.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == h.endA && (h.endB -= 2, m = c.doc.resolveNoCache(h.endB - c.from), setTimeout(() => { n.someProp("handleKeyDown", function (C) { return C(n, Nt(13, "Enter")) }) }, 20)); let k = h.start, M = h.endA, T = C => { let P = C || n.state.tr.replace(k, M, c.doc.slice(h.start - c.from, h.endB - c.from)); if (c.sel) { let B = Ec(n, P.doc, c.sel); B && !(J && n.composing && B.empty && (h.start != h.endB || n.input.lastChromeDelete < Date.now() - 100) && (B.head == k || B.head == P.mapping.map(M) - 1) || me && B.empty && B.head == k) && P.setSelection(B) } return s && P.setMeta("composition", s), P.scrollIntoView() }, D; if (S) if (g.pos == m.pos) { me && gt <= 11 && g.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => Ge(n), 20)); let C = T(n.state.tr.delete(k, M)), P = u.resolve(h.start).marksAcross(u.resolve(h.endA)); P && C.ensureMarks(P), n.dispatch(C) } else if (h.endA == h.endB && (D = rx(g.parent.content.cut(g.parentOffset, m.parentOffset), y.parent.content.cut(y.parentOffset, h.endA - y.start())))) { let C = T(n.state.tr); D.type == "add" ? C.addMark(k, M, D.mark) : C.removeMark(k, M, D.mark), n.dispatch(C) } else if (g.parent.child(g.index()).isText && g.index() == m.index() - (m.textOffset ? 0 : 1)) { let C = g.parent.textBetween(g.parentOffset, m.parentOffset), P = () => T(n.state.tr.insertText(C, k, M)); n.someProp("handleTextInput", B => B(n, k, M, C, P)) || n.dispatch(P()) } else n.dispatch(T()); else n.dispatch(T()) } function Ec(n, e, t) { return Math.max(t.anchor, t.head) > e.content.size ? null : Tl(n, e.resolve(t.anchor), e.resolve(t.head)) } function rx(n, e) { let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, l, a; for (let u = 0; u < r.length; u++)i = r[u].removeFromSet(i); for (let u = 0; u < t.length; u++)s = t[u].removeFromSet(s); if (i.length == 1 && s.length == 0) l = i[0], o = "add", a = u => u.mark(l.addToSet(u.marks)); else if (i.length == 0 && s.length == 1) l = s[0], o = "remove", a = u => u.mark(l.removeFromSet(u.marks)); else return null; let c = []; for (let u = 0; u < e.childCount; u++)c.push(a(e.child(u))); if (x.from(c).eq(n)) return { mark: l, type: o } } function ix(n, e, t, r, i) { if (t - e <= i.pos - r.pos || $s(r, !0, !1) < i.pos) return !1; let s = n.resolve(e); if (!r.parent.isTextblock) { let l = s.nodeAfter; return l != null && t == e + l.nodeSize } if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock) return !1; let o = n.resolve($s(s, !0, !0)); return !o.parent.isTextblock || o.pos > t || $s(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content) } function $s(n, e, t) { let r = n.depth, i = e ? n.end() : n.pos; for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount);)r--, i++, e = !1; if (t) { let s = n.node(r).maybeChild(n.indexAfter(r)); for (; s && !s.isLeaf;)s = s.firstChild, i++ } return i } function sx(n, e, t, r, i) { let s = n.findDiffStart(e, t); if (s == null) return null; let { a: o, b: l } = n.findDiffEnd(e, t + n.size, t + e.size); if (i == "end") { let a = Math.max(0, s - Math.min(o, l)); r -= o + a - s } if (o < s && n.size < e.size) { let a = r <= s && r >= o ? s - r : 0; s -= a, s && s < e.size && Cc(e.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), l = s + (l - o), o = s } else if (l < s) { let a = r <= s && r >= l ? s - r : 0; s -= a, s && s < n.size && Cc(n.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), o = s + (o - l), l = s } return { start: s, endA: o, endB: l } } function Cc(n) { if (n.length != 2) return !1; let e = n.charCodeAt(0), t = n.charCodeAt(1); return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319 } class Jd { constructor(e, t) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new w0, this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(Nc), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = Mc(this), Tc(this), this.nodeViews = Ac(this), this.docView = sc(this.state.doc, Oc(this), zs(this), this.dom, this), this.domObserver = new J0(this, (r, i, s, o) => nx(this, r, i, s, o)), this.domObserver.start(), k0(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let e = this._props; this._props = {}; for (let t in e) this._props[t] = e[t]; this._props.state = this.state } return this._props } update(e) { e.handleDOMEvents != this._props.handleDOMEvents && Po(this); let t = this._props; this._props = e, e.plugins && (e.plugins.forEach(Nc), this.directPlugins = e.plugins), this.updateStateInner(e.state, t) } setProps(e) { let t = {}; for (let r in this._props) t[r] = this._props[r]; t.state = this.state; for (let r in e) t[r] = e[r]; this.update(t) } updateState(e) { this.updateStateInner(e, this._props) } updateStateInner(e, t) { var r; let i = this.state, s = !1, o = !1; e.storedMarks && this.composing && (Hd(this), o = !0), this.state = e; let l = i.plugins != e.plugins || this._props.plugins != t.plugins; if (l || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) { let p = Ac(this); lx(p, this.nodeViews) && (this.nodeViews = p, s = !0) } (l || t.handleDOMEvents != this._props.handleDOMEvents) && Po(this), this.editable = Mc(this), Tc(this); let a = zs(this), c = Oc(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", f = s || !this.docView.matchesNode(e.doc, c, a); (f || !e.selection.eq(i.selection)) && (o = !0); let d = u == "preserve" && o && this.dom.style.overflowAnchor == null && Lb(this); if (o) { this.domObserver.stop(); let p = f && (me || J) && !this.composing && !i.selection.empty && !e.selection.empty && ox(i.selection, e.selection); if (f) { let h = J ? this.trackWrites = this.domSelectionRange().focusNode : null; this.composing && (this.input.compositionNode = L0(this)), (s || !this.docView.update(e.doc, c, a, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = sc(e.doc, c, a, this.dom, this)), h && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (p = !0) } p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && o0(this)) ? Ge(this, p) : (Nd(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start() } this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : d && Bb(d) } scrollToSelection() { let e = this.domSelectionRange().focusNode; if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) { if (!this.someProp("handleScrollToSelection", t => t(this))) if (this.state.selection instanceof A) { let t = this.docView.domAfterPos(this.state.selection.from); t.nodeType == 1 && Za(this, t.getBoundingClientRect(), e) } else Za(this, this.coordsAtPos(this.state.selection.head, 1), e) } } destroyPluginViews() { let e; for (; e = this.pluginViews.pop();)e.destroy && e.destroy() } updatePluginViews(e) { if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let t = 0; t < this.directPlugins.length; t++) { let r = this.directPlugins[t]; r.spec.view && this.pluginViews.push(r.spec.view(this)) } for (let t = 0; t < this.state.plugins.length; t++) { let r = this.state.plugins[t]; r.spec.view && this.pluginViews.push(r.spec.view(this)) } } else for (let t = 0; t < this.pluginViews.length; t++) { let r = this.pluginViews[t]; r.update && r.update(this, e) } } updateDraggedNode(e, t) { let r = e.node, i = -1; if (this.state.doc.nodeAt(r.from) == r.node) i = r.from; else { let s = r.from + (this.state.doc.content.size - t.doc.content.size); (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s) } this.dragging = new Vd(e.slice, e.move, i < 0 ? void 0 : A.create(this.state.doc, i)) } someProp(e, t) { let r = this._props && this._props[e], i; if (r != null && (i = t ? t(r) : r)) return i; for (let o = 0; o < this.directPlugins.length; o++) { let l = this.directPlugins[o].props[e]; if (l != null && (i = t ? t(l) : l)) return i } let s = this.state.plugins; if (s) for (let o = 0; o < s.length; o++) { let l = s[o].props[e]; if (l != null && (i = t ? t(l) : l)) return i } } hasFocus() { if (me) { let e = this.root.activeElement; if (e == this.dom) return !0; if (!e || !this.dom.contains(e)) return !1; for (; e && this.dom != e && this.dom.contains(e);) { if (e.contentEditable == "false") return !1; e = e.parentElement } return !0 } return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && Fb(this.dom), Ge(this), this.domObserver.start() } get root() { let e = this._root; if (e == null) { for (let t = this.dom.parentNode; t; t = t.parentNode)if (t.nodeType == 9 || t.nodeType == 11 && t.host) return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t } return e || document } updateRoot() { this._root = null } posAtCoords(e) { return Vb(this, e) } coordsAtPos(e, t = 1) { return wd(this, e, t) } domAtPos(e, t = 0) { return this.docView.domFromPos(e, t) } nodeDOM(e) { let t = this.docView.descAt(e); return t ? t.nodeDOM : null } posAtDOM(e, t, r = -1) { let i = this.docView.posFromDOM(e, t, r); if (i == null) throw new RangeError("DOM position not inside the editor"); return i } endOfTextblock(e, t) { return Jb(this, t || this.state, e) } pasteHTML(e, t) { return fr(this, "", e, !1, t || new ClipboardEvent("paste")) } pasteText(e, t) { return fr(this, e, null, !0, t || new ClipboardEvent("paste")) } serializeForClipboard(e) { return Ml(this, e) } destroy() { this.docView && (E0(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], zs(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, Tb()) } get isDestroyed() { return this.docView == null } dispatchEvent(e) { return O0(this, e) } domSelectionRange() { let e = this.domSelection(); return e ? re && this.root.nodeType === 11 && vb(this.dom.ownerDocument) == this.dom && Y0(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 } } domSelection() { return this.root.getSelection() } } Jd.prototype.dispatch = function (n) { let e = this._props.dispatchTransaction; e ? e.call(this, n) : this.updateState(this.state.apply(n)) }; function Oc(n) { let e = Object.create(null); return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", t => { if (typeof t == "function" && (t = t(n.state)), t) for (let r in t) r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r])) }), e.translate || (e.translate = "no"), [xe.node(0, n.state.doc.content.size, e)] } function Tc(n) { if (n.markCursor) { let e = document.createElement("img"); e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: xe.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) } } else n.cursorWrapper = null } function Mc(n) { return !n.someProp("editable", e => e(n.state) === !1) } function ox(n, e) { let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head)); return n.$anchor.start(t) != e.$anchor.start(t) } function Ac(n) { let e = Object.create(null); function t(r) { for (let i in r) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]) } return n.someProp("nodeViews", t), n.someProp("markViews", t), e } function lx(n, e) { let t = 0, r = 0; for (let i in n) { if (n[i] != e[i]) return !0; t++ } for (let i in e) r++; return t != r } function Nc(n) { if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } var wt = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, mi = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, ax = typeof navigator < "u" && /Mac/.test(navigator.platform), cx = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (var ne = 0; ne < 10; ne++)wt[48 + ne] = wt[96 + ne] = String(ne); for (var ne = 1; ne <= 24; ne++)wt[ne + 111] = "F" + ne; for (var ne = 65; ne <= 90; ne++)wt[ne] = String.fromCharCode(ne + 32), mi[ne] = String.fromCharCode(ne); for (var Hs in wt) mi.hasOwnProperty(Hs) || (mi[Hs] = wt[Hs]); function ux(n) { var e = ax && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || cx && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? mi : wt)[n.keyCode] || n.key || "Unidentified"; return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t } const fx = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), dx = typeof navigator < "u" && /Win/.test(navigator.platform); function hx(n) { let e = n.split(/-(?!$)/), t = e[e.length - 1]; t == "Space" && (t = " "); let r, i, s, o; for (let l = 0; l < e.length - 1; l++) { let a = e[l]; if (/^(cmd|meta|m)$/i.test(a)) o = !0; else if (/^a(lt)?$/i.test(a)) r = !0; else if (/^(c|ctrl|control)$/i.test(a)) i = !0; else if (/^s(hift)?$/i.test(a)) s = !0; else if (/^mod$/i.test(a)) fx ? o = !0 : i = !0; else throw new Error("Unrecognized modifier name: " + a) } return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t } function px(n) { let e = Object.create(null); for (let t in n) e[hx(t)] = n[t]; return e } function js(n, e, t = !0) { return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n } function mx(n) { return new Q({ props: { handleKeyDown: Gd(n) } }) } function Gd(n) { let e = px(n); return function (t, r) { let i = ux(r), s, o = e[js(i, r)]; if (o && o(t.state, t.dispatch, t)) return !0; if (i.length == 1 && i != " ") { if (r.shiftKey) { let l = e[js(i, r, !1)]; if (l && l(t.state, t.dispatch, t)) return !0 } if ((r.altKey || r.metaKey || r.ctrlKey) && !(dx && r.ctrlKey && r.altKey) && (s = wt[r.keyCode]) && s != i) { let l = e[js(s, r)]; if (l && l(t.state, t.dispatch, t)) return !0 } } return !1 } } const Dl = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0); function Yd(n, e) { let { $cursor: t } = n.selection; return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t } const Xd = (n, e, t) => { let r = Yd(n, t); if (!r) return !1; let i = Il(r); if (!i) { let o = r.blockRange(), l = o && _n(o); return l == null ? !1 : (e && e(n.tr.lift(o, l).scrollIntoView()), !0) } let s = i.nodeBefore; if (oh(n, i, e, -1)) return !0; if (r.parent.content.size == 0 && (Cn(s, "end") || A.isSelectable(s))) for (let o = r.depth; ; o--) { let l = ls(n.doc, r.before(o), r.after(o), E.empty); if (l && l.slice.size < l.to - l.from) { if (e) { let a = n.tr.step(l); a.setSelection(Cn(s, "end") ? _.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : A.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView()) } return !0 } if (o == 1 || r.node(o - 1).childCount > 1) break } return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1 }, gx = (n, e, t) => { let r = Yd(n, t); if (!r) return !1; let i = Il(r); return i ? Qd(n, i, e) : !1 }, yx = (n, e, t) => { let r = eh(n, t); if (!r) return !1; let i = Pl(r); return i ? Qd(n, i, e) : !1 }; function Qd(n, e, t) { let r = e.nodeBefore, i = r, s = e.pos - 1; for (; !i.isTextblock; s--) { if (i.type.spec.isolating) return !1; let u = i.lastChild; if (!u) return !1; i = u } let o = e.nodeAfter, l = o, a = e.pos + 1; for (; !l.isTextblock; a++) { if (l.type.spec.isolating) return !1; let u = l.firstChild; if (!u) return !1; l = u } let c = ls(n.doc, s, a, E.empty); if (!c || c.from != s || c instanceof q && c.slice.size >= a - s) return !1; if (t) { let u = n.tr.step(c); u.setSelection(R.create(u.doc, s)), t(u.scrollIntoView()) } return !0 } function Cn(n, e, t = !1) { for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) { if (r.isTextblock) return !0; if (t && r.childCount != 1) return !1 } return !1 } const Zd = (n, e, t) => { let { $head: r, empty: i } = n.selection, s = r; if (!i) return !1; if (r.parent.isTextblock) { if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0) return !1; s = Il(r) } let o = s && s.nodeBefore; return !o || !A.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(A.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0) }; function Il(n) { if (!n.parent.type.spec.isolating) for (let e = n.depth - 1; e >= 0; e--) { if (n.index(e) > 0) return n.doc.resolve(n.before(e + 1)); if (n.node(e).type.spec.isolating) break } return null } function eh(n, e) { let { $cursor: t } = n.selection; return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t } const th = (n, e, t) => { let r = eh(n, t); if (!r) return !1; let i = Pl(r); if (!i) return !1; let s = i.nodeAfter; if (oh(n, i, e, 1)) return !0; if (r.parent.content.size == 0 && (Cn(s, "start") || A.isSelectable(s))) { let o = ls(n.doc, r.before(), r.after(), E.empty); if (o && o.slice.size < o.to - o.from) { if (e) { let l = n.tr.step(o); l.setSelection(Cn(s, "start") ? _.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : A.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView()) } return !0 } } return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1 }, nh = (n, e, t) => { let { $head: r, empty: i } = n.selection, s = r; if (!i) return !1; if (r.parent.isTextblock) { if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size) return !1; s = Pl(r) } let o = s && s.nodeAfter; return !o || !A.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(A.create(n.doc, s.pos)).scrollIntoView()), !0) }; function Pl(n) { if (!n.parent.type.spec.isolating) for (let e = n.depth - 1; e >= 0; e--) { let t = n.node(e); if (n.index(e) + 1 < t.childCount) return n.doc.resolve(n.after(e + 1)); if (t.type.spec.isolating) break } return null } const bx = (n, e) => { let t = n.selection, r = t instanceof A, i; if (r) { if (t.node.isTextblock || !Et(n.doc, t.from)) return !1; i = t.from } else if (i = ss(n.doc, t.from, -1), i == null) return !1; if (e) { let s = n.tr.join(i); r && s.setSelection(A.create(s.doc, i - n.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView()) } return !0 }, xx = (n, e) => { let t = n.selection, r; if (t instanceof A) { if (t.node.isTextblock || !Et(n.doc, t.to)) return !1; r = t.to } else if (r = ss(n.doc, t.to, 1), r == null) return !1; return e && e(n.tr.join(r).scrollIntoView()), !0 }, Sx = (n, e) => { let { $from: t, $to: r } = n.selection, i = t.blockRange(r), s = i && _n(i); return s == null ? !1 : (e && e(n.tr.lift(i, s).scrollIntoView()), !0) }, rh = (n, e) => {
  let { $head: t, $anchor: r } = n.selection; return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0)
}; function Ll(n) { for (let e = 0; e < n.edgeCount; e++) { let { type: t } = n.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } const wx = (n, e) => { let { $head: t, $anchor: r } = n.selection; if (!t.parent.type.spec.code || !t.sameParent(r)) return !1; let i = t.node(-1), s = t.indexAfter(-1), o = Ll(i.contentMatchAt(s)); if (!o || !i.canReplaceWith(s, s, o)) return !1; if (e) { let l = t.after(), a = n.tr.replaceWith(l, l, o.createAndFill()); a.setSelection(_.near(a.doc.resolve(l), 1)), e(a.scrollIntoView()) } return !0 }, ih = (n, e) => { let t = n.selection, { $from: r, $to: i } = t; if (t instanceof Se || r.parent.inlineContent || i.parent.inlineContent) return !1; let s = Ll(i.parent.contentMatchAt(i.indexAfter())); if (!s || !s.isTextblock) return !1; if (e) { let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(o, s.createAndFill()); l.setSelection(R.create(l.doc, o + 1)), e(l.scrollIntoView()) } return !0 }, sh = (n, e) => { let { $cursor: t } = n.selection; if (!t || t.parent.content.size) return !1; if (t.depth > 1 && t.after() != t.end(-1)) { let s = t.before(); if (Je(n.doc, s)) return e && e(n.tr.split(s).scrollIntoView()), !0 } let r = t.blockRange(), i = r && _n(r); return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0) }; function kx(n) { return (e, t) => { let { $from: r, $to: i } = e.selection; if (e.selection instanceof A && e.selection.node.isBlock) return !r.parentOffset || !Je(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0); if (!r.depth) return !1; let s = [], o, l, a = !1, c = !1; for (let p = r.depth; ; p--)if (r.node(p).isBlock) { a = r.end(p) == r.pos + (r.depth - p), c = r.start(p) == r.pos - (r.depth - p), l = Ll(r.node(p - 1).contentMatchAt(r.indexAfter(p - 1))), s.unshift(a && l ? { type: l } : null), o = p; break } else { if (p == 1) return !1; s.unshift(null) } let u = e.tr; (e.selection instanceof R || e.selection instanceof Se) && u.deleteSelection(); let f = u.mapping.map(r.pos), d = Je(u.doc, f, s.length, s); if (d || (s[0] = l ? { type: l } : null, d = Je(u.doc, f, s.length, s)), !d) return !1; if (u.split(f, s.length, s), !a && c && r.node(o).type != l) { let p = u.mapping.map(r.before(o)), h = u.doc.resolve(p); l && r.node(o - 1).canReplaceWith(h.index(), h.index() + 1, l) && u.setNodeMarkup(u.mapping.map(r.before(o)), l) } return t && t(u.scrollIntoView()), !0 } } const Ex = kx(), Cx = (n, e) => { let { $from: t, to: r } = n.selection, i, s = t.sharedDepth(r); return s == 0 ? !1 : (i = t.before(s), e && e(n.tr.setSelection(A.create(n.doc, i))), !0) }; function Ox(n, e, t) { let r = e.nodeBefore, i = e.nodeAfter, s = e.index(); return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Et(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0) } function oh(n, e, t, r) { let i = e.nodeBefore, s = e.nodeAfter, o, l, a = i.type.spec.isolating || s.type.spec.isolating; if (!a && Ox(n, e, t)) return !0; let c = !a && e.parent.canReplace(e.index(), e.index() + 1); if (c && (o = (l = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && l.matchType(o[0] || s.type).validEnd) { if (t) { let p = e.pos + s.nodeSize, h = x.empty; for (let y = o.length - 1; y >= 0; y--)h = x.from(o[y].create(null, h)); h = x.from(i.copy(h)); let g = n.tr.step(new G(e.pos - 1, p, e.pos, p, new E(h, 1, 0), o.length, !0)), m = g.doc.resolve(p + 2 * o.length); m.nodeAfter && m.nodeAfter.type == i.type && Et(g.doc, m.pos) && g.join(m.pos), t(g.scrollIntoView()) } return !0 } let u = s.type.spec.isolating || r > 0 && a ? null : _.findFrom(e, 1), f = u && u.$from.blockRange(u.$to), d = f && _n(f); if (d != null && d >= e.depth) return t && t(n.tr.lift(f, d).scrollIntoView()), !0; if (c && Cn(s, "start", !0) && Cn(i, "end")) { let p = i, h = []; for (; h.push(p), !p.isTextblock;)p = p.lastChild; let g = s, m = 1; for (; !g.isTextblock; g = g.firstChild)m++; if (p.canReplace(p.childCount, p.childCount, g.content)) { if (t) { let y = x.empty; for (let k = h.length - 1; k >= 0; k--)y = x.from(h[k].copy(y)); let S = n.tr.step(new G(e.pos - h.length, e.pos + s.nodeSize, e.pos + m, e.pos + s.nodeSize - m, new E(y, h.length, 0), 0, !0)); t(S.scrollIntoView()) } return !0 } } return !1 } function lh(n) { return function (e, t) { let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth; for (; i.node(s).isInline;) { if (!s) return !1; s-- } return i.node(s).isTextblock ? (t && t(e.tr.setSelection(R.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1 } } const Tx = lh(-1), Mx = lh(1); function Ax(n, e = null) { return function (t, r) { let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = o && kl(o, n, e); return l ? (r && r(t.tr.wrap(o, l).scrollIntoView()), !0) : !1 } } function Rc(n, e = null) { return function (t, r) { let i = !1; for (let s = 0; s < t.selection.ranges.length && !i; s++) { let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[s]; t.doc.nodesBetween(o, l, (a, c) => { if (i) return !1; if (!(!a.isTextblock || a.hasMarkup(n, e))) if (a.type == n) i = !0; else { let u = t.doc.resolve(c), f = u.index(); i = u.parent.canReplaceWith(f, f + 1, n) } }) } if (!i) return !1; if (r) { let s = t.tr; for (let o = 0; o < t.selection.ranges.length; o++) { let { $from: { pos: l }, $to: { pos: a } } = t.selection.ranges[o]; s.setBlockType(l, a, n, e) } r(s.scrollIntoView()) } return !0 } } function Bl(...n) { return function (e, t, r) { for (let i = 0; i < n.length; i++)if (n[i](e, t, r)) return !0; return !1 } } Bl(Dl, Xd, Zd); Bl(Dl, th, nh); Bl(rh, ih, sh, Ex); typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin"; function Nx(n, e = null) { return function (t, r) { let { $from: i, $to: s } = t.selection, o = i.blockRange(s); if (!o) return !1; let l = r ? t.tr : null; return Rx(l, o, n, e) ? (r && r(l.scrollIntoView()), !0) : !1 } } function Rx(n, e, t, r = null) { let i = !1, s = e, o = e.$from.doc; if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) { if (e.$from.index(e.depth - 1) == 0) return !1; let a = o.resolve(e.start - 2); s = new ai(a, a, e.depth), e.endIndex < e.parent.childCount && (e = new ai(e.$from, o.resolve(e.$to.end(e.depth)), e.depth)), i = !0 } let l = kl(s, t, r, e); return l ? (n && vx(n, e, l, i, t), !0) : !1 } function vx(n, e, t, r, i) { let s = x.empty; for (let u = t.length - 1; u >= 0; u--)s = x.from(t[u].type.create(t[u].attrs, s)); n.step(new G(e.start - (r ? 2 : 0), e.end, e.start, e.end, new E(s, 0, 0), t.length, !0)); let o = 0; for (let u = 0; u < t.length; u++)t[u].type == i && (o = u + 1); let l = t.length - o, a = e.start + t.length - (r ? 2 : 0), c = e.parent; for (let u = e.startIndex, f = e.endIndex, d = !0; u < f; u++, d = !1)!d && Je(n.doc, a, l) && (n.split(a, l), a += 2 * l), a += c.child(u).nodeSize; return n } function _x(n) { return function (e, t) { let { $from: r, $to: i } = e.selection, s = r.blockRange(i, o => o.childCount > 0 && o.firstChild.type == n); return s ? t ? r.node(s.depth - 1).type == n ? Dx(e, t, n, s) : Ix(e, t, s) : !0 : !1 } } function Dx(n, e, t, r) { let i = n.tr, s = r.end, o = r.$to.end(r.depth); s < o && (i.step(new G(s - 1, o, s, o, new E(x.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new ai(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth)); const l = _n(r); if (l == null) return !1; i.lift(r, l); let a = i.doc.resolve(i.mapping.map(s, -1) - 1); return Et(i.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && i.join(a.pos), e(i.scrollIntoView()), !0 } function Ix(n, e, t) { let r = n.tr, i = t.parent; for (let p = t.end, h = t.endIndex - 1, g = t.startIndex; h > g; h--)p -= i.child(h).nodeSize, r.delete(p - 1, p + 1); let s = r.doc.resolve(t.start), o = s.nodeAfter; if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize) return !1; let l = t.startIndex == 0, a = t.endIndex == i.childCount, c = s.node(-1), u = s.index(-1); if (!c.canReplace(u + (l ? 0 : 1), u + 1, o.content.append(a ? x.empty : x.from(i)))) return !1; let f = s.pos, d = f + o.nodeSize; return r.step(new G(f - (l ? 1 : 0), d + (a ? 1 : 0), f + 1, d - 1, new E((l ? x.empty : x.from(i.copy(x.empty))).append(a ? x.empty : x.from(i.copy(x.empty))), l ? 0 : 1, a ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0 } function Px(n) { return function (e, t) { let { $from: r, $to: i } = e.selection, s = r.blockRange(i, c => c.childCount > 0 && c.firstChild.type == n); if (!s) return !1; let o = s.startIndex; if (o == 0) return !1; let l = s.parent, a = l.child(o - 1); if (a.type != n) return !1; if (t) { let c = a.lastChild && a.lastChild.type == l.type, u = x.from(c ? n.create() : null), f = new E(x.from(n.create(null, x.from(l.type.create(null, u)))), c ? 3 : 1, 0), d = s.start, p = s.end; t(e.tr.step(new G(d - (c ? 3 : 1), p, d, p, f, 1, !0)).scrollIntoView()) } return !0 } } function ds(n) { const { state: e, transaction: t } = n; let { selection: r } = t, { doc: i } = t, { storedMarks: s } = t; return { ...e, apply: e.apply.bind(e), applyTransaction: e.applyTransaction.bind(e), plugins: e.plugins, schema: e.schema, reconfigure: e.reconfigure.bind(e), toJSON: e.toJSON.bind(e), get storedMarks() { return s }, get selection() { return r }, get doc() { return i }, get tr() { return r = t.selection, i = t.doc, s = t.storedMarks, t } } } class hs { constructor(e) { this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state } get hasCustomState() { return !!this.customState } get state() { return this.customState || this.editor.state } get commands() { const { rawCommands: e, editor: t, state: r } = this, { view: i } = t, { tr: s } = r, o = this.buildProps(s); return Object.fromEntries(Object.entries(e).map(([l, a]) => [l, (...u) => { const f = a(...u)(o); return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), f }])) } get chain() { return () => this.createChain() } get can() { return () => this.createCan() } createChain(e, t = !0) { const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, l = [], a = !!e, c = e || s.tr, u = () => (!a && t && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), l.every(d => d === !0)), f = { ...Object.fromEntries(Object.entries(r).map(([d, p]) => [d, (...g) => { const m = this.buildProps(c, t), y = p(...g)(m); return l.push(y), f }])), run: u }; return f } createCan(e) { const { rawCommands: t, state: r } = this, i = !1, s = e || r.tr, o = this.buildProps(s, i); return { ...Object.fromEntries(Object.entries(t).map(([a, c]) => [a, (...u) => c(...u)({ ...o, dispatch: void 0 })])), chain: () => this.createChain(s, i) } } buildProps(e, t = !0) { const { rawCommands: r, editor: i, state: s } = this, { view: o } = i, l = { tr: e, editor: i, view: o, state: ds({ state: s, transaction: e }), dispatch: t ? () => { } : void 0, chain: () => this.createChain(e, t), can: () => this.createCan(e), get commands() { return Object.fromEntries(Object.entries(r).map(([a, c]) => [a, (...u) => c(...u)(l)])) } }; return l } } class Lx { constructor() { this.callbacks = {} } on(e, t) { return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this } emit(e, ...t) { const r = this.callbacks[e]; return r && r.forEach(i => i.apply(this, t)), this } off(e, t) { const r = this.callbacks[e]; return r && (t ? this.callbacks[e] = r.filter(i => i !== t) : delete this.callbacks[e]), this } once(e, t) { const r = (...i) => { this.off(e, r), t.apply(this, i) }; return this.on(e, r) } removeAllListeners() { this.callbacks = {} } } function O(n, e, t) { return n.config[e] === void 0 && n.parent ? O(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({ ...t, parent: n.parent ? O(n.parent, e, t) : null }) : n.config[e] } function ps(n) { const e = n.filter(i => i.type === "extension"), t = n.filter(i => i.type === "node"), r = n.filter(i => i.type === "mark"); return { baseExtensions: e, nodeExtensions: t, markExtensions: r } } function ah(n) { const e = [], { nodeExtensions: t, markExtensions: r } = ps(n), i = [...t, ...r], s = { default: null, rendered: !0, renderHTML: null, parseHTML: null, keepOnSplit: !0, isRequired: !1 }; return n.forEach(o => { const l = { name: o.name, options: o.options, storage: o.storage, extensions: i }, a = O(o, "addGlobalAttributes", l); if (!a) return; a().forEach(u => { u.types.forEach(f => { Object.entries(u.attributes).forEach(([d, p]) => { e.push({ type: f, name: d, attribute: { ...s, ...p } }) }) }) }) }), i.forEach(o => { const l = { name: o.name, options: o.options, storage: o.storage }, a = O(o, "addAttributes", l); if (!a) return; const c = a(); Object.entries(c).forEach(([u, f]) => { const d = { ...s, ...f }; typeof d?.default == "function" && (d.default = d.default()), d?.isRequired && d?.default === void 0 && delete d.default, e.push({ type: o.name, name: u, attribute: d }) }) }), e } function X(n, e) { if (typeof n == "string") { if (!e.nodes[n]) throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`); return e.nodes[n] } return n } function ie(...n) { return n.filter(e => !!e).reduce((e, t) => { const r = { ...e }; return Object.entries(t).forEach(([i, s]) => { if (!r[i]) { r[i] = s; return } if (i === "class") { const l = s ? String(s).split(" ") : [], a = r[i] ? r[i].split(" ") : [], c = l.filter(u => !a.includes(u)); r[i] = [...a, ...c].join(" ") } else if (i === "style") { const l = s ? s.split(";").map(u => u.trim()).filter(Boolean) : [], a = r[i] ? r[i].split(";").map(u => u.trim()).filter(Boolean) : [], c = new Map; a.forEach(u => { const [f, d] = u.split(":").map(p => p.trim()); c.set(f, d) }), l.forEach(u => { const [f, d] = u.split(":").map(p => p.trim()); c.set(f, d) }), r[i] = Array.from(c.entries()).map(([u, f]) => `${u}: ${f}`).join("; ") } else r[i] = s }), r }, {}) } function Lo(n, e) { return e.filter(t => t.type === n.type.name).filter(t => t.attribute.rendered).map(t => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : { [t.name]: n.attrs[t.name] }).reduce((t, r) => ie(t, r), {}) } function ch(n) { return typeof n == "function" } function I(n, e = void 0, ...t) { return ch(n) ? e ? n.bind(e)(...t) : n(...t) : n } function Bx(n = {}) { return Object.keys(n).length === 0 && n.constructor === Object } function Fx(n) { return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n } function vc(n, e) { return "style" in n ? n : { ...n, getAttrs: t => { const r = n.getAttrs ? n.getAttrs(t) : n.attrs; if (r === !1) return !1; const i = e.reduce((s, o) => { const l = o.attribute.parseHTML ? o.attribute.parseHTML(t) : Fx(t.getAttribute(o.name)); return l == null ? s : { ...s, [o.name]: l } }, {}); return { ...r, ...i } } } } function _c(n) { return Object.fromEntries(Object.entries(n).filter(([e, t]) => e === "attrs" && Bx(t) ? !1 : t != null)) } function zx(n, e) { var t; const r = ah(n), { nodeExtensions: i, markExtensions: s } = ps(n), o = (t = i.find(c => O(c, "topNode"))) === null || t === void 0 ? void 0 : t.name, l = Object.fromEntries(i.map(c => { const u = r.filter(y => y.type === c.name), f = { name: c.name, options: c.options, storage: c.storage, editor: e }, d = n.reduce((y, S) => { const k = O(S, "extendNodeSchema", f); return { ...y, ...k ? k(c) : {} } }, {}), p = _c({ ...d, content: I(O(c, "content", f)), marks: I(O(c, "marks", f)), group: I(O(c, "group", f)), inline: I(O(c, "inline", f)), atom: I(O(c, "atom", f)), selectable: I(O(c, "selectable", f)), draggable: I(O(c, "draggable", f)), code: I(O(c, "code", f)), whitespace: I(O(c, "whitespace", f)), linebreakReplacement: I(O(c, "linebreakReplacement", f)), defining: I(O(c, "defining", f)), isolating: I(O(c, "isolating", f)), attrs: Object.fromEntries(u.map(y => { var S; return [y.name, { default: (S = y?.attribute) === null || S === void 0 ? void 0 : S.default }] })) }), h = I(O(c, "parseHTML", f)); h && (p.parseDOM = h.map(y => vc(y, u))); const g = O(c, "renderHTML", f); g && (p.toDOM = y => g({ node: y, HTMLAttributes: Lo(y, u) })); const m = O(c, "renderText", f); return m && (p.toText = m), [c.name, p] })), a = Object.fromEntries(s.map(c => { const u = r.filter(m => m.type === c.name), f = { name: c.name, options: c.options, storage: c.storage, editor: e }, d = n.reduce((m, y) => { const S = O(y, "extendMarkSchema", f); return { ...m, ...S ? S(c) : {} } }, {}), p = _c({ ...d, inclusive: I(O(c, "inclusive", f)), excludes: I(O(c, "excludes", f)), group: I(O(c, "group", f)), spanning: I(O(c, "spanning", f)), code: I(O(c, "code", f)), attrs: Object.fromEntries(u.map(m => { var y; return [m.name, { default: (y = m?.attribute) === null || y === void 0 ? void 0 : y.default }] })) }), h = I(O(c, "parseHTML", f)); h && (p.parseDOM = h.map(m => vc(m, u))); const g = O(c, "renderHTML", f); return g && (p.toDOM = m => g({ mark: m, HTMLAttributes: Lo(m, u) })), [c.name, p] })); return new Gf({ topNode: o, nodes: l, marks: a }) } function Vs(n, e) { return e.nodes[n] || e.marks[n] || null } function Dc(n, e) { return Array.isArray(e) ? e.some(t => (typeof t == "string" ? t : t.name) === n.name) : e } function Fl(n, e) { const t = on.fromSchema(e).serializeFragment(n), i = document.implementation.createHTMLDocument().createElement("div"); return i.appendChild(t), i.innerHTML } const $x = (n, e = 500) => { let t = ""; const r = n.parentOffset; return n.parent.nodesBetween(Math.max(0, r - e), r, (i, s, o, l) => { var a, c; const u = ((c = (a = i.type.spec).toText) === null || c === void 0 ? void 0 : c.call(a, { node: i, pos: s, parent: o, index: l })) || i.textContent || "%leaf%"; t += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, r - s)) }), t }; function zl(n) { return Object.prototype.toString.call(n) === "[object RegExp]" } class ms { constructor(e) { this.find = e.find, this.handler = e.handler } } const Hx = (n, e) => { if (zl(e)) return e.exec(n); const t = e(n); if (!t) return null; const r = [t.text]; return r.index = t.index, r.input = n, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r }; function Fr(n) { var e; const { editor: t, from: r, to: i, text: s, rules: o, plugin: l } = n, { view: a } = t; if (a.composing) return !1; const c = a.state.doc.resolve(r); if (c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find(d => d.type.spec.code)) return !1; let u = !1; const f = $x(c) + s; return o.forEach(d => { if (u) return; const p = Hx(f, d.find); if (!p) return; const h = a.state.tr, g = ds({ state: a.state, transaction: h }), m = { from: r - (p[0].length - s.length), to: i }, { commands: y, chain: S, can: k } = new hs({ editor: t, state: g }); d.handler({ state: g, range: m, match: p, commands: y, chain: S, can: k }) === null || !h.steps.length || (h.setMeta(l, { transform: h, from: r, to: i, text: s }), a.dispatch(h), u = !0) }), u } function jx(n) {
  const { editor: e, rules: t } = n, r = new Q({
    state: { init() { return null }, apply(i, s, o) { const l = i.getMeta(r); if (l) return l; const a = i.getMeta("applyInputRules"); return a && setTimeout(() => { let { text: u } = a; typeof u == "string" ? u = u : u = Fl(x.from(u), o.schema); const { from: f } = a, d = f + u.length; Fr({ editor: e, from: f, to: d, text: u, rules: t, plugin: r }) }), i.selectionSet || i.docChanged ? null : s } }, props: {
      handleTextInput(i, s, o, l) { return Fr({ editor: e, from: s, to: o, text: l, rules: t, plugin: r }) }, handleDOMEvents: { compositionend: i => (setTimeout(() => { const { $cursor: s } = i.state.selection; s && Fr({ editor: e, from: s.pos, to: s.pos, text: "", rules: t, plugin: r }) }), !1) }, handleKeyDown(i, s) {
        if (s.key !== "Enter") return !1; const { $cursor: o } = i.state.selection; return o ? Fr({
          editor: e, from: o.pos, to: o.pos, text: `
`, rules: t, plugin: r
        }) : !1
      }
    }, isInputRules: !0
  }); return r
} function Vx(n) { return Object.prototype.toString.call(n).slice(8, -1) } function zr(n) { return Vx(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype } function gs(n, e) { const t = { ...n }; return zr(n) && zr(e) && Object.keys(e).forEach(r => { zr(e[r]) && zr(n[r]) ? t[r] = gs(n[r], e[r]) : t[r] = e[r] }), t } class Xe { constructor(e = {}) { this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = I(O(this, "addOptions", { name: this.name }))), this.storage = I(O(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Xe(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => gs(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new Xe(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = I(O(t, "addOptions", { name: t.name })), t.storage = I(O(t, "addStorage", { name: t.name, options: t.options })), t } static handleExit({ editor: e, mark: t }) { const { tr: r } = e.state, i = e.state.selection.$from; if (i.pos === i.end()) { const o = i.marks(); if (!!!o.find(c => c?.type.name === t.name)) return !1; const a = o.find(c => c?.type.name === t.name); return a && r.removeStoredMark(a), r.insertText(" ", i.pos), e.view.dispatch(r), !0 } return !1 } } function Ux(n) { return typeof n == "number" } class Wx { constructor(e) { this.find = e.find, this.handler = e.handler } } const Kx = (n, e, t) => { if (zl(e)) return [...n.matchAll(e)]; const r = e(n, t); return r ? r.map(i => { const s = [i.text]; return s.index = i.index, s.input = n, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s }) : [] }; function qx(n) { const { editor: e, state: t, from: r, to: i, rule: s, pasteEvent: o, dropEvent: l } = n, { commands: a, chain: c, can: u } = new hs({ editor: e, state: t }), f = []; return t.doc.nodesBetween(r, i, (p, h) => { if (!p.isTextblock || p.type.spec.code) return; const g = Math.max(r, h), m = Math.min(i, h + p.content.size), y = p.textBetween(g - h, m - h, void 0, ""); Kx(y, s.find, o).forEach(k => { if (k.index === void 0) return; const M = g + k.index + 1, T = M + k[0].length, D = { from: t.tr.mapping.map(M), to: t.tr.mapping.map(T) }, C = s.handler({ state: t, range: D, match: k, commands: a, chain: c, can: u, pasteEvent: o, dropEvent: l }); f.push(C) }) }), f.every(p => p !== null) } let $r = null; const Jx = n => { var e; const t = new ClipboardEvent("paste", { clipboardData: new DataTransfer }); return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", n), t }; function Gx(n) { const { editor: e, rules: t } = n; let r = null, i = !1, s = !1, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, l; try { l = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { l = null } const a = ({ state: u, from: f, to: d, rule: p, pasteEvt: h }) => { const g = u.tr, m = ds({ state: u, transaction: g }); if (!(!qx({ editor: e, state: m, from: Math.max(f - 1, 0), to: d.b - 1, rule: p, pasteEvent: h, dropEvent: l }) || !g.steps.length)) { try { l = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { l = null } return o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, g } }; return t.map(u => new Q({ view(f) { const d = h => { var g; r = !((g = f.dom.parentElement) === null || g === void 0) && g.contains(h.target) ? f.dom.parentElement : null, r && ($r = e) }, p = () => { $r && ($r = null) }; return window.addEventListener("dragstart", d), window.addEventListener("dragend", p), { destroy() { window.removeEventListener("dragstart", d), window.removeEventListener("dragend", p) } } }, props: { handleDOMEvents: { drop: (f, d) => { if (s = r === f.dom.parentElement, l = d, !s) { const p = $r; p?.isEditable && setTimeout(() => { const h = p.state.selection; h && p.commands.deleteRange({ from: h.from, to: h.to }) }, 10) } return !1 }, paste: (f, d) => { var p; const h = (p = d.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html"); return o = d, i = !!h?.includes("data-pm-slice"), !1 } } }, appendTransaction: (f, d, p) => { const h = f[0], g = h.getMeta("uiEvent") === "paste" && !i, m = h.getMeta("uiEvent") === "drop" && !s, y = h.getMeta("applyPasteRules"), S = !!y; if (!g && !m && !S) return; if (S) { let { text: T } = y; typeof T == "string" ? T = T : T = Fl(x.from(T), p.schema); const { from: D } = y, C = D + T.length, P = Jx(T); return a({ rule: u, state: p, from: D, to: { b: C }, pasteEvt: P }) } const k = d.doc.content.findDiffStart(p.doc.content), M = d.doc.content.findDiffEnd(p.doc.content); if (!(!Ux(k) || !M || k === M.b)) return a({ rule: u, state: p, from: k, to: M, pasteEvt: o }) } })) } function Yx(n) { const e = n.filter((t, r) => n.indexOf(t) !== r); return Array.from(new Set(e)) } class mn { constructor(e, t) { this.splittableMarks = [], this.editor = t, this.extensions = mn.resolve(e), this.schema = zx(this.extensions, t), this.setupExtensions() } static resolve(e) { const t = mn.sort(mn.flatten(e)), r = Yx(t.map(i => i.name)); return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map(i => `'${i}'`).join(", ")}]. This can lead to issues.`), t } static flatten(e) { return e.map(t => { const r = { name: t.name, options: t.options, storage: t.storage }, i = O(t, "addExtensions", r); return i ? [t, ...this.flatten(i())] : t }).flat(10) } static sort(e) { return e.sort((r, i) => { const s = O(r, "priority") || 100, o = O(i, "priority") || 100; return s > o ? -1 : s < o ? 1 : 0 }) } get commands() { return this.extensions.reduce((e, t) => { const r = { name: t.name, options: t.options, storage: t.storage, editor: this.editor, type: Vs(t.name, this.schema) }, i = O(t, "addCommands", r); return i ? { ...e, ...i() } : e }, {}) } get plugins() { const { editor: e } = this, t = mn.sort([...this.extensions].reverse()), r = [], i = [], s = t.map(o => { const l = { name: o.name, options: o.options, storage: o.storage, editor: e, type: Vs(o.name, this.schema) }, a = [], c = O(o, "addKeyboardShortcuts", l); let u = {}; if (o.type === "mark" && O(o, "exitable", l) && (u.ArrowRight = () => Xe.handleExit({ editor: e, mark: o })), c) { const g = Object.fromEntries(Object.entries(c()).map(([m, y]) => [m, () => y({ editor: e })])); u = { ...u, ...g } } const f = mx(u); a.push(f); const d = O(o, "addInputRules", l); Dc(o, e.options.enableInputRules) && d && r.push(...d()); const p = O(o, "addPasteRules", l); Dc(o, e.options.enablePasteRules) && p && i.push(...p()); const h = O(o, "addProseMirrorPlugins", l); if (h) { const g = h(); a.push(...g) } return a }).flat(); return [jx({ editor: e, rules: r }), ...Gx({ editor: e, rules: i }), ...s] } get attributes() { return ah(this.extensions) } get nodeViews() { const { editor: e } = this, { nodeExtensions: t } = ps(this.extensions); return Object.fromEntries(t.filter(r => !!O(r, "addNodeView")).map(r => { const i = this.attributes.filter(a => a.type === r.name), s = { name: r.name, options: r.options, storage: r.storage, editor: e, type: X(r.name, this.schema) }, o = O(r, "addNodeView", s); if (!o) return []; const l = (a, c, u, f, d) => { const p = Lo(a, i); return o()({ node: a, view: c, getPos: u, decorations: f, innerDecorations: d, editor: e, extension: r, HTMLAttributes: p }) }; return [r.name, l] })) } setupExtensions() { this.extensions.forEach(e => { var t; this.editor.extensionStorage[e.name] = e.storage; const r = { name: e.name, options: e.options, storage: e.storage, editor: this.editor, type: Vs(e.name, this.schema) }; e.type === "mark" && (!((t = I(O(e, "keepOnSplit", r))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name); const i = O(e, "onBeforeCreate", r), s = O(e, "onCreate", r), o = O(e, "onUpdate", r), l = O(e, "onSelectionUpdate", r), a = O(e, "onTransaction", r), c = O(e, "onFocus", r), u = O(e, "onBlur", r), f = O(e, "onDestroy", r); i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), o && this.editor.on("update", o), l && this.editor.on("selectionUpdate", l), a && this.editor.on("transaction", a), c && this.editor.on("focus", c), u && this.editor.on("blur", u), f && this.editor.on("destroy", f) }) } } class le { constructor(e = {}) { this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = I(O(this, "addOptions", { name: this.name }))), this.storage = I(O(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new le(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => gs(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new le({ ...this.config, ...e }); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = I(O(t, "addOptions", { name: t.name })), t.storage = I(O(t, "addStorage", { name: t.name, options: t.options })), t } } function uh(n, e, t) {
  const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = t || {}; let l = ""; return n.nodesBetween(r, i, (a, c, u, f) => { var d; a.isBlock && c > r && (l += s); const p = o?.[a.type.name]; if (p) return u && (l += p({ node: a, pos: c, parent: u, index: f, range: e })), !1; a.isText && (l += (d = a?.text) === null || d === void 0 ? void 0 : d.slice(Math.max(r, c) - c, i - c)) }), l
} function fh(n) { return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText])) } const Xx = le.create({ name: "clipboardTextSerializer", addOptions() { return { blockSeparator: void 0 } }, addProseMirrorPlugins() { return [new Q({ key: new ye("clipboardTextSerializer"), props: { clipboardTextSerializer: () => { const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: i } = e, { ranges: s } = i, o = Math.min(...s.map(u => u.$from.pos)), l = Math.max(...s.map(u => u.$to.pos)), a = fh(t); return uh(r, { from: o, to: l }, { ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}, textSerializers: a }) } } })] } }), Qx = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => { var t; n.isDestroyed || (e.dom.blur(), (t = window?.getSelection()) === null || t === void 0 || t.removeAllRanges()) }), !0), Zx = (n = !1) => ({ commands: e }) => e.setContent("", n), e1 = () => ({ state: n, tr: e, dispatch: t }) => { const { selection: r } = e, { ranges: i } = r; return t && i.forEach(({ $from: s, $to: o }) => { n.doc.nodesBetween(s.pos, o.pos, (l, a) => { if (l.type.isText) return; const { doc: c, mapping: u } = e, f = c.resolve(u.map(a)), d = c.resolve(u.map(a + l.nodeSize)), p = f.blockRange(d); if (!p) return; const h = _n(p); if (l.type.isTextblock) { const { defaultType: g } = f.parent.contentMatchAt(f.index()); e.setNodeMarkup(p.start, g) } (h || h === 0) && e.lift(p, h) }) }), !0 }, t1 = n => e => n(e), n1 = () => ({ state: n, dispatch: e }) => ih(n, e), r1 = (n, e) => ({ editor: t, tr: r }) => { const { state: i } = t, s = i.doc.slice(n.from, n.to); r.deleteRange(n.from, n.to); const o = r.mapping.map(e); return r.insert(o, s.content), r.setSelection(new R(r.doc.resolve(Math.max(o - 1, 0)))), !0 }, i1 = () => ({ tr: n, dispatch: e }) => { const { selection: t } = n, r = t.$anchor.node(); if (r.content.size > 0) return !1; const i = n.selection.$anchor; for (let s = i.depth; s > 0; s -= 1)if (i.node(s).type === r.type) { if (e) { const l = i.before(s), a = i.after(s); n.delete(l, a).scrollIntoView() } return !0 } return !1 }, s1 = n => ({ tr: e, state: t, dispatch: r }) => { const i = X(n, t.schema), s = e.selection.$anchor; for (let o = s.depth; o > 0; o -= 1)if (s.node(o).type === i) { if (r) { const a = s.before(o), c = s.after(o); e.delete(a, c).scrollIntoView() } return !0 } return !1 }, o1 = n => ({ tr: e, dispatch: t }) => { const { from: r, to: i } = n; return t && e.delete(r, i), !0 }, l1 = () => ({ state: n, dispatch: e }) => Dl(n, e), a1 = () => ({ commands: n }) => n.keyboardShortcut("Enter"), c1 = () => ({ state: n, dispatch: e }) => wx(n, e); function gi(n, e, t = { strict: !0 }) { const r = Object.keys(e); return r.length ? r.every(i => t.strict ? e[i] === n[i] : zl(e[i]) ? e[i].test(n[i]) : e[i] === n[i]) : !0 } function dh(n, e, t = {}) { return n.find(r => r.type === e && gi(Object.fromEntries(Object.keys(t).map(i => [i, r.attrs[i]])), t)) } function Ic(n, e, t = {}) { return !!dh(n, e, t) } function $l(n, e, t) { var r; if (!n || !e) return; let i = n.parent.childAfter(n.parentOffset); if ((!i.node || !i.node.marks.some(u => u.type === e)) && (i = n.parent.childBefore(n.parentOffset)), !i.node || !i.node.marks.some(u => u.type === e) || (t = t || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !dh([...i.node.marks], e, t))) return; let o = i.index, l = n.start() + i.offset, a = o + 1, c = l + i.node.nodeSize; for (; o > 0 && Ic([...n.parent.child(o - 1).marks], e, t);)o -= 1, l -= n.parent.child(o).nodeSize; for (; a < n.parent.childCount && Ic([...n.parent.child(a).marks], e, t);)c += n.parent.child(a).nodeSize, a += 1; return { from: l, to: c } } function Ot(n, e) { if (typeof n == "string") { if (!e.marks[n]) throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`); return e.marks[n] } return n } const u1 = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { const s = Ot(n, r.schema), { doc: o, selection: l } = t, { $from: a, from: c, to: u } = l; if (i) { const f = $l(a, s, e); if (f && f.from <= c && f.to >= u) { const d = R.create(o, f.from, f.to); t.setSelection(d) } } return !0 }, f1 = n => e => { const t = typeof n == "function" ? n(e) : n; for (let r = 0; r < t.length; r += 1)if (t[r](e)) return !0; return !1 }; function hh(n) { return n instanceof R } function Pt(n = 0, e = 0, t = 0) { return Math.min(Math.max(n, e), t) } function ph(n, e = null) { if (!e) return null; const t = _.atStart(n), r = _.atEnd(n); if (e === "start" || e === !0) return t; if (e === "end") return r; const i = t.from, s = r.to; return e === "all" ? R.create(n, Pt(0, i, s), Pt(n.content.size, i, s)) : R.create(n, Pt(e, i, s), Pt(e, i, s)) } function Pc() { return navigator.platform === "Android" || /android/i.test(navigator.userAgent) } function yi() { return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } function d1() { return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1 } const h1 = (n = null, e = {}) => ({ editor: t, view: r, tr: i, dispatch: s }) => { e = { scrollIntoView: !0, ...e }; const o = () => { (yi() || Pc()) && r.dom.focus(), requestAnimationFrame(() => { t.isDestroyed || (r.focus(), d1() && !yi() && !Pc() && r.dom.focus({ preventScroll: !0 })) }) }; if (r.hasFocus() && n === null || n === !1) return !0; if (s && n === null && !hh(t.state.selection)) return o(), !0; const l = ph(i.doc, n) || t.state.selection, a = t.state.selection.eq(l); return s && (a || i.setSelection(l), a && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0 }, p1 = (n, e) => t => n.every((r, i) => e(r, { ...t, index: i })), m1 = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), mh = n => { const e = n.childNodes; for (let t = e.length - 1; t >= 0; t -= 1) { const r = e[t]; r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n.removeChild(r) : r.nodeType === 1 && mh(r) } return n }; function Hr(n) { const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body; return mh(t) } function hr(n, e, t) { if (n instanceof pt || n instanceof x) return n; t = { slice: !0, parseOptions: {}, ...t }; const r = typeof n == "object" && n !== null, i = typeof n == "string"; if (r) try { if (Array.isArray(n) && n.length > 0) return x.fromArray(n.map(l => e.nodeFromJSON(l))); const o = e.nodeFromJSON(n); return t.errorOnInvalidContent && o.check(), o } catch (s) { if (t.errorOnInvalidContent) throw new Error("[tiptap error]: Invalid JSON content", { cause: s }); return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", s), hr("", e, t) } if (i) { if (t.errorOnInvalidContent) { let o = !1, l = ""; const a = new Gf({ topNode: e.spec.topNode, marks: e.spec.marks, nodes: e.spec.nodes.append({ __tiptap__private__unknown__catch__all__node: { content: "inline*", group: "block", parseDOM: [{ tag: "*", getAttrs: c => (o = !0, l = typeof c == "string" ? c : c.outerHTML, null) }] } }) }); if (t.slice ? mt.fromSchema(a).parseSlice(Hr(n), t.parseOptions) : mt.fromSchema(a).parse(Hr(n), t.parseOptions), t.errorOnInvalidContent && o) throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${l}`) }) } const s = mt.fromSchema(e); return t.slice ? s.parseSlice(Hr(n), t.parseOptions).content : s.parse(Hr(n), t.parseOptions) } return hr("", e, t) } function g1(n, e, t) { const r = n.steps.length - 1; if (r < e) return; const i = n.steps[r]; if (!(i instanceof q || i instanceof G)) return; const s = n.mapping.maps[r]; let o = 0; s.forEach((l, a, c, u) => { o === 0 && (o = u) }), n.setSelection(_.near(n.doc.resolve(o), t)) } const y1 = n => !("type" in n), b1 = (n, e, t) => ({ tr: r, dispatch: i, editor: s }) => { var o; if (i) { t = { parseOptions: s.options.parseOptions, updateSelection: !0, applyInputRules: !1, applyPasteRules: !1, ...t }; let l; const a = m => { s.emit("contentError", { editor: s, error: m, disableCollaboration: () => { s.storage.collaboration && (s.storage.collaboration.isDisabled = !0) } }) }, c = { preserveWhitespace: "full", ...t.parseOptions }; if (!t.errorOnInvalidContent && !s.options.enableContentCheck && s.options.emitContentError) try { hr(e, s.schema, { parseOptions: c, errorOnInvalidContent: !0 }) } catch (m) { a(m) } try { l = hr(e, s.schema, { parseOptions: c, errorOnInvalidContent: (o = t.errorOnInvalidContent) !== null && o !== void 0 ? o : s.options.enableContentCheck }) } catch (m) { return a(m), !1 } let { from: u, to: f } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, d = !0, p = !0; if ((y1(l) ? l : [l]).forEach(m => { m.check(), d = d ? m.isText && m.marks.length === 0 : !1, p = p ? m.isBlock : !1 }), u === f && p) { const { parent: m } = r.doc.resolve(u); m.isTextblock && !m.type.spec.code && !m.childCount && (u -= 1, f += 1) } let g; if (d) { if (Array.isArray(e)) g = e.map(m => m.text || "").join(""); else if (e instanceof x) { let m = ""; e.forEach(y => { y.text && (m += y.text) }), g = m } else typeof e == "object" && e && e.text ? g = e.text : g = e; r.insertText(g, u, f) } else g = l, r.replaceWith(u, f, g); t.updateSelection && g1(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", { from: u, text: g }), t.applyPasteRules && r.setMeta("applyPasteRules", { from: u, text: g }) } return !0 }, x1 = () => ({ state: n, dispatch: e }) => bx(n, e), S1 = () => ({ state: n, dispatch: e }) => xx(n, e), w1 = () => ({ state: n, dispatch: e }) => Xd(n, e), k1 = () => ({ state: n, dispatch: e }) => th(n, e), E1 = () => ({ state: n, dispatch: e, tr: t }) => { try { const r = ss(n.doc, n.selection.$from.pos, -1); return r == null ? !1 : (t.join(r, 2), e && e(t), !0) } catch { return !1 } }, C1 = () => ({ state: n, dispatch: e, tr: t }) => { try { const r = ss(n.doc, n.selection.$from.pos, 1); return r == null ? !1 : (t.join(r, 2), e && e(t), !0) } catch { return !1 } }, O1 = () => ({ state: n, dispatch: e }) => gx(n, e), T1 = () => ({ state: n, dispatch: e }) => yx(n, e); function gh() { return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1 } function M1(n) { const e = n.split(/-(?!$)/); let t = e[e.length - 1]; t === "Space" && (t = " "); let r, i, s, o; for (let l = 0; l < e.length - 1; l += 1) { const a = e[l]; if (/^(cmd|meta|m)$/i.test(a)) o = !0; else if (/^a(lt)?$/i.test(a)) r = !0; else if (/^(c|ctrl|control)$/i.test(a)) i = !0; else if (/^s(hift)?$/i.test(a)) s = !0; else if (/^mod$/i.test(a)) yi() || gh() ? o = !0 : i = !0; else throw new Error(`Unrecognized modifier name: ${a}`) } return r && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), s && (t = `Shift-${t}`), t } const A1 = n => ({ editor: e, view: t, tr: r, dispatch: i }) => { const s = M1(n).split(/-(?!$)/), o = s.find(c => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), l = new KeyboardEvent("keydown", { key: o === "Space" ? " " : o, altKey: s.includes("Alt"), ctrlKey: s.includes("Ctrl"), metaKey: s.includes("Meta"), shiftKey: s.includes("Shift"), bubbles: !0, cancelable: !0 }), a = e.captureTransaction(() => { t.someProp("handleKeyDown", c => c(t, l)) }); return a?.steps.forEach(c => { const u = c.map(r.mapping); u && i && r.maybeStep(u) }), !0 }; function pr(n, e, t = {}) { const { from: r, to: i, empty: s } = n.selection, o = e ? X(e, n.schema) : null, l = []; n.doc.nodesBetween(r, i, (f, d) => { if (f.isText) return; const p = Math.max(r, d), h = Math.min(i, d + f.nodeSize); l.push({ node: f, from: p, to: h }) }); const a = i - r, c = l.filter(f => o ? o.name === f.node.type.name : !0).filter(f => gi(f.node.attrs, t, { strict: !1 })); return s ? !!c.length : c.reduce((f, d) => f + d.to - d.from, 0) >= a } const N1 = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = X(n, t.schema); return pr(t, i, e) ? Sx(t, r) : !1 }, R1 = () => ({ state: n, dispatch: e }) => sh(n, e), v1 = n => ({ state: e, dispatch: t }) => { const r = X(n, e.schema); return _x(r)(e, t) }, _1 = () => ({ state: n, dispatch: e }) => rh(n, e); function ys(n, e) { return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null } function Lc(n, e) { const t = typeof e == "string" ? [e] : e; return Object.keys(n).reduce((r, i) => (t.includes(i) || (r[i] = n[i]), r), {}) } const D1 = (n, e) => ({ tr: t, state: r, dispatch: i }) => { let s = null, o = null; const l = ys(typeof n == "string" ? n : n.name, r.schema); return l ? (l === "node" && (s = X(n, r.schema)), l === "mark" && (o = Ot(n, r.schema)), i && t.selection.ranges.forEach(a => { r.doc.nodesBetween(a.$from.pos, a.$to.pos, (c, u) => { s && s === c.type && t.setNodeMarkup(u, void 0, Lc(c.attrs, e)), o && c.marks.length && c.marks.forEach(f => { o === f.type && t.addMark(u, u + c.nodeSize, o.create(Lc(f.attrs, e))) }) }) }), !0) : !1 }, I1 = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), P1 = () => ({ tr: n, dispatch: e }) => { if (e) { const t = new Se(n.doc); n.setSelection(t) } return !0 }, L1 = () => ({ state: n, dispatch: e }) => Zd(n, e), B1 = () => ({ state: n, dispatch: e }) => nh(n, e), F1 = () => ({ state: n, dispatch: e }) => Cx(n, e), z1 = () => ({ state: n, dispatch: e }) => Mx(n, e), $1 = () => ({ state: n, dispatch: e }) => Tx(n, e); function Bo(n, e, t = {}, r = {}) { return hr(n, e, { slice: !1, parseOptions: t, errorOnInvalidContent: r.errorOnInvalidContent }) } const H1 = (n, e = !1, t = {}, r = {}) => ({ editor: i, tr: s, dispatch: o, commands: l }) => { var a, c; const { doc: u } = s; if (t.preserveWhitespace !== "full") { const f = Bo(n, i.schema, t, { errorOnInvalidContent: (a = r.errorOnInvalidContent) !== null && a !== void 0 ? a : i.options.enableContentCheck }); return o && s.replaceWith(0, u.content.size, f).setMeta("preventUpdate", !e), !0 } return o && s.setMeta("preventUpdate", !e), l.insertContentAt({ from: 0, to: u.content.size }, n, { parseOptions: t, errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck }) }; function yh(n, e) { const t = Ot(e, n.schema), { from: r, to: i, empty: s } = n.selection, o = []; s ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, a => { o.push(...a.marks) }); const l = o.find(a => a.type.name === t.name); return l ? { ...l.attrs } : {} } function j1(n, e) { const t = new fd(n); return e.forEach(r => { r.steps.forEach(i => { t.step(i) }) }), t } function V1(n) { for (let e = 0; e < n.edgeCount; e += 1) { const { type: t } = n.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } function U1(n, e, t) { const r = []; return n.nodesBetween(e.from, e.to, (i, s) => { t(i) && r.push({ node: i, pos: s }) }), r } function W1(n, e) { for (let t = n.depth; t > 0; t -= 1) { const r = n.node(t); if (e(r)) return { pos: t > 0 ? n.before(t) : 0, start: n.start(t), depth: t, node: r } } } function Hl(n) { return e => W1(e.$from, n) } function K1(n, e) { const t = { from: 0, to: n.content.size }; return uh(n, t, e) } function q1(n, e) { const t = X(e, n.schema), { from: r, to: i } = n.selection, s = []; n.doc.nodesBetween(r, i, l => { s.push(l) }); const o = s.reverse().find(l => l.type.name === t.name); return o ? { ...o.attrs } : {} } function bh(n, e) { const t = ys(typeof e == "string" ? e : e.name, n.schema); return t === "node" ? q1(n, e) : t === "mark" ? yh(n, e) : {} } function J1(n, e = JSON.stringify) { const t = {}; return n.filter(r => { const i = e(r); return Object.prototype.hasOwnProperty.call(t, i) ? !1 : t[i] = !0 }) } function G1(n) { const e = J1(n); return e.length === 1 ? e : e.filter((t, r) => !e.filter((s, o) => o !== r).some(s => t.oldRange.from >= s.oldRange.from && t.oldRange.to <= s.oldRange.to && t.newRange.from >= s.newRange.from && t.newRange.to <= s.newRange.to)) } function Y1(n) { const { mapping: e, steps: t } = n, r = []; return e.maps.forEach((i, s) => { const o = []; if (i.ranges.length) i.forEach((l, a) => { o.push({ from: l, to: a }) }); else { const { from: l, to: a } = t[s]; if (l === void 0 || a === void 0) return; o.push({ from: l, to: a }) } o.forEach(({ from: l, to: a }) => { const c = e.slice(s).map(l, -1), u = e.slice(s).map(a), f = e.invert().map(c, -1), d = e.invert().map(u); r.push({ oldRange: { from: f, to: d }, newRange: { from: c, to: u } }) }) }), G1(r) } function jl(n, e, t) { const r = []; return n === e ? t.resolve(n).marks().forEach(i => { const s = t.resolve(n), o = $l(s, i.type); o && r.push({ mark: i, ...o }) }) : t.nodesBetween(n, e, (i, s) => { !i || i?.nodeSize === void 0 || r.push(...i.marks.map(o => ({ from: s, to: s + i.nodeSize, mark: o }))) }), r } function Qr(n, e, t) { return Object.fromEntries(Object.entries(t).filter(([r]) => { const i = n.find(s => s.type === e && s.name === r); return i ? i.attribute.keepOnSplit : !1 })) } function Fo(n, e, t = {}) { const { empty: r, ranges: i } = n.selection, s = e ? Ot(e, n.schema) : null; if (r) return !!(n.storedMarks || n.selection.$from.marks()).filter(f => s ? s.name === f.type.name : !0).find(f => gi(f.attrs, t, { strict: !1 })); let o = 0; const l = []; if (i.forEach(({ $from: f, $to: d }) => { const p = f.pos, h = d.pos; n.doc.nodesBetween(p, h, (g, m) => { if (!g.isText && !g.marks.length) return; const y = Math.max(p, m), S = Math.min(h, m + g.nodeSize), k = S - y; o += k, l.push(...g.marks.map(M => ({ mark: M, from: y, to: S }))) }) }), o === 0) return !1; const a = l.filter(f => s ? s.name === f.mark.type.name : !0).filter(f => gi(f.mark.attrs, t, { strict: !1 })).reduce((f, d) => f + d.to - d.from, 0), c = l.filter(f => s ? f.mark.type !== s && f.mark.type.excludes(s) : !0).reduce((f, d) => f + d.to - d.from, 0); return (a > 0 ? a + c : a) >= o } function X1(n, e, t = {}) { if (!e) return pr(n, null, t) || Fo(n, null, t); const r = ys(e, n.schema); return r === "node" ? pr(n, e, t) : r === "mark" ? Fo(n, e, t) : !1 } function Bc(n, e) { const { nodeExtensions: t } = ps(e), r = t.find(o => o.name === n); if (!r) return !1; const i = { name: r.name, options: r.options, storage: r.storage }, s = I(O(r, "group", i)); return typeof s != "string" ? !1 : s.split(" ").includes("list") } function bs(n, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) { var r; if (t) { if (n.type.name === "hardBreak") return !0; if (n.isText) return /^\s*$/m.test((r = n.text) !== null && r !== void 0 ? r : "") } if (n.isText) return !n.text; if (n.isAtom || n.isLeaf) return !1; if (n.content.childCount === 0) return !0; if (e) { let i = !0; return n.content.forEach(s => { i !== !1 && (bs(s, { ignoreWhitespace: t, checkChildren: e }) || (i = !1)) }), i } return !1 } function Q1(n) { return n instanceof A } function Z1(n, e, t) { var r; const { selection: i } = e; let s = null; if (hh(i) && (s = i.$cursor), s) { const l = (r = n.storedMarks) !== null && r !== void 0 ? r : s.marks(); return !!t.isInSet(l) || !l.some(a => a.type.excludes(t)) } const { ranges: o } = i; return o.some(({ $from: l, $to: a }) => { let c = l.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1; return n.doc.nodesBetween(l.pos, a.pos, (u, f, d) => { if (c) return !1; if (u.isInline) { const p = !d || d.type.allowsMarkType(t), h = !!t.isInSet(u.marks) || !u.marks.some(g => g.type.excludes(t)); c = p && h } return !c }), c }) } const eS = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { const { selection: s } = t, { empty: o, ranges: l } = s, a = Ot(n, r.schema); if (i) if (o) { const c = yh(r, a); t.addStoredMark(a.create({ ...c, ...e })) } else l.forEach(c => { const u = c.$from.pos, f = c.$to.pos; r.doc.nodesBetween(u, f, (d, p) => { const h = Math.max(p, u), g = Math.min(p + d.nodeSize, f); d.marks.find(y => y.type === a) ? d.marks.forEach(y => { a === y.type && t.addMark(h, g, a.create({ ...y.attrs, ...e })) }) : t.addMark(h, g, a.create(e)) }) }); return Z1(r, t, a) }, tS = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), nS = (n, e = {}) => ({ state: t, dispatch: r, chain: i }) => { const s = X(n, t.schema); let o; return t.selection.$anchor.sameParent(t.selection.$head) && (o = t.selection.$anchor.parent.attrs), s.isTextblock ? i().command(({ commands: l }) => Rc(s, { ...o, ...e })(t) ? !0 : l.clearNodes()).command(({ state: l }) => Rc(s, { ...o, ...e })(l, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1) }, rS = n => ({ tr: e, dispatch: t }) => { if (t) { const { doc: r } = e, i = Pt(n, 0, r.content.size), s = A.create(r, i); e.setSelection(s) } return !0 }, iS = n => ({ tr: e, dispatch: t }) => { if (t) { const { doc: r } = e, { from: i, to: s } = typeof n == "number" ? { from: n, to: n } : n, o = R.atStart(r).from, l = R.atEnd(r).to, a = Pt(i, o, l), c = Pt(s, o, l), u = R.create(r, a, c); e.setSelection(u) } return !0 }, sS = n => ({ state: e, dispatch: t }) => { const r = X(n, e.schema); return Px(r)(e, t) }; function Fc(n, e) { const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks(); if (t) { const r = t.filter(i => e?.includes(i.type.name)); n.tr.ensureMarks(r) } } const oS = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: r, editor: i }) => { const { selection: s, doc: o } = e, { $from: l, $to: a } = s, c = i.extensionManager.attributes, u = Qr(c, l.node().type.name, l.node().attrs); if (s instanceof A && s.node.isBlock) return !l.parentOffset || !Je(o, l.pos) ? !1 : (r && (n && Fc(t, i.extensionManager.splittableMarks), e.split(l.pos).scrollIntoView()), !0); if (!l.parent.isBlock) return !1; const f = a.parentOffset === a.parent.content.size, d = l.depth === 0 ? void 0 : V1(l.node(-1).contentMatchAt(l.indexAfter(-1))); let p = f && d ? [{ type: d, attrs: u }] : void 0, h = Je(e.doc, e.mapping.map(l.pos), 1, p); if (!p && !h && Je(e.doc, e.mapping.map(l.pos), 1, d ? [{ type: d }] : void 0) && (h = !0, p = d ? [{ type: d, attrs: u }] : void 0), r) { if (h && (s instanceof R && e.deleteSelection(), e.split(e.mapping.map(l.pos), 1, p), d && !f && !l.parentOffset && l.parent.type !== d)) { const g = e.mapping.map(l.before()), m = e.doc.resolve(g); l.node(-1).canReplaceWith(m.index(), m.index() + 1, d) && e.setNodeMarkup(e.mapping.map(l.before()), d) } n && Fc(t, i.extensionManager.splittableMarks), e.scrollIntoView() } return h }, lS = (n, e = {}) => ({ tr: t, state: r, dispatch: i, editor: s }) => { var o; const l = X(n, r.schema), { $from: a, $to: c } = r.selection, u = r.selection.node; if (u && u.isBlock || a.depth < 2 || !a.sameParent(c)) return !1; const f = a.node(-1); if (f.type !== l) return !1; const d = s.extensionManager.attributes; if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) { if (a.depth === 2 || a.node(-3).type !== l || a.index(-2) !== a.node(-2).childCount - 1) return !1; if (i) { let y = x.empty; const S = a.index(-1) ? 1 : a.index(-2) ? 2 : 3; for (let P = a.depth - S; P >= a.depth - 3; P -= 1)y = x.from(a.node(P).copy(y)); const k = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3, M = { ...Qr(d, a.node().type.name, a.node().attrs), ...e }, T = ((o = l.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(M)) || void 0; y = y.append(x.from(l.createAndFill(null, T) || void 0)); const D = a.before(a.depth - (S - 1)); t.replace(D, a.after(-k), new E(y, 4 - S, 0)); let C = -1; t.doc.nodesBetween(D, t.doc.content.size, (P, B) => { if (C > -1) return !1; P.isTextblock && P.content.size === 0 && (C = B + 1) }), C > -1 && t.setSelection(R.near(t.doc.resolve(C))), t.scrollIntoView() } return !0 } const p = c.pos === a.end() ? f.contentMatchAt(0).defaultType : null, h = { ...Qr(d, f.type.name, f.attrs), ...e }, g = { ...Qr(d, a.node().type.name, a.node().attrs), ...e }; t.delete(a.pos, c.pos); const m = p ? [{ type: l, attrs: h }, { type: p, attrs: g }] : [{ type: l, attrs: h }]; if (!Je(t.doc, a.pos, 2)) return !1; if (i) { const { selection: y, storedMarks: S } = r, { splittableMarks: k } = s.extensionManager, M = S || y.$to.parentOffset && y.$from.marks(); if (t.split(a.pos, 2, m).scrollIntoView(), !M || !i) return !0; const T = M.filter(D => k.includes(D.type.name)); t.ensureMarks(T) } return !0 }, Us = (n, e) => { const t = Hl(o => o.type === e)(n.selection); if (!t) return !0; const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth); if (r === void 0) return !0; const i = n.doc.nodeAt(r); return t.node.type === i?.type && Et(n.doc, t.pos) && n.join(t.pos), !0 }, Ws = (n, e) => { const t = Hl(o => o.type === e)(n.selection); if (!t) return !0; const r = n.doc.resolve(t.start).after(t.depth); if (r === void 0) return !0; const i = n.doc.nodeAt(r); return t.node.type === i?.type && Et(n.doc, r) && n.join(r), !0 }, aS = (n, e, t, r = {}) => ({ editor: i, tr: s, state: o, dispatch: l, chain: a, commands: c, can: u }) => { const { extensions: f, splittableMarks: d } = i.extensionManager, p = X(n, o.schema), h = X(e, o.schema), { selection: g, storedMarks: m } = o, { $from: y, $to: S } = g, k = y.blockRange(S), M = m || g.$to.parentOffset && g.$from.marks(); if (!k) return !1; const T = Hl(D => Bc(D.type.name, f))(g); if (k.depth >= 1 && T && k.depth - T.depth <= 1) { if (T.node.type === p) return c.liftListItem(h); if (Bc(T.node.type.name, f) && p.validContent(T.node.content) && l) return a().command(() => (s.setNodeMarkup(T.pos, p), !0)).command(() => Us(s, p)).command(() => Ws(s, p)).run() } return !t || !M || !l ? a().command(() => u().wrapInList(p, r) ? !0 : c.clearNodes()).wrapInList(p, r).command(() => Us(s, p)).command(() => Ws(s, p)).run() : a().command(() => { const D = u().wrapInList(p, r), C = M.filter(P => d.includes(P.type.name)); return s.ensureMarks(C), D ? !0 : c.clearNodes() }).wrapInList(p, r).command(() => Us(s, p)).command(() => Ws(s, p)).run() }, cS = (n, e = {}, t = {}) => ({ state: r, commands: i }) => { const { extendEmptyMarkRange: s = !1 } = t, o = Ot(n, r.schema); return Fo(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: s }) : i.setMark(o, e) }, uS = (n, e, t = {}) => ({ state: r, commands: i }) => { const s = X(n, r.schema), o = X(e, r.schema), l = pr(r, s, t); let a; return r.selection.$anchor.sameParent(r.selection.$head) && (a = r.selection.$anchor.parent.attrs), l ? i.setNode(o, a) : i.setNode(s, { ...a, ...t }) }, fS = (n, e = {}) => ({ state: t, commands: r }) => { const i = X(n, t.schema); return pr(t, i, e) ? r.lift(i) : r.wrapIn(i, e) }, dS = () => ({ state: n, dispatch: e }) => { const t = n.plugins; for (let r = 0; r < t.length; r += 1) { const i = t[r]; let s; if (i.spec.isInputRules && (s = i.getState(n))) { if (e) { const o = n.tr, l = s.transform; for (let a = l.steps.length - 1; a >= 0; a -= 1)o.step(l.steps[a].invert(l.docs[a])); if (s.text) { const a = o.doc.resolve(s.from).marks(); o.replaceWith(s.from, s.to, n.schema.text(s.text, a)) } else o.delete(s.from, s.to) } return !0 } } return !1 }, hS = () => ({ tr: n, dispatch: e }) => { const { selection: t } = n, { empty: r, ranges: i } = t; return r || e && i.forEach(s => { n.removeMark(s.$from.pos, s.$to.pos) }), !0 }, pS = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { var s; const { extendEmptyMarkRange: o = !1 } = e, { selection: l } = t, a = Ot(n, r.schema), { $from: c, empty: u, ranges: f } = l; if (!i) return !0; if (u && o) { let { from: d, to: p } = l; const h = (s = c.marks().find(m => m.type === a)) === null || s === void 0 ? void 0 : s.attrs, g = $l(c, a, h); g && (d = g.from, p = g.to), t.removeMark(d, p, a) } else f.forEach(d => { t.removeMark(d.$from.pos, d.$to.pos, a) }); return t.removeStoredMark(a), !0 }, mS = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { let s = null, o = null; const l = ys(typeof n == "string" ? n : n.name, r.schema); return l ? (l === "node" && (s = X(n, r.schema)), l === "mark" && (o = Ot(n, r.schema)), i && t.selection.ranges.forEach(a => { const c = a.$from.pos, u = a.$to.pos; let f, d, p, h; t.selection.empty ? r.doc.nodesBetween(c, u, (g, m) => { s && s === g.type && (p = Math.max(m, c), h = Math.min(m + g.nodeSize, u), f = m, d = g) }) : r.doc.nodesBetween(c, u, (g, m) => { m < c && s && s === g.type && (p = Math.max(m, c), h = Math.min(m + g.nodeSize, u), f = m, d = g), m >= c && m <= u && (s && s === g.type && t.setNodeMarkup(m, void 0, { ...g.attrs, ...e }), o && g.marks.length && g.marks.forEach(y => { if (o === y.type) { const S = Math.max(m, c), k = Math.min(m + g.nodeSize, u); t.addMark(S, k, o.create({ ...y.attrs, ...e })) } })) }), d && (f !== void 0 && t.setNodeMarkup(f, void 0, { ...d.attrs, ...e }), o && d.marks.length && d.marks.forEach(g => { o === g.type && t.addMark(p, h, o.create({ ...g.attrs, ...e })) })) }), !0) : !1 }, gS = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = X(n, t.schema); return Ax(i, e)(t, r) }, yS = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = X(n, t.schema); return Nx(i, e)(t, r) }; var bS = Object.freeze({ __proto__: null, blur: Qx, clearContent: Zx, clearNodes: e1, command: t1, createParagraphNear: n1, cut: r1, deleteCurrentNode: i1, deleteNode: s1, deleteRange: o1, deleteSelection: l1, enter: a1, exitCode: c1, extendMarkRange: u1, first: f1, focus: h1, forEach: p1, insertContent: m1, insertContentAt: b1, joinBackward: w1, joinDown: S1, joinForward: k1, joinItemBackward: E1, joinItemForward: C1, joinTextblockBackward: O1, joinTextblockForward: T1, joinUp: x1, keyboardShortcut: A1, lift: N1, liftEmptyBlock: R1, liftListItem: v1, newlineInCode: _1, resetAttributes: D1, scrollIntoView: I1, selectAll: P1, selectNodeBackward: L1, selectNodeForward: B1, selectParentNode: F1, selectTextblockEnd: z1, selectTextblockStart: $1, setContent: H1, setMark: eS, setMeta: tS, setNode: nS, setNodeSelection: rS, setTextSelection: iS, sinkListItem: sS, splitBlock: oS, splitListItem: lS, toggleList: aS, toggleMark: cS, toggleNode: uS, toggleWrap: fS, undoInputRule: dS, unsetAllMarks: hS, unsetMark: pS, updateAttributes: mS, wrapIn: gS, wrapInList: yS }); const xS = le.create({ name: "commands", addCommands() { return { ...bS } } }), SS = le.create({ name: "drop", addProseMirrorPlugins() { return [new Q({ key: new ye("tiptapDrop"), props: { handleDrop: (n, e, t, r) => { this.editor.emit("drop", { editor: this.editor, event: e, slice: t, moved: r }) } } })] } }), wS = le.create({ name: "editable", addProseMirrorPlugins() { return [new Q({ key: new ye("editable"), props: { editable: () => this.editor.options.editable } })] } }), kS = new ye("focusEvents"), ES = le.create({ name: "focusEvents", addProseMirrorPlugins() { const { editor: n } = this; return [new Q({ key: kS, props: { handleDOMEvents: { focus: (e, t) => { n.isFocused = !0; const r = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1); return e.dispatch(r), !1 }, blur: (e, t) => { n.isFocused = !1; const r = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1); return e.dispatch(r), !1 } } } })] } }), CS = le.create({ name: "keymap", addKeyboardShortcuts() { const n = () => this.editor.commands.first(({ commands: o }) => [() => o.undoInputRule(), () => o.command(({ tr: l }) => { const { selection: a, doc: c } = l, { empty: u, $anchor: f } = a, { pos: d, parent: p } = f, h = f.parent.isTextblock && d > 0 ? l.doc.resolve(d - 1) : f, g = h.parent.type.spec.isolating, m = f.pos - f.parentOffset, y = g && h.parent.childCount === 1 ? m === f.pos : _.atStart(c).from === d; return !u || !p.type.isTextblock || p.textContent.length || !y || y && f.parent.type.name === "paragraph" ? !1 : o.clearNodes() }), () => o.deleteSelection(), () => o.joinBackward(), () => o.selectNodeBackward()]), e = () => this.editor.commands.first(({ commands: o }) => [() => o.deleteSelection(), () => o.deleteCurrentNode(), () => o.joinForward(), () => o.selectNodeForward()]), r = { Enter: () => this.editor.commands.first(({ commands: o }) => [() => o.newlineInCode(), () => o.createParagraphNear(), () => o.liftEmptyBlock(), () => o.splitBlock()]), "Mod-Enter": () => this.editor.commands.exitCode(), Backspace: n, "Mod-Backspace": n, "Shift-Backspace": n, Delete: e, "Mod-Delete": e, "Mod-a": () => this.editor.commands.selectAll() }, i = { ...r }, s = { ...r, "Ctrl-h": n, "Alt-Backspace": n, "Ctrl-d": e, "Ctrl-Alt-Backspace": e, "Alt-Delete": e, "Alt-d": e, "Ctrl-a": () => this.editor.commands.selectTextblockStart(), "Ctrl-e": () => this.editor.commands.selectTextblockEnd() }; return yi() || gh() ? s : i }, addProseMirrorPlugins() { return [new Q({ key: new ye("clearDocument"), appendTransaction: (n, e, t) => { if (n.some(g => g.getMeta("composition"))) return; const r = n.some(g => g.docChanged) && !e.doc.eq(t.doc), i = n.some(g => g.getMeta("preventClearDocument")); if (!r || i) return; const { empty: s, from: o, to: l } = e.selection, a = _.atStart(e.doc).from, c = _.atEnd(e.doc).to; if (s || !(o === a && l === c) || !bs(t.doc)) return; const d = t.tr, p = ds({ state: t, transaction: d }), { commands: h } = new hs({ editor: this.editor, state: p }); if (h.clearNodes(), !!d.steps.length) return d } })] } }), OS = le.create({ name: "paste", addProseMirrorPlugins() { return [new Q({ key: new ye("tiptapPaste"), props: { handlePaste: (n, e, t) => { this.editor.emit("paste", { editor: this.editor, event: e, slice: t }) } } })] } }), TS = le.create({ name: "tabindex", addProseMirrorPlugins() { return [new Q({ key: new ye("tabindex"), props: { attributes: () => this.editor.isEditable ? { tabindex: "0" } : {} } })] } }); class Rt { get name() { return this.node.type.name } constructor(e, t, r = !1, i = null) { this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = t, this.currentNode = i } get node() { return this.currentNode || this.resolvedPos.node() } get element() { return this.editor.view.domAtPos(this.pos).node } get depth() { var e; return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth } get pos() { return this.resolvedPos.pos } get content() { return this.node.content } set content(e) { let t = this.from, r = this.to; if (this.isBlock) { if (this.content.size === 0) { console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`); return } t = this.from + 1, r = this.to - 1 } this.editor.commands.insertContentAt({ from: t, to: r }, e) } get attributes() { return this.node.attrs } get textContent() { return this.node.textContent } get size() { return this.node.nodeSize } get from() { return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth) } get range() { return { from: this.from, to: this.to } } get to() { return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1) } get parent() { if (this.depth === 0) return null; const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e); return new Rt(t, this.editor) } get before() { let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Rt(e, this.editor) } get after() { let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Rt(e, this.editor) } get children() { const e = []; return this.node.content.forEach((t, r) => { const i = t.isBlock && !t.isTextblock, s = t.isAtom && !t.isText, o = this.pos + r + (s ? 0 : 1); if (o < 0 || o > this.resolvedPos.doc.nodeSize - 2) return; const l = this.resolvedPos.doc.resolve(o); if (!i && l.depth <= this.depth) return; const a = new Rt(l, this.editor, i, i ? t : null); i && (a.actualDepth = this.depth + 1), e.push(new Rt(l, this.editor, i, i ? t : null)) }), e } get firstChild() { return this.children[0] || null } get lastChild() { const e = this.children; return e[e.length - 1] || null } closest(e, t = {}) { let r = null, i = this.parent; for (; i && !r;) { if (i.node.type.name === e) if (Object.keys(t).length > 0) { const s = i.node.attrs, o = Object.keys(t); for (let l = 0; l < o.length; l += 1) { const a = o[l]; if (s[a] !== t[a]) break } } else r = i; i = i.parent } return r } querySelector(e, t = {}) { return this.querySelectorAll(e, t, !0)[0] || null } querySelectorAll(e, t = {}, r = !1) { let i = []; if (!this.children || this.children.length === 0) return i; const s = Object.keys(t); return this.children.forEach(o => { r && i.length > 0 || (o.node.type.name === e && s.every(a => t[a] === o.node.attrs[a]) && i.push(o), !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(e, t, r)))) }), i } setAttribute(e) { const { tr: t } = this.editor.state; t.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }), this.editor.view.dispatch(t) } } const MS = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`; function AS(n, e, t) { const r = document.querySelector("style[data-tiptap-style]"); if (r !== null) return r; const i = document.createElement("style"); return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(i), i } class NS extends Lx {
  constructor(e = {}) { super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = { element: document.createElement("div"), content: "", injectCSS: !0, injectNonce: void 0, extensions: [], autofocus: !1, editable: !0, editorProps: {}, parseOptions: {}, coreExtensionOptions: {}, enableInputRules: !0, enablePasteRules: !0, enableCoreExtensions: !0, enableContentCheck: !1, emitContentError: !1, onBeforeCreate: () => null, onCreate: () => null, onUpdate: () => null, onSelectionUpdate: () => null, onTransaction: () => null, onFocus: () => null, onBlur: () => null, onDestroy: () => null, onContentError: ({ error: t }) => { throw t }, onPaste: () => null, onDrop: () => null }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: r, moved: i }) => this.options.onDrop(t, r, i)), this.on("paste", ({ event: t, slice: r }) => this.options.onPaste(t, r)), window.setTimeout(() => { this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0) }, 0) } get storage() { return this.extensionStorage } get commands() { return this.commandManager.commands } chain() { return this.commandManager.chain() } can() { return this.commandManager.can() } injectCSS() { this.options.injectCSS && document && (this.css = AS(MS, this.options.injectNonce)) } setOptions(e = {}) { this.options = { ...this.options, ...e }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state)) } setEditable(e, t = !0) { this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr }) } get isEditable() { return this.options.editable && this.view && this.view.editable } get state() { return this.view.state } registerPlugin(e, t) { const r = ch(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r }); return this.view.updateState(i), i } unregisterPlugin(e) { if (this.isDestroyed) return; const t = this.state.plugins; let r = t; if ([].concat(e).forEach(s => { const o = typeof s == "string" ? `${s}$` : s.key; r = r.filter(l => !l.key.startsWith(o)) }), t.length === r.length) return; const i = this.state.reconfigure({ plugins: r }); return this.view.updateState(i), i } createExtensionManager() { var e, t; const i = [...this.options.enableCoreExtensions ? [wS, Xx.configure({ blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator }), xS, ES, CS, TS, SS, OS].filter(s => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter(s => ["extension", "node", "mark"].includes(s?.type)); this.extensionManager = new mn(i, this) } createCommandManager() { this.commandManager = new hs({ editor: this }) } createSchema() { this.schema = this.extensionManager.schema } createView() { var e; let t; try { t = Bo(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck }) } catch (o) { if (!(o instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(o.message)) throw o; this.emit("contentError", { editor: this, error: o, disableCollaboration: () => { this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter(l => l.name !== "collaboration"), this.createExtensionManager() } }), t = Bo(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 }) } const r = ph(t, this.options.autofocus); this.view = new Jd(this.options.element, { ...this.options.editorProps, attributes: { role: "textbox", ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes }, dispatchTransaction: this.dispatchTransaction.bind(this), state: pn.create({ doc: t, selection: r || void 0 }) }); const i = this.state.reconfigure({ plugins: this.extensionManager.plugins }); this.view.updateState(i), this.createNodeViews(), this.prependClass(); const s = this.view.dom; s.editor = this } createNodeViews() { this.view.isDestroyed || this.view.setProps({ nodeViews: this.extensionManager.nodeViews }) } prependClass() { this.view.dom.className = `tiptap ${this.view.dom.className}` } captureTransaction(e) { this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1; const t = this.capturedTransaction; return this.capturedTransaction = null, t } dispatchTransaction(e) { if (this.view.isDestroyed) return; if (this.isCapturingTransaction) { if (!this.capturedTransaction) { this.capturedTransaction = e; return } e.steps.forEach(o => { var l; return (l = this.capturedTransaction) === null || l === void 0 ? void 0 : l.step(o) }); return } const t = this.state.apply(e), r = !this.state.selection.eq(t.selection); this.emit("beforeTransaction", { editor: this, transaction: e, nextState: t }), this.view.updateState(t), this.emit("transaction", { editor: this, transaction: e }), r && this.emit("selectionUpdate", { editor: this, transaction: e }); const i = e.getMeta("focus"), s = e.getMeta("blur"); i && this.emit("focus", { editor: this, event: i.event, transaction: e }), s && this.emit("blur", { editor: this, event: s.event, transaction: e }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", { editor: this, transaction: e }) } getAttributes(e) { return bh(this.state, e) } isActive(e, t) { const r = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e; return X1(this.state, r, i) } getJSON() { return this.state.doc.toJSON() } getHTML() { return Fl(this.state.doc.content, this.schema) } getText(e) {
    const { blockSeparator: t = `

`, textSerializers: r = {} } = e || {}; return K1(this.state.doc, { blockSeparator: t, textSerializers: { ...fh(this.schema), ...r } })
  } get isEmpty() { return bs(this.state.doc) } getCharacterCount() { return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2 } destroy() { if (this.emit("destroy"), this.view) { const e = this.view.dom; e && e.editor && delete e.editor, this.view.destroy() } this.removeAllListeners() } get isDestroyed() { var e; return !(!((e = this.view) === null || e === void 0) && e.docView) } $node(e, t) { var r; return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, t)) || null } $nodes(e, t) { var r; return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, t)) || null } $pos(e) { const t = this.state.doc.resolve(e); return new Rt(t, this) } get $doc() { return this.$pos(0) }
} function On(n) { return new ms({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = I(n.getAttributes, void 0, r); if (i === !1 || i === null) return null; const { tr: s } = e, o = r[r.length - 1], l = r[0]; if (o) { const a = l.search(/\S/), c = t.from + l.indexOf(o), u = c + o.length; if (jl(t.from, t.to, e.doc).filter(p => p.mark.type.excluded.find(g => g === n.type && g !== p.mark.type)).filter(p => p.to > c).length) return null; u < t.to && s.delete(u, t.to), c > t.from && s.delete(t.from + a, c); const d = t.from + a + o.length; s.addMark(t.from + a, d, n.type.create(i || {})), s.removeStoredMark(n.type) } } }) } function RS(n) { return new ms({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = I(n.getAttributes, void 0, r) || {}, { tr: s } = e, o = t.from; let l = t.to; const a = n.type.create(i); if (r[1]) { const c = r[0].lastIndexOf(r[1]); let u = o + c; u > l ? u = l : l = u + r[1].length; const f = r[0][r[0].length - 1]; s.insertText(f, o + r[0].length - 1), s.replaceWith(u, l, a) } else if (r[0]) { const c = n.type.isInline ? o : o - 1; s.insert(c, n.type.create(i)).delete(s.mapping.map(o), s.mapping.map(l)) } s.scrollIntoView() } }) } function zo(n) { return new ms({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = e.doc.resolve(t.from), s = I(n.getAttributes, void 0, r) || {}; if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), n.type)) return null; e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, s) } }) } function mr(n) { return new ms({ find: n.find, handler: ({ state: e, range: t, match: r, chain: i }) => { const s = I(n.getAttributes, void 0, r) || {}, o = e.tr.delete(t.from, t.to), a = o.doc.resolve(t.from).blockRange(), c = a && kl(a, n.type, s); if (!c) return null; if (o.wrap(a, c), n.keepMarks && n.editor) { const { selection: f, storedMarks: d } = e, { splittableMarks: p } = n.editor.extensionManager, h = d || f.$to.parentOffset && f.$from.marks(); if (h) { const g = h.filter(m => p.includes(m.type.name)); o.ensureMarks(g) } } if (n.keepAttributes) { const f = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList"; i().updateAttributes(f, s).run() } const u = o.doc.resolve(t.from - 1).nodeBefore; u && u.type === n.type && Et(o.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(r, u)) && o.join(t.from - 1) } }) } class ge { constructor(e = {}) { this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = I(O(this, "addOptions", { name: this.name }))), this.storage = I(O(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new ge(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => gs(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new ge(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = I(O(t, "addOptions", { name: t.name })), t.storage = I(O(t, "addStorage", { name: t.name, options: t.options })), t } } function nn(n) { return new Wx({ find: n.find, handler: ({ state: e, range: t, match: r, pasteEvent: i }) => { const s = I(n.getAttributes, void 0, r, i); if (s === !1 || s === null) return null; const { tr: o } = e, l = r[r.length - 1], a = r[0]; let c = t.to; if (l) { const u = a.search(/\S/), f = t.from + a.indexOf(l), d = f + l.length; if (jl(t.from, t.to, e.doc).filter(h => h.mark.type.excluded.find(m => m === n.type && m !== h.mark.type)).filter(h => h.to > f).length) return null; d < t.to && o.delete(d, t.to), f > t.from && o.delete(t.from + u, f), c = t.from + u + l.length, o.addMark(t.from + u, c, n.type.create(s || {})), o.removeStoredMark(n.type) } } }) } function vS(n, e) { const { selection: t } = n, { $from: r } = t; if (t instanceof A) { const s = r.index(); return r.parent.canReplaceWith(s, s + 1, e) } let i = r.depth; for (; i >= 0;) { const s = r.index(i); if (r.node(i).contentMatchAt(s).matchType(e)) return !0; i -= 1 } return !1 } const _S = /^\s*>\s$/, DS = ge.create({ name: "blockquote", addOptions() { return { HTMLAttributes: {} } }, content: "block+", group: "block", defining: !0, parseHTML() { return [{ tag: "blockquote" }] }, renderHTML({ HTMLAttributes: n }) { return ["blockquote", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name), toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name), unsetBlockquote: () => ({ commands: n }) => n.lift(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() } }, addInputRules() { return [mr({ find: _S, type: this.type })] } }), IS = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, PS = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, LS = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, BS = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, FS = Xe.create({ name: "bold", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "strong" }, { tag: "b", getAttrs: n => n.style.fontWeight !== "normal" && null }, { style: "font-weight=400", clearMark: n => n.type.name === this.name }, { style: "font-weight", getAttrs: n => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null }] }, renderHTML({ HTMLAttributes: n }) { return ["strong", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setBold: () => ({ commands: n }) => n.setMark(this.name), toggleBold: () => ({ commands: n }) => n.toggleMark(this.name), unsetBold: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-b": () => this.editor.commands.toggleBold(), "Mod-B": () => this.editor.commands.toggleBold() } }, addInputRules() { return [On({ find: IS, type: this.type }), On({ find: LS, type: this.type })] }, addPasteRules() { return [nn({ find: PS, type: this.type }), nn({ find: BS, type: this.type })] } }), zS = "listItem", zc = "textStyle", $c = /^\s*([-+*])\s$/, $S = ge.create({ name: "bulletList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, parseHTML() { return [{ tag: "ul" }] }, renderHTML({ HTMLAttributes: n }) { return ["ul", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { toggleBulletList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(zS, this.editor.getAttributes(zc)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() } }, addInputRules() { let n = mr({ find: $c, type: this.type }); return (this.options.keepMarks || this.options.keepAttributes) && (n = mr({ find: $c, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: () => this.editor.getAttributes(zc), editor: this.editor })), [n] } }), HS = /(^|[^`])`([^`]+)`(?!`)/, jS = /(^|[^`])`([^`]+)`(?!`)/g, VS = Xe.create({ name: "code", addOptions() { return { HTMLAttributes: {} } }, excludes: "_", code: !0, exitable: !0, parseHTML() { return [{ tag: "code" }] }, renderHTML({ HTMLAttributes: n }) { return ["code", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setCode: () => ({ commands: n }) => n.setMark(this.name), toggleCode: () => ({ commands: n }) => n.toggleMark(this.name), unsetCode: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-e": () => this.editor.commands.toggleCode() } }, addInputRules() { return [On({ find: HS, type: this.type })] }, addPasteRules() { return [nn({ find: jS, type: this.type })] } }), US = /^```([a-z]+)?[\s\n]$/, WS = /^~~~([a-z]+)?[\s\n]$/, KS = ge.create({
  name: "codeBlock", addOptions() { return { languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, defaultLanguage: null, HTMLAttributes: {} } }, content: "text*", marks: "", group: "block", code: !0, defining: !0, addAttributes() { return { language: { default: this.options.defaultLanguage, parseHTML: n => { var e; const { languageClassPrefix: t } = this.options, s = [...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(o => o.startsWith(t)).map(o => o.replace(t, ""))[0]; return s || null }, rendered: !1 } } }, parseHTML() { return [{ tag: "pre", preserveWhitespace: "full" }] }, renderHTML({ node: n, HTMLAttributes: e }) { return ["pre", ie(this.options.HTMLAttributes, e), ["code", { class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null }, 0]] }, addCommands() { return { setCodeBlock: n => ({ commands: e }) => e.setNode(this.name, n), toggleCodeBlock: n => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n) } }, addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => { const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1; return !n || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1 }, Enter: ({ editor: n }) => {
        if (!this.options.exitOnTripleEnter) return !1; const { state: e } = n, { selection: t } = e, { $from: r, empty: i } = t; if (!i || r.parent.type !== this.type) return !1; const s = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`); return !s || !o ? !1 : n.chain().command(({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0)).exitCode().run()
      }, ArrowDown: ({ editor: n }) => { if (!this.options.exitOnArrowDown) return !1; const { state: e } = n, { selection: t, doc: r } = e, { $from: i, empty: s } = t; if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return !1; const l = i.after(); return l === void 0 ? !1 : r.nodeAt(l) ? n.commands.command(({ tr: c }) => (c.setSelection(_.near(r.resolve(l))), !0)) : n.commands.exitCode() }
    }
  }, addInputRules() { return [zo({ find: US, type: this.type, getAttributes: n => ({ language: n[1] }) }), zo({ find: WS, type: this.type, getAttributes: n => ({ language: n[1] }) })] }, addProseMirrorPlugins() {
    return [new Q({
      key: new ye("codeBlockVSCodeHandler"), props: {
        handlePaste: (n, e) => {
          if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1; const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i?.mode; if (!t || !s) return !1; const { tr: o, schema: l } = n.state, a = l.text(t.replace(/\r\n?/g, `
`)); return o.replaceSelectionWith(this.type.create({ language: s }, a)), o.selection.$from.parent.type !== this.type && o.setSelection(R.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", !0), n.dispatch(o), !0
        }
      }
    })]
  }
}), qS = ge.create({ name: "doc", topNode: !0, content: "block+" }); function JS(n = {}) { return new Q({ view(e) { return new GS(e, n) } }) } class GS { constructor(e, t) { var r; this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(i => { let s = o => { this[i](o) }; return e.dom.addEventListener(i, s), { name: i, handler: s } }) } destroy() { this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t)) } update(e, t) { this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay()) } setCursor(e) { e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay()) } updateOverlay() { let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r, i = this.editorView.dom, s = i.getBoundingClientRect(), o = s.width / i.offsetWidth, l = s.height / i.offsetHeight; if (t) { let f = e.nodeBefore, d = e.nodeAfter; if (f || d) { let p = this.editorView.nodeDOM(this.cursorPos - (f ? f.nodeSize : 0)); if (p) { let h = p.getBoundingClientRect(), g = f ? h.bottom : h.top; f && d && (g = (g + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2); let m = this.width / 2 * l; r = { left: h.left, right: h.right, top: g - m, bottom: g + m } } } } if (!r) { let f = this.editorView.coordsAtPos(this.cursorPos), d = this.width / 2 * o; r = { left: f.left - d, right: f.left + d, top: f.top, bottom: f.bottom } } let a = this.editorView.dom.offsetParent; this.element || (this.element = a.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t); let c, u; if (!a || a == document.body && getComputedStyle(a).position == "static") c = -pageXOffset, u = -pageYOffset; else { let f = a.getBoundingClientRect(), d = f.width / a.offsetWidth, p = f.height / a.offsetHeight; c = f.left - a.scrollLeft * d, u = f.top - a.scrollTop * p } this.element.style.left = (r.left - c) / o + "px", this.element.style.top = (r.top - u) / l + "px", this.element.style.width = (r.right - r.left) / o + "px", this.element.style.height = (r.bottom - r.top) / l + "px" } scheduleRemoval(e) { clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e) } dragover(e) { if (!this.editorView.editable) return; let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i; if (t && !s) { let o = t.pos; if (this.editorView.dragging && this.editorView.dragging.slice) { let l = od(this.editorView.state.doc, o, this.editorView.dragging.slice); l != null && (o = l) } this.setCursor(o), this.scheduleRemoval(5e3) } } dragend() { this.scheduleRemoval(20) } drop() { this.scheduleRemoval(20) } dragleave(e) { this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null) } } const YS = le.create({ name: "dropCursor", addOptions() { return { color: "currentColor", width: 1, class: void 0 } }, addProseMirrorPlugins() { return [JS(this.options)] } }); class j extends _ { constructor(e) { super(e, e) } map(e, t) { let r = e.resolve(t.map(this.head)); return j.valid(r) ? new j(r) : _.near(r) } content() { return E.empty } eq(e) { return e instanceof j && e.head == this.head } toJSON() { return { type: "gapcursor", pos: this.head } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON"); return new j(e.resolve(t.pos)) } getBookmark() { return new Vl(this.anchor) } static valid(e) { let t = e.parent; if (t.isTextblock || !XS(e) || !QS(e)) return !1; let r = t.type.spec.allowGapCursor; if (r != null) return r; let i = t.contentMatchAt(e.index()).defaultType; return i && i.isTextblock } static findGapCursorFrom(e, t, r = !1) { e: for (; ;) { if (!r && j.valid(e)) return e; let i = e.pos, s = null; for (let o = e.depth; ; o--) { let l = e.node(o); if (t > 0 ? e.indexAfter(o) < l.childCount : e.index(o) > 0) { s = l.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1); break } else if (o == 0) return null; i += t; let a = e.doc.resolve(i); if (j.valid(a)) return a } for (; ;) { let o = t > 0 ? s.firstChild : s.lastChild; if (!o) { if (s.isAtom && !s.isText && !A.isSelectable(s)) { e = e.doc.resolve(i + s.nodeSize * t), r = !1; continue e } break } s = o, i += t; let l = e.doc.resolve(i); if (j.valid(l)) return l } return null } } } j.prototype.visible = !1; j.findFrom = j.findGapCursorFrom; _.jsonID("gapcursor", j); class Vl { constructor(e) { this.pos = e } map(e) { return new Vl(e.map(this.pos)) } resolve(e) { let t = e.resolve(this.pos); return j.valid(t) ? new j(t) : _.near(t) } } function xh(n) { return n.isAtom || n.spec.isolating || n.spec.createGapCursor } function XS(n) { for (let e = n.depth; e >= 0; e--) { let t = n.index(e), r = n.node(e); if (t == 0) { if (r.type.spec.isolating) return !0; continue } for (let i = r.child(t - 1); ; i = i.lastChild) { if (i.childCount == 0 && !i.inlineContent || xh(i.type)) return !0; if (i.inlineContent) return !1 } } return !0 } function QS(n) { for (let e = n.depth; e >= 0; e--) { let t = n.indexAfter(e), r = n.node(e); if (t == r.childCount) { if (r.type.spec.isolating) return !0; continue } for (let i = r.child(t); ; i = i.firstChild) { if (i.childCount == 0 && !i.inlineContent || xh(i.type)) return !0; if (i.inlineContent) return !1 } } return !0 } function ZS() { return new Q({ props: { decorations: rw, createSelectionBetween(n, e, t) { return e.pos == t.pos && j.valid(t) ? new j(t) : null }, handleClick: tw, handleKeyDown: ew, handleDOMEvents: { beforeinput: nw } } }) } const ew = Gd({ ArrowLeft: jr("horiz", -1), ArrowRight: jr("horiz", 1), ArrowUp: jr("vert", -1), ArrowDown: jr("vert", 1) }); function jr(n, e) { const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left"; return function (r, i, s) { let o = r.selection, l = e > 0 ? o.$to : o.$from, a = o.empty; if (o instanceof R) { if (!s.endOfTextblock(t) || l.depth == 0) return !1; a = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before()) } let c = j.findGapCursorFrom(l, e, a); return c ? (i && i(r.tr.setSelection(new j(c))), !0) : !1 } } function tw(n, e, t) { if (!n || !n.editable) return !1; let r = n.state.doc.resolve(e); if (!j.valid(r)) return !1; let i = n.posAtCoords({ left: t.clientX, top: t.clientY }); return i && i.inside > -1 && A.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new j(r))), !0) } function nw(n, e) { if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof j)) return !1; let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text); if (!r) return !1; let i = x.empty; for (let o = r.length - 1; o >= 0; o--)i = x.from(r[o].createAndFill(null, i)); let s = n.state.tr.replace(t.pos, t.pos, new E(i, 0, 0)); return s.setSelection(R.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1 } function rw(n) { if (!(n.selection instanceof j)) return null; let e = document.createElement("div"); return e.className = "ProseMirror-gapcursor", U.create(n.doc, [xe.widget(n.selection.head, e, { key: "gapcursor" })]) } const iw = le.create({ name: "gapCursor", addProseMirrorPlugins() { return [ZS()] }, extendNodeSchema(n) { var e; const t = { name: n.name, options: n.options, storage: n.storage }; return { allowGapCursor: (e = I(O(n, "allowGapCursor", t))) !== null && e !== void 0 ? e : null } } }), sw = ge.create({
  name: "hardBreak", addOptions() { return { keepMarks: !0, HTMLAttributes: {} } }, inline: !0, group: "inline", selectable: !1, linebreakReplacement: !0, parseHTML() { return [{ tag: "br" }] }, renderHTML({ HTMLAttributes: n }) { return ["br", ie(this.options.HTMLAttributes, n)] }, renderText() {
    return `
`}, addCommands() { return { setHardBreak: () => ({ commands: n, chain: e, state: t, editor: r }) => n.first([() => n.exitCode(), () => n.command(() => { const { selection: i, storedMarks: s } = t; if (i.$from.parent.type.spec.isolating) return !1; const { keepMarks: o } = this.options, { splittableMarks: l } = r.extensionManager, a = s || i.$to.parentOffset && i.$from.marks(); return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => { if (u && a && o) { const f = a.filter(d => l.includes(d.type.name)); c.ensureMarks(f) } return !0 }).run() })]) } }, addKeyboardShortcuts() { return { "Mod-Enter": () => this.editor.commands.setHardBreak(), "Shift-Enter": () => this.editor.commands.setHardBreak() } }
}), ow = ge.create({ name: "heading", addOptions() { return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} } }, content: "inline*", group: "block", defining: !0, addAttributes() { return { level: { default: 1, rendered: !1 } } }, parseHTML() { return this.options.levels.map(n => ({ tag: `h${n}`, attrs: { level: n } })) }, renderHTML({ node: n, HTMLAttributes: e }) { return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, ie(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setHeading: n => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1, toggleHeading: n => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1 } }, addKeyboardShortcuts() { return this.options.levels.reduce((n, e) => ({ ...n, [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e }) }), {}) }, addInputRules() { return this.options.levels.map(n => zo({ find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n}})\\s$`), type: this.type, getAttributes: { level: n } })) } }); var bi = 200, Y = function () { }; Y.prototype.append = function (e) { return e.length ? (e = Y.from(e), !this.length && e || e.length < bi && this.leafAppend(e) || this.length < bi && e.leafPrepend(this) || this.appendInner(e)) : this }; Y.prototype.prepend = function (e) { return e.length ? Y.from(e).append(this) : this }; Y.prototype.appendInner = function (e) { return new lw(this, e) }; Y.prototype.slice = function (e, t) { return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Y.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t)) }; Y.prototype.get = function (e) { if (!(e < 0 || e >= this.length)) return this.getInner(e) }; Y.prototype.forEach = function (e, t, r) { t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0) }; Y.prototype.map = function (e, t, r) { t === void 0 && (t = 0), r === void 0 && (r = this.length); var i = []; return this.forEach(function (s, o) { return i.push(e(s, o)) }, t, r), i }; Y.from = function (e) { return e instanceof Y ? e : e && e.length ? new Sh(e) : Y.empty }; var Sh = (function (n) { function e(r) { n.call(this), this.values = r } n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e; var t = { length: { configurable: !0 }, depth: { configurable: !0 } }; return e.prototype.flatten = function () { return this.values }, e.prototype.sliceInner = function (i, s) { return i == 0 && s == this.length ? this : new e(this.values.slice(i, s)) }, e.prototype.getInner = function (i) { return this.values[i] }, e.prototype.forEachInner = function (i, s, o, l) { for (var a = s; a < o; a++)if (i(this.values[a], l + a) === !1) return !1 }, e.prototype.forEachInvertedInner = function (i, s, o, l) { for (var a = s - 1; a >= o; a--)if (i(this.values[a], l + a) === !1) return !1 }, e.prototype.leafAppend = function (i) { if (this.length + i.length <= bi) return new e(this.values.concat(i.flatten())) }, e.prototype.leafPrepend = function (i) { if (this.length + i.length <= bi) return new e(i.flatten().concat(this.values)) }, t.length.get = function () { return this.values.length }, t.depth.get = function () { return 0 }, Object.defineProperties(e.prototype, t), e })(Y); Y.empty = new Sh([]); var lw = (function (n) { function e(t, r) { n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1 } return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, e.prototype.getInner = function (r) { return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length) }, e.prototype.forEachInner = function (r, i, s, o) { var l = this.left.length; if (i < l && this.left.forEachInner(r, i, Math.min(s, l), o) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, o + l) === !1) return !1 }, e.prototype.forEachInvertedInner = function (r, i, s, o) { var l = this.left.length; if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, o + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, o) === !1) return !1 }, e.prototype.sliceInner = function (r, i) { if (r == 0 && i == this.length) return this; var s = this.left.length; return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s)) }, e.prototype.leafAppend = function (r) { var i = this.right.leafAppend(r); if (i) return new e(this.left, i) }, e.prototype.leafPrepend = function (r) { var i = this.left.leafPrepend(r); if (i) return new e(i, this.right) }, e.prototype.appendInner = function (r) { return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r) }, e })(Y); const aw = 500; class Ne { constructor(e, t) { this.items = e, this.eventCount = t } popEvent(e, t) { if (this.eventCount == 0) return null; let r = this.items.length; for (; ; r--)if (this.items.get(r - 1).selection) { --r; break } let i, s; t && (i = this.remapping(r, this.items.length), s = i.maps.length); let o = e.tr, l, a, c = [], u = []; return this.items.forEach((f, d) => { if (!f.step) { i || (i = this.remapping(r, d + 1), s = i.maps.length), s--, u.push(f); return } if (i) { u.push(new Pe(f.map)); let p = f.step.map(i.slice(s)), h; p && o.maybeStep(p).doc && (h = o.mapping.maps[o.mapping.maps.length - 1], c.push(new Pe(h, void 0, void 0, c.length + u.length))), s--, h && i.appendMap(h, s) } else o.maybeStep(f.step); if (f.selection) return l = i ? f.selection.map(i.slice(s)) : f.selection, a = new Ne(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1 }, this.items.length, 0), { remaining: a, transform: o, selection: l } } addTransform(e, t, r, i) { let s = [], o = this.eventCount, l = this.items, a = !i && l.length ? l.get(l.length - 1) : null; for (let u = 0; u < e.steps.length; u++) { let f = e.steps[u].invert(e.docs[u]), d = new Pe(e.mapping.maps[u], f, t), p; (p = a && a.merge(d)) && (d = p, u ? s.pop() : l = l.slice(0, l.length - 1)), s.push(d), t && (o++, t = void 0), i || (a = d) } let c = o - r.depth; return c > uw && (l = cw(l, c), o -= c), new Ne(l.append(s), o) } remapping(e, t) { let r = new ar; return this.items.forEach((i, s) => { let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0; r.appendMap(i.map, o) }, e, t), r } addMaps(e) { return this.eventCount == 0 ? this : new Ne(this.items.append(e.map(t => new Pe(t))), this.eventCount) } rebased(e, t) { if (!this.eventCount) return this; let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, l = this.eventCount; this.items.forEach(d => { d.selection && l-- }, i); let a = t; this.items.forEach(d => { let p = s.getMirror(--a); if (p == null) return; o = Math.min(o, p); let h = s.maps[p]; if (d.step) { let g = e.steps[p].invert(e.docs[p]), m = d.selection && d.selection.map(s.slice(a + 1, p)); m && l++, r.push(new Pe(h, g, m)) } else r.push(new Pe(h)) }, i); let c = []; for (let d = t; d < o; d++)c.push(new Pe(s.maps[d])); let u = this.items.slice(0, i).append(c).append(r), f = new Ne(u, l); return f.emptyItemCount() > aw && (f = f.compress(this.items.length - r.length)), f } emptyItemCount() { let e = 0; return this.items.forEach(t => { t.step || e++ }), e } compress(e = this.items.length) { let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0; return this.items.forEach((o, l) => { if (l >= e) i.push(o), o.selection && s++; else if (o.step) { let a = o.step.map(t.slice(r)), c = a && a.getMap(); if (r--, c && t.appendMap(c, r), a) { let u = o.selection && o.selection.map(t.slice(r)); u && s++; let f = new Pe(c.invert(), a, u), d, p = i.length - 1; (d = i.length && i[p].merge(f)) ? i[p] = d : i.push(f) } } else o.map && r-- }, this.items.length, 0), new Ne(Y.from(i.reverse()), s) } } Ne.empty = new Ne(Y.empty, 0); function cw(n, e) { let t; return n.forEach((r, i) => { if (r.selection && e-- == 0) return t = i, !1 }), n.slice(t) } class Pe { constructor(e, t, r, i) { this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i } merge(e) { if (this.step && e.step && !e.selection) { let t = e.step.merge(this.step); if (t) return new Pe(t.getMap().invert(), t, this.selection) } } } class lt { constructor(e, t, r, i, s) { this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s } } const uw = 20; function fw(n, e, t, r) { let i = t.getMeta(Kt), s; if (i) return i.historyState; t.getMeta(pw) && (n = new lt(n.done, n.undone, null, 0, -1)); let o = t.getMeta("appendedTransaction"); if (t.steps.length == 0) return n; if (o && o.getMeta(Kt)) return o.getMeta(Kt).redo ? new lt(n.done.addTransform(t, void 0, r, Zr(e)), n.undone, Hc(t.mapping.maps), n.prevTime, n.prevComposition) : new lt(n.done, n.undone.addTransform(t, void 0, r, Zr(e)), null, n.prevTime, n.prevComposition); if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) { let l = t.getMeta("composition"), a = n.prevTime == 0 || !o && n.prevComposition != l && (n.prevTime < (t.time || 0) - r.newGroupDelay || !dw(t, n.prevRanges)), c = o ? Ks(n.prevRanges, t.mapping) : Hc(t.mapping.maps); return new lt(n.done.addTransform(t, a ? e.selection.getBookmark() : void 0, r, Zr(e)), Ne.empty, c, t.time, l ?? n.prevComposition) } else return (s = t.getMeta("rebased")) ? new lt(n.done.rebased(t, s), n.undone.rebased(t, s), Ks(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new lt(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), Ks(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) } function dw(n, e) { if (!e) return !1; if (!n.docChanged) return !0; let t = !1; return n.mapping.maps[0].forEach((r, i) => { for (let s = 0; s < e.length; s += 2)r <= e[s + 1] && i >= e[s] && (t = !0) }), t } function Hc(n) { let e = []; for (let t = n.length - 1; t >= 0 && e.length == 0; t--)n[t].forEach((r, i, s, o) => e.push(s, o)); return e } function Ks(n, e) { if (!n) return null; let t = []; for (let r = 0; r < n.length; r += 2) { let i = e.map(n[r], 1), s = e.map(n[r + 1], -1); i <= s && t.push(i, s) } return t } function hw(n, e, t) { let r = Zr(e), i = Kt.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r); if (!s) return null; let o = s.selection.resolve(s.transform.doc), l = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), a = new lt(t ? l : s.remaining, t ? s.remaining : l, null, 0, -1); return s.transform.setSelection(o).setMeta(Kt, { redo: t, historyState: a }) } let qs = !1, jc = null; function Zr(n) { let e = n.plugins; if (jc != e) { qs = !1, jc = e; for (let t = 0; t < e.length; t++)if (e[t].spec.historyPreserveItems) { qs = !0; break } } return qs } const Kt = new ye("history"), pw = new ye("closeHistory"); function mw(n = {}) { return n = { depth: n.depth || 100, newGroupDelay: n.newGroupDelay || 500 }, new Q({ key: Kt, state: { init() { return new lt(Ne.empty, Ne.empty, null, 0, -1) }, apply(e, t, r) { return fw(t, r, e, n) } }, config: n, props: { handleDOMEvents: { beforeinput(e, t) { let r = t.inputType, i = r == "historyUndo" ? kh : r == "historyRedo" ? Eh : null; return !i || !e.editable ? !1 : (t.preventDefault(), i(e.state, e.dispatch)) } } } }) } function wh(n, e) { return (t, r) => { let i = Kt.getState(t); if (!i || (n ? i.undone : i.done).eventCount == 0) return !1; if (r) { let s = hw(i, t, n); s && r(e ? s.scrollIntoView() : s) } return !0 } } const kh = wh(!1, !0), Eh = wh(!0, !0), gw = le.create({ name: "history", addOptions() { return { depth: 100, newGroupDelay: 500 } }, addCommands() { return { undo: () => ({ state: n, dispatch: e }) => kh(n, e), redo: () => ({ state: n, dispatch: e }) => Eh(n, e) } }, addProseMirrorPlugins() { return [mw(this.options)] }, addKeyboardShortcuts() { return { "Mod-z": () => this.editor.commands.undo(), "Shift-Mod-z": () => this.editor.commands.redo(), "Mod-y": () => this.editor.commands.redo(), "Mod-": () => this.editor.commands.undo(), "Shift-Mod-": () => this.editor.commands.redo() } } }), yw = ge.create({ name: "horizontalRule", addOptions() { return { HTMLAttributes: {} } }, group: "block", parseHTML() { return [{ tag: "hr" }] }, renderHTML({ HTMLAttributes: n }) { return ["hr", ie(this.options.HTMLAttributes, n)] }, addCommands() { return { setHorizontalRule: () => ({ chain: n, state: e }) => { if (!vS(e, e.schema.nodes[this.name])) return !1; const { selection: t } = e, { $from: r, $to: i } = t, s = n(); return r.parentOffset === 0 ? s.insertContentAt({ from: Math.max(r.pos - 1, 0), to: i.pos }, { type: this.name }) : Q1(t) ? s.insertContentAt(i.pos, { type: this.name }) : s.insertContent({ type: this.name }), s.command(({ tr: o, dispatch: l }) => { var a; if (l) { const { $to: c } = o.selection, u = c.end(); if (c.nodeAfter) c.nodeAfter.isTextblock ? o.setSelection(R.create(o.doc, c.pos + 1)) : c.nodeAfter.isBlock ? o.setSelection(A.create(o.doc, c.pos)) : o.setSelection(R.create(o.doc, c.pos)); else { const f = (a = c.parent.type.contentMatch.defaultType) === null || a === void 0 ? void 0 : a.create(); f && (o.insert(u, f), o.setSelection(R.create(o.doc, u + 1))) } o.scrollIntoView() } return !0 }).run() } } }, addInputRules() { return [RS({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })] } }), bw = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, xw = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Sw = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, ww = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, kw = Xe.create({ name: "italic", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "em" }, { tag: "i", getAttrs: n => n.style.fontStyle !== "normal" && null }, { style: "font-style=normal", clearMark: n => n.type.name === this.name }, { style: "font-style=italic" }] }, renderHTML({ HTMLAttributes: n }) { return ["em", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setItalic: () => ({ commands: n }) => n.setMark(this.name), toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name), unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-i": () => this.editor.commands.toggleItalic(), "Mod-I": () => this.editor.commands.toggleItalic() } }, addInputRules() { return [On({ find: bw, type: this.type }), On({ find: Sw, type: this.type })] }, addPasteRules() { return [nn({ find: xw, type: this.type }), nn({ find: ww, type: this.type })] } }), Ew = ge.create({ name: "listItem", addOptions() { return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" } }, content: "paragraph block*", defining: !0, parseHTML() { return [{ tag: "li" }] }, renderHTML({ HTMLAttributes: n }) { return ["li", ie(this.options.HTMLAttributes, n), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), Cw = "listItem", Vc = "textStyle", Uc = /^(\d+)\.\s$/, Ow = ge.create({ name: "orderedList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, addAttributes() { return { start: { default: 1, parseHTML: n => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1 }, type: { default: null, parseHTML: n => n.getAttribute("type") } } }, parseHTML() { return [{ tag: "ol" }] }, renderHTML({ HTMLAttributes: n }) { const { start: e, ...t } = n; return e === 1 ? ["ol", ie(this.options.HTMLAttributes, t), 0] : ["ol", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { toggleOrderedList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Cw, this.editor.getAttributes(Vc)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() } }, addInputRules() { let n = mr({ find: Uc, type: this.type, getAttributes: e => ({ start: +e[1] }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1] }); return (this.options.keepMarks || this.options.keepAttributes) && (n = mr({ find: Uc, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: e => ({ start: +e[1], ...this.editor.getAttributes(Vc) }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1], editor: this.editor })), [n] } }), Tw = ge.create({ name: "paragraph", priority: 1e3, addOptions() { return { HTMLAttributes: {} } }, group: "block", content: "inline*", parseHTML() { return [{ tag: "p" }] }, renderHTML({ HTMLAttributes: n }) { return ["p", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setParagraph: () => ({ commands: n }) => n.setNode(this.name) } }, addKeyboardShortcuts() { return { "Mod-Alt-0": () => this.editor.commands.setParagraph() } } }), Mw = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Aw = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Nw = Xe.create({ name: "strike", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: !1, getAttrs: n => n.includes("line-through") ? {} : !1 }] }, renderHTML({ HTMLAttributes: n }) { return ["s", ie(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setStrike: () => ({ commands: n }) => n.setMark(this.name), toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name), unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() } }, addInputRules() { return [On({ find: Mw, type: this.type })] }, addPasteRules() { return [nn({ find: Aw, type: this.type })] } }), Rw = ge.create({ name: "text", group: "inline" }), vw = le.create({ name: "starterKit", addExtensions() { const n = []; return this.options.bold !== !1 && n.push(FS.configure(this.options.bold)), this.options.blockquote !== !1 && n.push(DS.configure(this.options.blockquote)), this.options.bulletList !== !1 && n.push($S.configure(this.options.bulletList)), this.options.code !== !1 && n.push(VS.configure(this.options.code)), this.options.codeBlock !== !1 && n.push(KS.configure(this.options.codeBlock)), this.options.document !== !1 && n.push(qS.configure(this.options.document)), this.options.dropcursor !== !1 && n.push(YS.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && n.push(iw.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && n.push(sw.configure(this.options.hardBreak)), this.options.heading !== !1 && n.push(ow.configure(this.options.heading)), this.options.history !== !1 && n.push(gw.configure(this.options.history)), this.options.horizontalRule !== !1 && n.push(yw.configure(this.options.horizontalRule)), this.options.italic !== !1 && n.push(kw.configure(this.options.italic)), this.options.listItem !== !1 && n.push(Ew.configure(this.options.listItem)), this.options.orderedList !== !1 && n.push(Ow.configure(this.options.orderedList)), this.options.paragraph !== !1 && n.push(Tw.configure(this.options.paragraph)), this.options.strike !== !1 && n.push(Nw.configure(this.options.strike)), this.options.text !== !1 && n.push(Rw.configure(this.options.text)), n } }), _w = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Dw = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", $o = "numeric", Ho = "ascii", jo = "alpha", Xn = "asciinumeric", Un = "alphanumeric", Vo = "domain", Ch = "emoji", Iw = "scheme", Pw = "slashscheme", Js = "whitespace"; function Lw(n, e) { return n in e || (e[n] = []), e[n] } function Lt(n, e, t) { e[$o] && (e[Xn] = !0, e[Un] = !0), e[Ho] && (e[Xn] = !0, e[jo] = !0), e[Xn] && (e[Un] = !0), e[jo] && (e[Un] = !0), e[Un] && (e[Vo] = !0), e[Ch] && (e[Vo] = !0); for (const r in e) { const i = Lw(r, t); i.indexOf(n) < 0 && i.push(n) } } function Bw(n, e) { const t = {}; for (const r in e) e[r].indexOf(n) >= 0 && (t[r] = !0); return t } function de(n = null) { this.j = {}, this.jr = [], this.jd = null, this.t = n } de.groups = {}; de.prototype = { accepts() { return !!this.t }, go(n) { const e = this, t = e.j[n]; if (t) return t; for (let r = 0; r < e.jr.length; r++) { const i = e.jr[r][0], s = e.jr[r][1]; if (s && i.test(n)) return s } return e.jd }, has(n, e = !1) { return e ? n in this.j : !!this.go(n) }, ta(n, e, t, r) { for (let i = 0; i < n.length; i++)this.tt(n[i], e, t, r) }, tr(n, e, t, r) { r = r || de.groups; let i; return e && e.j ? i = e : (i = new de(e), t && r && Lt(e, t, r)), this.jr.push([n, i]), i }, ts(n, e, t, r) { let i = this; const s = n.length; if (!s) return i; for (let o = 0; o < s - 1; o++)i = i.tt(n[o]); return i.tt(n[s - 1], e, t, r) }, tt(n, e, t, r) { r = r || de.groups; const i = this; if (e && e.j) return i.j[n] = e, e; const s = e; let o, l = i.go(n); if (l ? (o = new de, Object.assign(o.j, l.j), o.jr.push.apply(o.jr, l.jr), o.jd = l.jd, o.t = l.t) : o = new de, s) { if (r) if (o.t && typeof o.t == "string") { const a = Object.assign(Bw(o.t, r), t); Lt(s, a, r) } else t && Lt(s, t, r); o.t = s } return i.j[n] = o, o } }; const v = (n, e, t, r, i) => n.ta(e, t, r, i), H = (n, e, t, r, i) => n.tr(e, t, r, i), Wc = (n, e, t, r, i) => n.ts(e, t, r, i), w = (n, e, t, r, i) => n.tt(e, t, r, i), We = "WORD", Uo = "UWORD", Oh = "ASCIINUMERICAL", Th = "ALPHANUMERICAL", gr = "LOCALHOST", Wo = "TLD", Ko = "UTLD", ei = "SCHEME", hn = "SLASH_SCHEME", Ul = "NUM", qo = "WS", Wl = "NL", Qn = "OPENBRACE", Zn = "CLOSEBRACE", xi = "OPENBRACKET", Si = "CLOSEBRACKET", wi = "OPENPAREN", ki = "CLOSEPAREN", Ei = "OPENANGLEBRACKET", Ci = "CLOSEANGLEBRACKET", Oi = "FULLWIDTHLEFTPAREN", Ti = "FULLWIDTHRIGHTPAREN", Mi = "LEFTCORNERBRACKET", Ai = "RIGHTCORNERBRACKET", Ni = "LEFTWHITECORNERBRACKET", Ri = "RIGHTWHITECORNERBRACKET", vi = "FULLWIDTHLESSTHAN", _i = "FULLWIDTHGREATERTHAN", Di = "AMPERSAND", Ii = "APOSTROPHE", Pi = "ASTERISK", at = "AT", Li = "BACKSLASH", Bi = "BACKTICK", Fi = "CARET", ut = "COLON", Kl = "COMMA", zi = "DOLLAR", Le = "DOT", $i = "EQUALS", ql = "EXCLAMATION", ke = "HYPHEN", er = "PERCENT", Hi = "PIPE", ji = "PLUS", Vi = "POUND", tr = "QUERY", Jl = "QUOTE", Mh = "FULLWIDTHMIDDLEDOT", Gl = "SEMI", Be = "SLASH", nr = "TILDE", Ui = "UNDERSCORE", Ah = "EMOJI", Wi = "SYM"; var Nh = Object.freeze({ __proto__: null, ALPHANUMERICAL: Th, AMPERSAND: Di, APOSTROPHE: Ii, ASCIINUMERICAL: Oh, ASTERISK: Pi, AT: at, BACKSLASH: Li, BACKTICK: Bi, CARET: Fi, CLOSEANGLEBRACKET: Ci, CLOSEBRACE: Zn, CLOSEBRACKET: Si, CLOSEPAREN: ki, COLON: ut, COMMA: Kl, DOLLAR: zi, DOT: Le, EMOJI: Ah, EQUALS: $i, EXCLAMATION: ql, FULLWIDTHGREATERTHAN: _i, FULLWIDTHLEFTPAREN: Oi, FULLWIDTHLESSTHAN: vi, FULLWIDTHMIDDLEDOT: Mh, FULLWIDTHRIGHTPAREN: Ti, HYPHEN: ke, LEFTCORNERBRACKET: Mi, LEFTWHITECORNERBRACKET: Ni, LOCALHOST: gr, NL: Wl, NUM: Ul, OPENANGLEBRACKET: Ei, OPENBRACE: Qn, OPENBRACKET: xi, OPENPAREN: wi, PERCENT: er, PIPE: Hi, PLUS: ji, POUND: Vi, QUERY: tr, QUOTE: Jl, RIGHTCORNERBRACKET: Ai, RIGHTWHITECORNERBRACKET: Ri, SCHEME: ei, SEMI: Gl, SLASH: Be, SLASH_SCHEME: hn, SYM: Wi, TILDE: nr, TLD: Wo, UNDERSCORE: Ui, UTLD: Ko, UWORD: Uo, WORD: We, WS: qo }); const Ve = /[a-z]/, zn = new RegExp("\\p{L}", "u"), Gs = new RegExp("\\p{Emoji}", "u"), Ue = /\d/, Ys = /\s/, Kc = "\r", Xs = `
`, Fw = "", zw = "", Qs = ""; let Vr = null, Ur = null; function $w(n = []) { const e = {}; de.groups = e; const t = new de; Vr == null && (Vr = qc(_w)), Ur == null && (Ur = qc(Dw)), w(t, "'", Ii), w(t, "{", Qn), w(t, "}", Zn), w(t, "[", xi), w(t, "]", Si), w(t, "(", wi), w(t, ")", ki), w(t, "<", Ei), w(t, ">", Ci), w(t, "", Oi), w(t, "", Ti), w(t, "", Mi), w(t, "", Ai), w(t, "", Ni), w(t, "", Ri), w(t, "", vi), w(t, "", _i), w(t, "&", Di), w(t, "*", Pi), w(t, "@", at), w(t, "`", Bi), w(t, "^", Fi), w(t, ":", ut), w(t, ",", Kl), w(t, "$", zi), w(t, ".", Le), w(t, "=", $i), w(t, "!", ql), w(t, "-", ke), w(t, "%", er), w(t, "|", Hi), w(t, "+", ji), w(t, "#", Vi), w(t, "?", tr), w(t, '"', Jl), w(t, "/", Be), w(t, ";", Gl), w(t, "~", nr), w(t, "_", Ui), w(t, "\\", Li), w(t, "", Mh); const r = H(t, Ue, Ul, { [$o]: !0 }); H(r, Ue, r); const i = H(r, Ve, Oh, { [Xn]: !0 }), s = H(r, zn, Th, { [Un]: !0 }), o = H(t, Ve, We, { [Ho]: !0 }); H(o, Ue, i), H(o, Ve, o), H(i, Ue, i), H(i, Ve, i); const l = H(t, zn, Uo, { [jo]: !0 }); H(l, Ve), H(l, Ue, s), H(l, zn, l), H(s, Ue, s), H(s, Ve), H(s, zn, s); const a = w(t, Xs, Wl, { [Js]: !0 }), c = w(t, Kc, qo, { [Js]: !0 }), u = H(t, Ys, qo, { [Js]: !0 }); w(t, Qs, u), w(c, Xs, a), w(c, Qs, u), H(c, Ys, u), w(u, Kc), w(u, Xs), H(u, Ys, u), w(u, Qs, u); const f = H(t, Gs, Ah, { [Ch]: !0 }); w(f, "#"), H(f, Gs, f), w(f, Fw, f); const d = w(f, zw); w(d, "#"), H(d, Gs, f); const p = [[Ve, o], [Ue, i]], h = [[Ve, null], [zn, l], [Ue, s]]; for (let g = 0; g < Vr.length; g++)it(t, Vr[g], Wo, We, p); for (let g = 0; g < Ur.length; g++)it(t, Ur[g], Ko, Uo, h); Lt(Wo, { tld: !0, ascii: !0 }, e), Lt(Ko, { utld: !0, alpha: !0 }, e), it(t, "file", ei, We, p), it(t, "mailto", ei, We, p), it(t, "http", hn, We, p), it(t, "https", hn, We, p), it(t, "ftp", hn, We, p), it(t, "ftps", hn, We, p), Lt(ei, { scheme: !0, ascii: !0 }, e), Lt(hn, { slashscheme: !0, ascii: !0 }, e), n = n.sort((g, m) => g[0] > m[0] ? 1 : -1); for (let g = 0; g < n.length; g++) { const m = n[g][0], S = n[g][1] ? { [Iw]: !0 } : { [Pw]: !0 }; m.indexOf("-") >= 0 ? S[Vo] = !0 : Ve.test(m) ? Ue.test(m) ? S[Xn] = !0 : S[Ho] = !0 : S[$o] = !0, Wc(t, m, m, S) } return Wc(t, "localhost", gr, { ascii: !0 }), t.jd = new de(Wi), { start: t, tokens: Object.assign({ groups: e }, Nh) } } function Rh(n, e) { const t = Hw(e.replace(/[A-Z]/g, l => l.toLowerCase())), r = t.length, i = []; let s = 0, o = 0; for (; o < r;) { let l = n, a = null, c = 0, u = null, f = -1, d = -1; for (; o < r && (a = l.go(t[o]));)l = a, l.accepts() ? (f = 0, d = 0, u = l) : f >= 0 && (f += t[o].length, d++), c += t[o].length, s += t[o].length, o++; s -= f, o -= d, c -= f, i.push({ t: u.t, v: e.slice(s - c, s), s: s - c, e: s }) } return i } function Hw(n) { const e = [], t = n.length; let r = 0; for (; r < t;) { let i = n.charCodeAt(r), s, o = i < 55296 || i > 56319 || r + 1 === t || (s = n.charCodeAt(r + 1)) < 56320 || s > 57343 ? n[r] : n.slice(r, r + 2); e.push(o), r += o.length } return e } function it(n, e, t, r, i) { let s; const o = e.length; for (let l = 0; l < o - 1; l++) { const a = e[l]; n.j[a] ? s = n.j[a] : (s = new de(r), s.jr = i.slice(), n.j[a] = s), n = s } return s = new de(t), s.jr = i.slice(), n.j[e[o - 1]] = s, s } function qc(n) { const e = [], t = []; let r = 0, i = "0123456789"; for (; r < n.length;) { let s = 0; for (; i.indexOf(n[r + s]) >= 0;)s++; if (s > 0) { e.push(t.join("")); for (let o = parseInt(n.substring(r, r + s), 10); o > 0; o--)t.pop(); r += s } else t.push(n[r]), r++ } return e } const yr = { defaultProtocol: "http", events: null, format: Jc, formatHref: Jc, nl2br: !1, tagName: "a", target: null, rel: null, validate: !0, truncate: 1 / 0, className: null, attributes: null, ignoreTags: [], render: null }; function Yl(n, e = null) { let t = Object.assign({}, yr); n && (t = Object.assign(t, n instanceof Yl ? n.o : n)); const r = t.ignoreTags, i = []; for (let s = 0; s < r.length; s++)i.push(r[s].toUpperCase()); this.o = t, e && (this.defaultRender = e), this.ignoreTags = i } Yl.prototype = { o: yr, ignoreTags: [], defaultRender(n) { return n }, check(n) { return this.get("validate", n.toString(), n) }, get(n, e, t) { const r = e != null; let i = this.o[n]; return i && (typeof i == "object" ? (i = t.t in i ? i[t.t] : yr[n], typeof i == "function" && r && (i = i(e, t))) : typeof i == "function" && r && (i = i(e, t.t, t)), i) }, getObj(n, e, t) { let r = this.o[n]; return typeof r == "function" && e != null && (r = r(e, t.t, t)), r }, render(n) { const e = n.render(this); return (this.get("render", null, n) || this.defaultRender)(e, n.t, n) } }; function Jc(n) { return n } function vh(n, e) { this.t = "token", this.v = n, this.tk = e } vh.prototype = { isLink: !1, toString() { return this.v }, toHref(n) { return this.toString() }, toFormattedString(n) { const e = this.toString(), t = n.get("truncate", e, this), r = n.get("format", e, this); return t && r.length > t ? r.substring(0, t) + "" : r }, toFormattedHref(n) { return n.get("formatHref", this.toHref(n.get("defaultProtocol")), this) }, startIndex() { return this.tk[0].s }, endIndex() { return this.tk[this.tk.length - 1].e }, toObject(n = yr.defaultProtocol) { return { type: this.t, value: this.toString(), isLink: this.isLink, href: this.toHref(n), start: this.startIndex(), end: this.endIndex() } }, toFormattedObject(n) { return { type: this.t, value: this.toFormattedString(n), isLink: this.isLink, href: this.toFormattedHref(n), start: this.startIndex(), end: this.endIndex() } }, validate(n) { return n.get("validate", this.toString(), this) }, render(n) { const e = this, t = this.toHref(n.get("defaultProtocol")), r = n.get("formatHref", t, this), i = n.get("tagName", t, e), s = this.toFormattedString(n), o = {}, l = n.get("className", t, e), a = n.get("target", t, e), c = n.get("rel", t, e), u = n.getObj("attributes", t, e), f = n.getObj("events", t, e); return o.href = r, l && (o.class = l), a && (o.target = a), c && (o.rel = c), u && Object.assign(o, u), { tagName: i, attributes: o, content: s, eventListeners: f } } }; function xs(n, e) { class t extends vh { constructor(i, s) { super(i, s), this.t = n } } for (const r in e) t.prototype[r] = e[r]; return t.t = n, t } const Gc = xs("email", { isLink: !0, toHref() { return "mailto:" + this.toString() } }), Yc = xs("text"), jw = xs("nl"), Wr = xs("url", { isLink: !0, toHref(n = yr.defaultProtocol) { return this.hasProtocol() ? this.v : `${n}://${this.v}` }, hasProtocol() { const n = this.tk; return n.length >= 2 && n[0].t !== gr && n[1].t === ut } }), we = n => new de(n); function Vw({ groups: n }) { const e = n.domain.concat([Di, Pi, at, Li, Bi, Fi, zi, $i, ke, Ul, er, Hi, ji, Vi, Be, Wi, nr, Ui]), t = [Ii, ut, Kl, Le, ql, er, tr, Jl, Gl, Ei, Ci, Qn, Zn, Si, xi, wi, ki, Oi, Ti, Mi, Ai, Ni, Ri, vi, _i], r = [Di, Ii, Pi, Li, Bi, Fi, zi, $i, ke, Qn, Zn, er, Hi, ji, Vi, tr, Be, Wi, nr, Ui], i = we(), s = w(i, nr); v(s, r, s), v(s, n.domain, s); const o = we(), l = we(), a = we(); v(i, n.domain, o), v(i, n.scheme, l), v(i, n.slashscheme, a), v(o, r, s), v(o, n.domain, o); const c = w(o, at); w(s, at, c), w(l, at, c), w(a, at, c); const u = w(s, Le); v(u, r, s), v(u, n.domain, s); const f = we(); v(c, n.domain, f), v(f, n.domain, f); const d = w(f, Le); v(d, n.domain, f); const p = we(Gc); v(d, n.tld, p), v(d, n.utld, p), w(c, gr, p); const h = w(f, ke); w(h, ke, h), v(h, n.domain, f), v(p, n.domain, f), w(p, Le, d), w(p, ke, h); const g = w(p, ut); v(g, n.numeric, Gc); const m = w(o, ke), y = w(o, Le); w(m, ke, m), v(m, n.domain, o), v(y, r, s), v(y, n.domain, o); const S = we(Wr); v(y, n.tld, S), v(y, n.utld, S), v(S, n.domain, o), v(S, r, s), w(S, Le, y), w(S, ke, m), w(S, at, c); const k = w(S, ut), M = we(Wr); v(k, n.numeric, M); const T = we(Wr), D = we(); v(T, e, T), v(T, t, D), v(D, e, T), v(D, t, D), w(S, Be, T), w(M, Be, T); const C = w(l, ut), P = w(a, ut), B = w(P, Be), De = w(B, Be); v(l, n.domain, o), w(l, Le, y), w(l, ke, m), v(a, n.domain, o), w(a, Le, y), w(a, ke, m), v(C, n.domain, T), w(C, Be, T), w(C, tr, T), v(De, n.domain, T), v(De, e, T), w(De, Be, T); const Dn = [[Qn, Zn], [xi, Si], [wi, ki], [Ei, Ci], [Oi, Ti], [Mi, Ai], [Ni, Ri], [vi, _i]]; for (let Qe = 0; Qe < Dn.length; Qe++) { const [Ze, Ae] = Dn[Qe], Tt = w(T, Ze); w(D, Ze, Tt), w(Tt, Ae, T); const Z = we(Wr); v(Tt, e, Z); const et = we(); v(Tt, t), v(Z, e, Z), v(Z, t, et), v(et, e, Z), v(et, t, et), w(Z, Ae, T), w(et, Ae, T) } return w(i, gr, S), w(i, Wl, jw), { start: i, tokens: Nh } } function Uw(n, e, t) { let r = t.length, i = 0, s = [], o = []; for (; i < r;) { let l = n, a = null, c = null, u = 0, f = null, d = -1; for (; i < r && !(a = l.go(t[i].t));)o.push(t[i++]); for (; i < r && (c = a || l.go(t[i].t));)a = null, l = c, l.accepts() ? (d = 0, f = l) : d >= 0 && d++, i++, u++; if (d < 0) i -= u, i < r && (o.push(t[i]), i++); else { o.length > 0 && (s.push(Zs(Yc, e, o)), o = []), i -= d, u -= d; const p = f.t, h = t.slice(i - u, i); s.push(Zs(p, e, h)) } } return o.length > 0 && s.push(Zs(Yc, e, o)), s } function Zs(n, e, t) { const r = t[0].s, i = t[t.length - 1].e, s = e.slice(r, i); return new n(s, t) } const Ww = typeof console < "u" && console && console.warn || (() => { }), Kw = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", F = { scanner: null, parser: null, tokenQueue: [], pluginQueue: [], customSchemes: [], initialized: !1 }; function qw() { return de.groups = {}, F.scanner = null, F.parser = null, F.tokenQueue = [], F.pluginQueue = [], F.customSchemes = [], F.initialized = !1, F } function Xc(n, e = !1) {
  if (F.initialized && Ww(`linkifyjs: already initialized - will not register custom scheme "${n}" ${Kw}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(n)) throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`); F.customSchemes.push([n, e])
} function Jw() { F.scanner = $w(F.customSchemes); for (let n = 0; n < F.tokenQueue.length; n++)F.tokenQueue[n][1]({ scanner: F.scanner }); F.parser = Vw(F.scanner.tokens); for (let n = 0; n < F.pluginQueue.length; n++)F.pluginQueue[n][1]({ scanner: F.scanner, parser: F.parser }); return F.initialized = !0, F } function Xl(n) { return F.initialized || Jw(), Uw(F.parser.start, n, Rh(F.scanner.start, n)) } Xl.scan = Rh; function _h(n, e = null, t = null) { if (e && typeof e == "object") { if (t) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`); t = e, e = null } const r = new Yl(t), i = Xl(n), s = []; for (let o = 0; o < i.length; o++) { const l = i[o]; l.isLink && (!e || l.t === e) && r.check(l) && s.push(l.toFormattedObject(r)) } return s } const Ql = "[\0- -\u2029]", Gw = new RegExp(Ql), Yw = new RegExp(`${Ql}$`), Xw = new RegExp(Ql, "g"); function Qw(n) { return n.length === 1 ? n[0].isLink : n.length === 3 && n[1].isLink ? ["()", "[]"].includes(n[0].value + n[2].value) : !1 } function Zw(n) { return new Q({ key: new ye("autolink"), appendTransaction: (e, t, r) => { const i = e.some(c => c.docChanged) && !t.doc.eq(r.doc), s = e.some(c => c.getMeta("preventAutolink")); if (!i || s) return; const { tr: o } = r, l = j1(t.doc, [...e]); if (Y1(l).forEach(({ newRange: c }) => { const u = U1(r.doc, c, p => p.isTextblock); let f, d; if (u.length > 1) f = u[0], d = r.doc.textBetween(f.pos, f.pos + f.node.nodeSize, void 0, " "); else if (u.length) { const p = r.doc.textBetween(c.from, c.to, " ", " "); if (!Yw.test(p)) return; f = u[0], d = r.doc.textBetween(f.pos, c.to, void 0, " ") } if (f && d) { const p = d.split(Gw).filter(Boolean); if (p.length <= 0) return !1; const h = p[p.length - 1], g = f.pos + d.lastIndexOf(h); if (!h) return !1; const m = Xl(h).map(y => y.toObject(n.defaultProtocol)); if (!Qw(m)) return !1; m.filter(y => y.isLink).map(y => ({ ...y, from: g + y.start + 1, to: g + y.end + 1 })).filter(y => r.schema.marks.code ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code) : !0).filter(y => n.validate(y.value)).filter(y => n.shouldAutoLink(y.value)).forEach(y => { jl(y.from, y.to, r.doc).some(S => S.mark.type === n.type) || o.addMark(y.from, y.to, n.type.create({ href: y.href })) }) } }), !!o.steps.length) return o } }) } function ek(n) { return new Q({ key: new ye("handleClickLink"), props: { handleClick: (e, t, r) => { var i, s; if (r.button !== 0 || !e.editable) return !1; let o = r.target; const l = []; for (; o.nodeName !== "DIV";)l.push(o), o = o.parentNode; if (!l.find(d => d.nodeName === "A")) return !1; const a = bh(e.state, n.type.name), c = r.target, u = (i = c?.href) !== null && i !== void 0 ? i : a.href, f = (s = c?.target) !== null && s !== void 0 ? s : a.target; return c && u ? (window.open(u, f), !0) : !1 } } }) } function tk(n) { return new Q({ key: new ye("handlePasteLink"), props: { handlePaste: (e, t, r) => { const { state: i } = e, { selection: s } = i, { empty: o } = s; if (o) return !1; let l = ""; r.content.forEach(c => { l += c.textContent }); const a = _h(l, { defaultProtocol: n.defaultProtocol }).find(c => c.isLink && c.value === l); return !l || !a ? !1 : n.editor.commands.setMark(n.type, { href: a.href }) } } }) } function Mt(n, e) { const t = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"]; return e && e.forEach(r => { const i = typeof r == "string" ? r : r.scheme; i && t.push(i) }), !n || n.replace(Xw, "").match(new RegExp(`^(?:(?:${t.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, "i")) } const nk = Xe.create({ name: "link", priority: 1e3, keepOnSplit: !1, exitable: !0, onCreate() { this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach(n => { if (typeof n == "string") { Xc(n); return } Xc(n.scheme, n.optionalSlashes) }) }, onDestroy() { qw() }, inclusive() { return this.options.autolink }, addOptions() { return { openOnClick: !0, linkOnPaste: !0, autolink: !0, protocols: [], defaultProtocol: "http", HTMLAttributes: { target: "_blank", rel: "noopener noreferrer nofollow", class: null }, isAllowedUri: (n, e) => !!Mt(n, e.protocols), validate: n => !!n, shouldAutoLink: n => !!n } }, addAttributes() { return { href: { default: null, parseHTML(n) { return n.getAttribute("href") } }, target: { default: this.options.HTMLAttributes.target }, rel: { default: this.options.HTMLAttributes.rel }, class: { default: this.options.HTMLAttributes.class } } }, parseHTML() { return [{ tag: "a[href]", getAttrs: n => { const e = n.getAttribute("href"); return !e || !this.options.isAllowedUri(e, { defaultValidate: t => !!Mt(t, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? !1 : null } }] }, renderHTML({ HTMLAttributes: n }) { return this.options.isAllowedUri(n.href, { defaultValidate: e => !!Mt(e, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? ["a", ie(this.options.HTMLAttributes, n), 0] : ["a", ie(this.options.HTMLAttributes, { ...n, href: "" }), 0] }, addCommands() { return { setLink: n => ({ chain: e }) => { const { href: t } = n; return this.options.isAllowedUri(t, { defaultValidate: r => !!Mt(r, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? e().setMark(this.name, n).setMeta("preventAutolink", !0).run() : !1 }, toggleLink: n => ({ chain: e }) => { const { href: t } = n; return this.options.isAllowedUri(t, { defaultValidate: r => !!Mt(r, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? e().toggleMark(this.name, n, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1 }, unsetLink: () => ({ chain: n }) => n().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() } }, addPasteRules() { return [nn({ find: n => { const e = []; if (n) { const { protocols: t, defaultProtocol: r } = this.options, i = _h(n).filter(s => s.isLink && this.options.isAllowedUri(s.value, { defaultValidate: o => !!Mt(o, t), protocols: t, defaultProtocol: r })); i.length && i.forEach(s => e.push({ text: s.value, data: { href: s.href }, index: s.start })) } return e }, type: this.type, getAttributes: n => { var e; return { href: (e = n.data) === null || e === void 0 ? void 0 : e.href } } })] }, addProseMirrorPlugins() { const n = [], { protocols: e, defaultProtocol: t } = this.options; return this.options.autolink && n.push(Zw({ type: this.type, defaultProtocol: this.options.defaultProtocol, validate: r => this.options.isAllowedUri(r, { defaultValidate: i => !!Mt(i, e), protocols: e, defaultProtocol: t }), shouldAutoLink: this.options.shouldAutoLink })), this.options.openOnClick === !0 && n.push(ek({ type: this.type })), this.options.linkOnPaste && n.push(tk({ editor: this.editor, defaultProtocol: this.options.defaultProtocol, type: this.type })), n } }), rk = le.create({ name: "placeholder", addOptions() { return { emptyEditorClass: "is-editor-empty", emptyNodeClass: "is-empty", placeholder: "Write something ", showOnlyWhenEditable: !0, showOnlyCurrent: !0, includeChildren: !1 } }, addProseMirrorPlugins() { return [new Q({ key: new ye("placeholder"), props: { decorations: ({ doc: n, selection: e }) => { const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = []; if (!t) return null; const s = this.editor.isEmpty; return n.descendants((o, l) => { const a = r >= l && r <= l + o.nodeSize, c = !o.isLeaf && bs(o); if ((a || !this.options.showOnlyCurrent) && c) { const u = [this.options.emptyNodeClass]; s && u.push(this.options.emptyEditorClass); const f = xe.node(l, l + o.nodeSize, { class: u.join(" "), "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({ editor: this.editor, node: o, pos: l, hasAnchor: a }) : this.options.placeholder }); i.push(f) } return this.options.includeChildren }), U.create(n, i) } } })] } }); function Dh(n = {}) { let e = null; return { content: n.content || "", init() { e || this.$nextTick(() => { try { e = new NS({ element: this.$refs.editor, extensions: [vw.configure({ heading: { levels: [1, 2, 3] } }), nk.configure({ openOnClick: !1, HTMLAttributes: { class: "text-brand-600 underline" } }), rk.configure({ placeholder: n.placeholder || "Write something..." })], content: this.content, onUpdate: ({ editor: t }) => { this.content = t.getHTML() }, onTransaction: () => { } }), console.log("Tiptap editor initialized successfully (Closure Mode)") } catch (t) { console.error("Failed to initialize Tiptap:", t) } }) }, isActive(t, r = {}) { if (!e) return !1; try { return e.isActive(t, r) } catch { return !1 } }, toggleHeading(t) { e && e.chain().focus().toggleHeading({ level: t }).run() }, toggleBold() { e && e.chain().focus().toggleBold().run() }, toggleBulletList() { e && e.chain().focus().toggleBulletList().run() }, setLink() { if (!e) return; const t = window.prompt("URL", e.getAttributes("link").href); if (t === "") { e.chain().focus().extendMarkRange("link").unsetLink().run(); return } t && e.chain().focus().extendMarkRange("link").setLink({ href: t }).run() }, clearFormatting() { e && e.chain().focus().unsetAllMarks().clearNodes().run() }, destroy() { e && (e.destroy(), e = null) } } } function ik(n = {}) { return { tab: "post", postId: n.postId, insights: null, loadingInsights: !1, reactions: [], reactionsPage: 1, hasMoreReactions: !0, loadingReactions: !1, comments: [], commentsPage: 1, hasMoreComments: !0, loadingComments: !1, replyMode: !1, selectedComment: null, replyContent: "", submitting: !1, init() { }, setTab(e) { this.tab = e, e === "reactions" && this.reactions.length === 0 && this.loadMoreReactions(), e === "comments" && this.comments.length === 0 && this.loadMoreComments(), e === "insights" && !this.insights && this.fetchInsights() }, async fetchInsights() { if (!this.loadingInsights) { this.loadingInsights = !0; try { const e = await axios.get(`/admin/news_events/${this.postId}/insights`); this.insights = e.data } catch (e) { console.error("Failed to fetch insights", e) } finally { this.loadingInsights = !1 } } }, async loadMoreReactions() { if (!(this.loadingReactions || !this.hasMoreReactions)) { this.loadingReactions = !0; try { const t = (await axios.get(`/admin/news_events/${this.postId}/reactions?page=${this.reactionsPage}`)).data; this.reactions.push(...t.data), this.hasMoreReactions = !!t.next_page_url, this.reactionsPage++ } catch (e) { console.error("Failed to load reactions", e) } finally { this.loadingReactions = !1 } } }, async loadMoreComments() { if (!(this.loadingComments || !this.hasMoreComments)) { this.loadingComments = !0; try { const t = (await axios.get(`/admin/news_events/${this.postId}/comments?page=${this.commentsPage}`)).data; this.comments.push(...t.data), this.hasMoreComments = !!t.next_page_url, this.commentsPage++ } catch (e) { console.error("Failed to load comments", e) } finally { this.loadingComments = !1 } } }, replyTo(e) { this.selectedComment = e, this.replyMode = !0, this.replyContent = "" }, async submitReply() { if (!(!this.replyContent.trim() || this.submitting)) { this.submitting = !0; try { const e = await axios.post(`/admin/news_events/comments/${this.selectedComment.id}/reply`, { content: this.replyContent }); window.showToast && window.showToast(e.data.success || "Reply sent"), this.replyMode = !1, this.comments = [], this.commentsPage = 1, this.hasMoreComments = !0, this.loadMoreComments() } catch (e) { window.showToast && window.showToast(e.response?.data?.message || "Failed to send reply", "error") } finally { this.submitting = !1 } } }, confirmDeleteComment(e) { confirm("Are you sure you want to delete this comment?") && this.deleteComment(e) }, async deleteComment(e) { try { const t = await axios.delete(`/admin/news_events/comments/${e}`); window.showToast && window.showToast(t.data.success || "Comment removed"), this.comments = this.comments.filter(r => r.id !== e) } catch { window.showToast && window.showToast("Failed to delete comment", "error") } }, formatDate(e) { return new Date(e).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric", hour: "2-digit", minute: "2-digit" }) } } } function sk(n = {}) { return { postId: n.postId, comments: n.initialComments || [], cursor: n.nextPage || null, hasMore: !!n.nextPage, loading: !1, totalComments: n.initialCount || 0, expandedComments: [], content: "", parentId: null, submitting: !1, reactionCount: n.initialReactionCount || 0, userReacted: n.userReacted || !1, async init() { }, isExpanded(e) { return this.expandedComments.includes(e) }, toggleExpanded(e) { this.isExpanded(e) ? this.expandedComments = this.expandedComments.filter(t => t !== e) : this.expandedComments.push(e) }, async loadMore() { if (!(this.loading || !this.hasMore)) { this.loading = !0; try { let e = `/news/${this.postId}/comments`; this.cursor && (e = this.cursor); const r = (await axios.get(e)).data; this.comments.push(...r.data), this.cursor = r.next_page_url, this.hasMore = !!r.next_page_url } catch (e) { console.error("Failed to load comments", e) } finally { this.loading = !1 } } }, async submitComment() { if (!(!this.content.trim() || this.submitting)) { this.submitting = !0; try { const e = await axios.post(`/news/${this.postId}/comment`, { content: this.content, parent_id: this.parentId }); if (e.data.status === "success") { const t = e.data.comment; if (this.parentId) { const r = this.comments.find(i => i.id === this.parentId); r && (r.replies || (r.replies = []), r.replies.unshift(t), this.isExpanded(this.parentId) || this.expandedComments.push(this.parentId)) } else this.comments.unshift(t); this.content = "", this.parentId = null, this.totalComments = e.data.count, window.dispatchEvent(new CustomEvent("comment-added", { detail: { postId: this.postId, count: this.totalComments } })), window.showToast && window.showToast("Comment posted successfully") } } catch (e) { window.showToast && window.showToast(e.response?.data?.message || "Failed to post comment", "error") } finally { this.submitting = !1 } } }, async toggleReaction(e = "like") { try { const t = await axios.post(`/news/${this.postId}/react`, { type: e }); t.data.status === "success" && (this.reactionCount = t.data.count, this.userReacted = t.data.action !== "removed", window.dispatchEvent(new CustomEvent("reaction-toggled", { detail: { postId: this.postId, count: this.reactionCount, userReacted: this.userReacted } }))) } catch (t) { console.error("Reaction failed", t) } }, async deleteComment(e) { if (confirm("Are you sure you want to delete this comment?")) try { (await axios.delete(`/news/comment/${e}`)).data.status === "success" && (this.comments = this.comments.filter(r => r.id === e ? !1 : (r.replies && (r.replies = r.replies.filter(i => i.id !== e)), !0)), window.showToast && window.showToast("Comment deleted")) } catch { window.showToast && window.showToast("Failed to delete comment", "error") } }, formatDate(e) { return new Date(e).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric", hour: "2-digit", minute: "2-digit" }) } } } sn.plugin(Oy); sn.plugin(Ry); sn.data("tiptapEditor", Dh); sn.data("moderationDashboard", ik); sn.data("newsComments", sk); window.tiptapEditor = Dh; window.Alpine = sn; window.showToast = (n, e = "success") => { window.dispatchEvent(new CustomEvent("toast", { detail: { message: n, type: e } })) }; sn.start();
